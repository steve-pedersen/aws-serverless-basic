"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@hapi/hoek/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/@hapi/hoek/lib/stringify.js"(exports, module2) {
    "use strict";
    module2.exports = function(...args) {
      try {
        return JSON.stringify(...args);
      } catch (err) {
        return "[Cannot display object: " + err.message + "]";
      }
    };
  }
});

// node_modules/@hapi/hoek/lib/error.js
var require_error = __commonJS({
  "node_modules/@hapi/hoek/lib/error.js"(exports, module2) {
    "use strict";
    var Stringify = require_stringify();
    module2.exports = class extends Error {
      constructor(args) {
        const msgs = args.filter((arg) => arg !== "").map((arg) => {
          return typeof arg === "string" ? arg : arg instanceof Error ? arg.message : Stringify(arg);
        });
        super(msgs.join(" ") || "Unknown error");
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, exports.assert);
        }
      }
    };
  }
});

// node_modules/@hapi/hoek/lib/assert.js
var require_assert = __commonJS({
  "node_modules/@hapi/hoek/lib/assert.js"(exports, module2) {
    "use strict";
    var AssertError = require_error();
    module2.exports = function(condition, ...args) {
      if (condition) {
        return;
      }
      if (args.length === 1 && args[0] instanceof Error) {
        throw args[0];
      }
      throw new AssertError(args);
    };
  }
});

// node_modules/@hapi/hoek/lib/reach.js
var require_reach = __commonJS({
  "node_modules/@hapi/hoek/lib/reach.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var internals = {};
    module2.exports = function(obj, chain, options) {
      if (chain === false || chain === null || chain === void 0) {
        return obj;
      }
      options = options || {};
      if (typeof options === "string") {
        options = { separator: options };
      }
      const isChainArray = Array.isArray(chain);
      Assert(!isChainArray || !options.separator, "Separator option is not valid for array-based chain");
      const path = isChainArray ? chain : chain.split(options.separator || ".");
      let ref = obj;
      for (let i = 0; i < path.length; ++i) {
        let key = path[i];
        const type = options.iterables && internals.iterables(ref);
        if (Array.isArray(ref) || type === "set") {
          const number = Number(key);
          if (Number.isInteger(number)) {
            key = number < 0 ? ref.length + number : number;
          }
        }
        if (!ref || typeof ref === "function" && options.functions === false || !type && ref[key] === void 0) {
          Assert(!options.strict || i + 1 === path.length, "Missing segment", key, "in reach path ", chain);
          Assert(typeof ref === "object" || options.functions === true || typeof ref !== "function", "Invalid segment", key, "in reach path ", chain);
          ref = options.default;
          break;
        }
        if (!type) {
          ref = ref[key];
        } else if (type === "set") {
          ref = [...ref][key];
        } else {
          ref = ref.get(key);
        }
      }
      return ref;
    };
    internals.iterables = function(ref) {
      if (ref instanceof Set) {
        return "set";
      }
      if (ref instanceof Map) {
        return "map";
      }
    };
  }
});

// node_modules/@hapi/hoek/lib/types.js
var require_types = __commonJS({
  "node_modules/@hapi/hoek/lib/types.js"(exports, module2) {
    "use strict";
    var internals = {};
    exports = module2.exports = {
      array: Array.prototype,
      buffer: Buffer && Buffer.prototype,
      date: Date.prototype,
      error: Error.prototype,
      generic: Object.prototype,
      map: Map.prototype,
      promise: Promise.prototype,
      regex: RegExp.prototype,
      set: Set.prototype,
      weakMap: WeakMap.prototype,
      weakSet: WeakSet.prototype
    };
    internals.typeMap = /* @__PURE__ */ new Map([
      ["[object Error]", exports.error],
      ["[object Map]", exports.map],
      ["[object Promise]", exports.promise],
      ["[object Set]", exports.set],
      ["[object WeakMap]", exports.weakMap],
      ["[object WeakSet]", exports.weakSet]
    ]);
    exports.getInternalProto = function(obj) {
      if (Array.isArray(obj)) {
        return exports.array;
      }
      if (Buffer && obj instanceof Buffer) {
        return exports.buffer;
      }
      if (obj instanceof Date) {
        return exports.date;
      }
      if (obj instanceof RegExp) {
        return exports.regex;
      }
      if (obj instanceof Error) {
        return exports.error;
      }
      const objName = Object.prototype.toString.call(obj);
      return internals.typeMap.get(objName) || exports.generic;
    };
  }
});

// node_modules/@hapi/hoek/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@hapi/hoek/lib/utils.js"(exports) {
    "use strict";
    exports.keys = function(obj, options = {}) {
      return options.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);
    };
  }
});

// node_modules/@hapi/hoek/lib/clone.js
var require_clone = __commonJS({
  "node_modules/@hapi/hoek/lib/clone.js"(exports, module2) {
    "use strict";
    var Reach = require_reach();
    var Types = require_types();
    var Utils = require_utils();
    var internals = {
      needsProtoHack: /* @__PURE__ */ new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])
    };
    module2.exports = internals.clone = function(obj, options = {}, _seen = null) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      let clone = internals.clone;
      let seen = _seen;
      if (options.shallow) {
        if (options.shallow !== true) {
          return internals.cloneWithShallow(obj, options);
        }
        clone = (value) => value;
      } else if (seen) {
        const lookup = seen.get(obj);
        if (lookup) {
          return lookup;
        }
      } else {
        seen = /* @__PURE__ */ new Map();
      }
      const baseProto = Types.getInternalProto(obj);
      if (baseProto === Types.buffer) {
        return Buffer && Buffer.from(obj);
      }
      if (baseProto === Types.date) {
        return new Date(obj.getTime());
      }
      if (baseProto === Types.regex) {
        return new RegExp(obj);
      }
      const newObj = internals.base(obj, baseProto, options);
      if (newObj === obj) {
        return obj;
      }
      if (seen) {
        seen.set(obj, newObj);
      }
      if (baseProto === Types.set) {
        for (const value of obj) {
          newObj.add(clone(value, options, seen));
        }
      } else if (baseProto === Types.map) {
        for (const [key, value] of obj) {
          newObj.set(key, clone(value, options, seen));
        }
      }
      const keys = Utils.keys(obj, options);
      for (const key of keys) {
        if (key === "__proto__") {
          continue;
        }
        if (baseProto === Types.array && key === "length") {
          newObj.length = obj.length;
          continue;
        }
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor) {
          if (descriptor.get || descriptor.set) {
            Object.defineProperty(newObj, key, descriptor);
          } else if (descriptor.enumerable) {
            newObj[key] = clone(obj[key], options, seen);
          } else {
            Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone(obj[key], options, seen) });
          }
        } else {
          Object.defineProperty(newObj, key, {
            enumerable: true,
            writable: true,
            configurable: true,
            value: clone(obj[key], options, seen)
          });
        }
      }
      return newObj;
    };
    internals.cloneWithShallow = function(source, options) {
      const keys = options.shallow;
      options = Object.assign({}, options);
      options.shallow = false;
      const seen = /* @__PURE__ */ new Map();
      for (const key of keys) {
        const ref = Reach(source, key);
        if (typeof ref === "object" || typeof ref === "function") {
          seen.set(ref, ref);
        }
      }
      return internals.clone(source, options, seen);
    };
    internals.base = function(obj, baseProto, options) {
      if (options.prototype === false) {
        if (internals.needsProtoHack.has(baseProto)) {
          return new baseProto.constructor();
        }
        return baseProto === Types.array ? [] : {};
      }
      const proto = Object.getPrototypeOf(obj);
      if (proto && proto.isImmutable) {
        return obj;
      }
      if (baseProto === Types.array) {
        const newObj = [];
        if (proto !== baseProto) {
          Object.setPrototypeOf(newObj, proto);
        }
        return newObj;
      }
      if (internals.needsProtoHack.has(baseProto)) {
        const newObj = new proto.constructor();
        if (proto !== baseProto) {
          Object.setPrototypeOf(newObj, proto);
        }
        return newObj;
      }
      return Object.create(proto);
    };
  }
});

// node_modules/@hapi/hoek/lib/merge.js
var require_merge = __commonJS({
  "node_modules/@hapi/hoek/lib/merge.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Utils = require_utils();
    var internals = {};
    module2.exports = internals.merge = function(target, source, options) {
      Assert(target && typeof target === "object", "Invalid target value: must be an object");
      Assert(source === null || source === void 0 || typeof source === "object", "Invalid source value: must be null, undefined, or an object");
      if (!source) {
        return target;
      }
      options = Object.assign({ nullOverride: true, mergeArrays: true }, options);
      if (Array.isArray(source)) {
        Assert(Array.isArray(target), "Cannot merge array onto an object");
        if (!options.mergeArrays) {
          target.length = 0;
        }
        for (let i = 0; i < source.length; ++i) {
          target.push(Clone(source[i], { symbols: options.symbols }));
        }
        return target;
      }
      const keys = Utils.keys(source, options);
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key === "__proto__" || !Object.prototype.propertyIsEnumerable.call(source, key)) {
          continue;
        }
        const value = source[key];
        if (value && typeof value === "object") {
          if (target[key] === value) {
            continue;
          }
          if (!target[key] || typeof target[key] !== "object" || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer && Buffer.isBuffer(value) || value instanceof RegExp) {
            target[key] = Clone(value, { symbols: options.symbols });
          } else {
            internals.merge(target[key], value, options);
          }
        } else {
          if (value !== null && value !== void 0) {
            target[key] = value;
          } else if (options.nullOverride) {
            target[key] = value;
          }
        }
      }
      return target;
    };
  }
});

// node_modules/@hapi/hoek/lib/applyToDefaults.js
var require_applyToDefaults = __commonJS({
  "node_modules/@hapi/hoek/lib/applyToDefaults.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Merge = require_merge();
    var Reach = require_reach();
    var internals = {};
    module2.exports = function(defaults, source, options = {}) {
      Assert(defaults && typeof defaults === "object", "Invalid defaults value: must be an object");
      Assert(!source || source === true || typeof source === "object", "Invalid source value: must be true, falsy or an object");
      Assert(typeof options === "object", "Invalid options: must be an object");
      if (!source) {
        return null;
      }
      if (options.shallow) {
        return internals.applyToDefaultsWithShallow(defaults, source, options);
      }
      const copy = Clone(defaults);
      if (source === true) {
        return copy;
      }
      const nullOverride = options.nullOverride !== void 0 ? options.nullOverride : false;
      return Merge(copy, source, { nullOverride, mergeArrays: false });
    };
    internals.applyToDefaultsWithShallow = function(defaults, source, options) {
      const keys = options.shallow;
      Assert(Array.isArray(keys), "Invalid keys");
      const seen = /* @__PURE__ */ new Map();
      const merge = source === true ? null : /* @__PURE__ */ new Set();
      for (let key of keys) {
        key = Array.isArray(key) ? key : key.split(".");
        const ref = Reach(defaults, key);
        if (ref && typeof ref === "object") {
          seen.set(ref, merge && Reach(source, key) || ref);
        } else if (merge) {
          merge.add(key);
        }
      }
      const copy = Clone(defaults, {}, seen);
      if (!merge) {
        return copy;
      }
      for (const key of merge) {
        internals.reachCopy(copy, source, key);
      }
      const nullOverride = options.nullOverride !== void 0 ? options.nullOverride : false;
      return Merge(copy, source, { nullOverride, mergeArrays: false });
    };
    internals.reachCopy = function(dst, src, path) {
      for (const segment of path) {
        if (!(segment in src)) {
          return;
        }
        const val = src[segment];
        if (typeof val !== "object" || val === null) {
          return;
        }
        src = val;
      }
      const value = src;
      let ref = dst;
      for (let i = 0; i < path.length - 1; ++i) {
        const segment = path[i];
        if (typeof ref[segment] !== "object") {
          ref[segment] = {};
        }
        ref = ref[segment];
      }
      ref[path[path.length - 1]] = value;
    };
  }
});

// node_modules/@hapi/hoek/lib/bench.js
var require_bench = __commonJS({
  "node_modules/@hapi/hoek/lib/bench.js"(exports, module2) {
    "use strict";
    var internals = {};
    module2.exports = internals.Bench = class {
      constructor() {
        this.ts = 0;
        this.reset();
      }
      reset() {
        this.ts = internals.Bench.now();
      }
      elapsed() {
        return internals.Bench.now() - this.ts;
      }
      static now() {
        const ts = process.hrtime();
        return ts[0] * 1e3 + ts[1] / 1e6;
      }
    };
  }
});

// node_modules/@hapi/hoek/lib/ignore.js
var require_ignore = __commonJS({
  "node_modules/@hapi/hoek/lib/ignore.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
    };
  }
});

// node_modules/@hapi/hoek/lib/block.js
var require_block = __commonJS({
  "node_modules/@hapi/hoek/lib/block.js"(exports, module2) {
    "use strict";
    var Ignore = require_ignore();
    module2.exports = function() {
      return new Promise(Ignore);
    };
  }
});

// node_modules/@hapi/hoek/lib/deepEqual.js
var require_deepEqual = __commonJS({
  "node_modules/@hapi/hoek/lib/deepEqual.js"(exports, module2) {
    "use strict";
    var Types = require_types();
    var internals = {
      mismatched: null
    };
    module2.exports = function(obj, ref, options) {
      options = Object.assign({ prototype: true }, options);
      return !!internals.isDeepEqual(obj, ref, options, []);
    };
    internals.isDeepEqual = function(obj, ref, options, seen) {
      if (obj === ref) {
        return obj !== 0 || 1 / obj === 1 / ref;
      }
      const type = typeof obj;
      if (type !== typeof ref) {
        return false;
      }
      if (obj === null || ref === null) {
        return false;
      }
      if (type === "function") {
        if (!options.deepFunction || obj.toString() !== ref.toString()) {
          return false;
        }
      } else if (type !== "object") {
        return obj !== obj && ref !== ref;
      }
      const instanceType = internals.getSharedType(obj, ref, !!options.prototype);
      switch (instanceType) {
        case Types.buffer:
          return Buffer && Buffer.prototype.equals.call(obj, ref);
        case Types.promise:
          return obj === ref;
        case Types.regex:
          return obj.toString() === ref.toString();
        case internals.mismatched:
          return false;
      }
      for (let i = seen.length - 1; i >= 0; --i) {
        if (seen[i].isSame(obj, ref)) {
          return true;
        }
      }
      seen.push(new internals.SeenEntry(obj, ref));
      try {
        return !!internals.isDeepEqualObj(instanceType, obj, ref, options, seen);
      } finally {
        seen.pop();
      }
    };
    internals.getSharedType = function(obj, ref, checkPrototype) {
      if (checkPrototype) {
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
          return internals.mismatched;
        }
        return Types.getInternalProto(obj);
      }
      const type = Types.getInternalProto(obj);
      if (type !== Types.getInternalProto(ref)) {
        return internals.mismatched;
      }
      return type;
    };
    internals.valueOf = function(obj) {
      const objValueOf = obj.valueOf;
      if (objValueOf === void 0) {
        return obj;
      }
      try {
        return objValueOf.call(obj);
      } catch (err) {
        return err;
      }
    };
    internals.hasOwnEnumerableProperty = function(obj, key) {
      return Object.prototype.propertyIsEnumerable.call(obj, key);
    };
    internals.isSetSimpleEqual = function(obj, ref) {
      for (const entry of Set.prototype.values.call(obj)) {
        if (!Set.prototype.has.call(ref, entry)) {
          return false;
        }
      }
      return true;
    };
    internals.isDeepEqualObj = function(instanceType, obj, ref, options, seen) {
      const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
      const { keys, getOwnPropertySymbols } = Object;
      if (instanceType === Types.array) {
        if (options.part) {
          for (const objValue of obj) {
            for (const refValue of ref) {
              if (isDeepEqual(objValue, refValue, options, seen)) {
                return true;
              }
            }
          }
        } else {
          if (obj.length !== ref.length) {
            return false;
          }
          for (let i = 0; i < obj.length; ++i) {
            if (!isDeepEqual(obj[i], ref[i], options, seen)) {
              return false;
            }
          }
          return true;
        }
      } else if (instanceType === Types.set) {
        if (obj.size !== ref.size) {
          return false;
        }
        if (!internals.isSetSimpleEqual(obj, ref)) {
          const ref2 = new Set(Set.prototype.values.call(ref));
          for (const objEntry of Set.prototype.values.call(obj)) {
            if (ref2.delete(objEntry)) {
              continue;
            }
            let found = false;
            for (const refEntry of ref2) {
              if (isDeepEqual(objEntry, refEntry, options, seen)) {
                ref2.delete(refEntry);
                found = true;
                break;
              }
            }
            if (!found) {
              return false;
            }
          }
        }
      } else if (instanceType === Types.map) {
        if (obj.size !== ref.size) {
          return false;
        }
        for (const [key, value] of Map.prototype.entries.call(obj)) {
          if (value === void 0 && !Map.prototype.has.call(ref, key)) {
            return false;
          }
          if (!isDeepEqual(value, Map.prototype.get.call(ref, key), options, seen)) {
            return false;
          }
        }
      } else if (instanceType === Types.error) {
        if (obj.name !== ref.name || obj.message !== ref.message) {
          return false;
        }
      }
      const valueOfObj = valueOf(obj);
      const valueOfRef = valueOf(ref);
      if ((obj !== valueOfObj || ref !== valueOfRef) && !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {
        return false;
      }
      const objKeys = keys(obj);
      if (!options.part && objKeys.length !== keys(ref).length && !options.skip) {
        return false;
      }
      let skipped = 0;
      for (const key of objKeys) {
        if (options.skip && options.skip.includes(key)) {
          if (ref[key] === void 0) {
            ++skipped;
          }
          continue;
        }
        if (!hasOwnEnumerableProperty(ref, key)) {
          return false;
        }
        if (!isDeepEqual(obj[key], ref[key], options, seen)) {
          return false;
        }
      }
      if (!options.part && objKeys.length - skipped !== keys(ref).length) {
        return false;
      }
      if (options.symbols !== false) {
        const objSymbols = getOwnPropertySymbols(obj);
        const refSymbols = new Set(getOwnPropertySymbols(ref));
        for (const key of objSymbols) {
          if (!options.skip || !options.skip.includes(key)) {
            if (hasOwnEnumerableProperty(obj, key)) {
              if (!hasOwnEnumerableProperty(ref, key)) {
                return false;
              }
              if (!isDeepEqual(obj[key], ref[key], options, seen)) {
                return false;
              }
            } else if (hasOwnEnumerableProperty(ref, key)) {
              return false;
            }
          }
          refSymbols.delete(key);
        }
        for (const key of refSymbols) {
          if (hasOwnEnumerableProperty(ref, key)) {
            return false;
          }
        }
      }
      return true;
    };
    internals.SeenEntry = class {
      constructor(obj, ref) {
        this.obj = obj;
        this.ref = ref;
      }
      isSame(obj, ref) {
        return this.obj === obj && this.ref === ref;
      }
    };
  }
});

// node_modules/@hapi/hoek/lib/escapeRegex.js
var require_escapeRegex = __commonJS({
  "node_modules/@hapi/hoek/lib/escapeRegex.js"(exports, module2) {
    "use strict";
    module2.exports = function(string) {
      return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
    };
  }
});

// node_modules/@hapi/hoek/lib/contain.js
var require_contain = __commonJS({
  "node_modules/@hapi/hoek/lib/contain.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var EscapeRegex = require_escapeRegex();
    var Utils = require_utils();
    var internals = {};
    module2.exports = function(ref, values, options = {}) {
      if (typeof values !== "object") {
        values = [values];
      }
      Assert(!Array.isArray(values) || values.length, "Values array cannot be empty");
      if (typeof ref === "string") {
        return internals.string(ref, values, options);
      }
      if (Array.isArray(ref)) {
        return internals.array(ref, values, options);
      }
      Assert(typeof ref === "object", "Reference must be string or an object");
      return internals.object(ref, values, options);
    };
    internals.array = function(ref, values, options) {
      if (!Array.isArray(values)) {
        values = [values];
      }
      if (!ref.length) {
        return false;
      }
      if (options.only && options.once && ref.length !== values.length) {
        return false;
      }
      let compare;
      const map = /* @__PURE__ */ new Map();
      for (const value of values) {
        if (!options.deep || !value || typeof value !== "object") {
          const existing = map.get(value);
          if (existing) {
            ++existing.allowed;
          } else {
            map.set(value, { allowed: 1, hits: 0 });
          }
        } else {
          compare = compare || internals.compare(options);
          let found = false;
          for (const [key, existing] of map.entries()) {
            if (compare(key, value)) {
              ++existing.allowed;
              found = true;
              break;
            }
          }
          if (!found) {
            map.set(value, { allowed: 1, hits: 0 });
          }
        }
      }
      let hits = 0;
      for (const item of ref) {
        let match;
        if (!options.deep || !item || typeof item !== "object") {
          match = map.get(item);
        } else {
          compare = compare || internals.compare(options);
          for (const [key, existing] of map.entries()) {
            if (compare(key, item)) {
              match = existing;
              break;
            }
          }
        }
        if (match) {
          ++match.hits;
          ++hits;
          if (options.once && match.hits > match.allowed) {
            return false;
          }
        }
      }
      if (options.only && hits !== ref.length) {
        return false;
      }
      for (const match of map.values()) {
        if (match.hits === match.allowed) {
          continue;
        }
        if (match.hits < match.allowed && !options.part) {
          return false;
        }
      }
      return !!hits;
    };
    internals.object = function(ref, values, options) {
      Assert(options.once === void 0, "Cannot use option once with object");
      const keys = Utils.keys(ref, options);
      if (!keys.length) {
        return false;
      }
      if (Array.isArray(values)) {
        return internals.array(keys, values, options);
      }
      const symbols = Object.getOwnPropertySymbols(values).filter((sym) => values.propertyIsEnumerable(sym));
      const targets = [...Object.keys(values), ...symbols];
      const compare = internals.compare(options);
      const set = new Set(targets);
      for (const key of keys) {
        if (!set.has(key)) {
          if (options.only) {
            return false;
          }
          continue;
        }
        if (!compare(values[key], ref[key])) {
          return false;
        }
        set.delete(key);
      }
      if (set.size) {
        return options.part ? set.size < targets.length : false;
      }
      return true;
    };
    internals.string = function(ref, values, options) {
      if (ref === "") {
        return values.length === 1 && values[0] === "" || !options.once && !values.some((v) => v !== "");
      }
      const map = /* @__PURE__ */ new Map();
      const patterns = [];
      for (const value of values) {
        Assert(typeof value === "string", "Cannot compare string reference to non-string value");
        if (value) {
          const existing = map.get(value);
          if (existing) {
            ++existing.allowed;
          } else {
            map.set(value, { allowed: 1, hits: 0 });
            patterns.push(EscapeRegex(value));
          }
        } else if (options.once || options.only) {
          return false;
        }
      }
      if (!patterns.length) {
        return true;
      }
      const regex = new RegExp(`(${patterns.join("|")})`, "g");
      const leftovers = ref.replace(regex, ($0, $1) => {
        ++map.get($1).hits;
        return "";
      });
      if (options.only && leftovers) {
        return false;
      }
      let any = false;
      for (const match of map.values()) {
        if (match.hits) {
          any = true;
        }
        if (match.hits === match.allowed) {
          continue;
        }
        if (match.hits < match.allowed && !options.part) {
          return false;
        }
        if (options.once) {
          return false;
        }
      }
      return !!any;
    };
    internals.compare = function(options) {
      if (!options.deep) {
        return internals.shallow;
      }
      const hasOnly = options.only !== void 0;
      const hasPart = options.part !== void 0;
      const flags = {
        prototype: hasOnly ? options.only : hasPart ? !options.part : false,
        part: hasOnly ? !options.only : hasPart ? options.part : false
      };
      return (a, b) => DeepEqual(a, b, flags);
    };
    internals.shallow = function(a, b) {
      return a === b;
    };
  }
});

// node_modules/@hapi/hoek/lib/escapeHeaderAttribute.js
var require_escapeHeaderAttribute = __commonJS({
  "node_modules/@hapi/hoek/lib/escapeHeaderAttribute.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    module2.exports = function(attribute) {
      Assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), "Bad attribute value (" + attribute + ")");
      return attribute.replace(/\\/g, "\\\\").replace(/\"/g, '\\"');
    };
  }
});

// node_modules/@hapi/hoek/lib/escapeHtml.js
var require_escapeHtml = __commonJS({
  "node_modules/@hapi/hoek/lib/escapeHtml.js"(exports, module2) {
    "use strict";
    var internals = {};
    module2.exports = function(input) {
      if (!input) {
        return "";
      }
      let escaped = "";
      for (let i = 0; i < input.length; ++i) {
        const charCode = input.charCodeAt(i);
        if (internals.isSafe(charCode)) {
          escaped += input[i];
        } else {
          escaped += internals.escapeHtmlChar(charCode);
        }
      }
      return escaped;
    };
    internals.escapeHtmlChar = function(charCode) {
      const namedEscape = internals.namedHtml.get(charCode);
      if (namedEscape) {
        return namedEscape;
      }
      if (charCode >= 256) {
        return "&#" + charCode + ";";
      }
      const hexValue = charCode.toString(16).padStart(2, "0");
      return `&#x${hexValue};`;
    };
    internals.isSafe = function(charCode) {
      return internals.safeCharCodes.has(charCode);
    };
    internals.namedHtml = /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [34, "&quot;"],
      [160, "&nbsp;"],
      [162, "&cent;"],
      [163, "&pound;"],
      [164, "&curren;"],
      [169, "&copy;"],
      [174, "&reg;"]
    ]);
    internals.safeCharCodes = function() {
      const safe = /* @__PURE__ */ new Set();
      for (let i = 32; i < 123; ++i) {
        if (i >= 97 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 32 || i === 46 || i === 44 || i === 45 || i === 58 || i === 95) {
          safe.add(i);
        }
      }
      return safe;
    }();
  }
});

// node_modules/@hapi/hoek/lib/escapeJson.js
var require_escapeJson = __commonJS({
  "node_modules/@hapi/hoek/lib/escapeJson.js"(exports, module2) {
    "use strict";
    var internals = {};
    module2.exports = function(input) {
      if (!input) {
        return "";
      }
      return input.replace(/[<>&\u2028\u2029]/g, internals.escape);
    };
    internals.escape = function(char) {
      return internals.replacements.get(char);
    };
    internals.replacements = /* @__PURE__ */ new Map([
      ["<", "\\u003c"],
      [">", "\\u003e"],
      ["&", "\\u0026"],
      ["\u2028", "\\u2028"],
      ["\u2029", "\\u2029"]
    ]);
  }
});

// node_modules/@hapi/hoek/lib/flatten.js
var require_flatten = __commonJS({
  "node_modules/@hapi/hoek/lib/flatten.js"(exports, module2) {
    "use strict";
    var internals = {};
    module2.exports = internals.flatten = function(array, target) {
      const result = target || [];
      for (const entry of array) {
        if (Array.isArray(entry)) {
          internals.flatten(entry, result);
        } else {
          result.push(entry);
        }
      }
      return result;
    };
  }
});

// node_modules/@hapi/hoek/lib/intersect.js
var require_intersect = __commonJS({
  "node_modules/@hapi/hoek/lib/intersect.js"(exports, module2) {
    "use strict";
    var internals = {};
    module2.exports = function(array1, array2, options = {}) {
      if (!array1 || !array2) {
        return options.first ? null : [];
      }
      const common = [];
      const hash = Array.isArray(array1) ? new Set(array1) : array1;
      const found = /* @__PURE__ */ new Set();
      for (const value of array2) {
        if (internals.has(hash, value) && !found.has(value)) {
          if (options.first) {
            return value;
          }
          common.push(value);
          found.add(value);
        }
      }
      return options.first ? null : common;
    };
    internals.has = function(ref, key) {
      if (typeof ref.has === "function") {
        return ref.has(key);
      }
      return ref[key] !== void 0;
    };
  }
});

// node_modules/@hapi/hoek/lib/isPromise.js
var require_isPromise = __commonJS({
  "node_modules/@hapi/hoek/lib/isPromise.js"(exports, module2) {
    "use strict";
    module2.exports = function(promise) {
      return !!promise && typeof promise.then === "function";
    };
  }
});

// node_modules/@hapi/hoek/lib/once.js
var require_once = __commonJS({
  "node_modules/@hapi/hoek/lib/once.js"(exports, module2) {
    "use strict";
    var internals = {
      wrapped: Symbol("wrapped")
    };
    module2.exports = function(method) {
      if (method[internals.wrapped]) {
        return method;
      }
      let once = false;
      const wrappedFn = function(...args) {
        if (!once) {
          once = true;
          method(...args);
        }
      };
      wrappedFn[internals.wrapped] = true;
      return wrappedFn;
    };
  }
});

// node_modules/@hapi/hoek/lib/reachTemplate.js
var require_reachTemplate = __commonJS({
  "node_modules/@hapi/hoek/lib/reachTemplate.js"(exports, module2) {
    "use strict";
    var Reach = require_reach();
    module2.exports = function(obj, template, options) {
      return template.replace(/{([^{}]+)}/g, ($0, chain) => {
        const value = Reach(obj, chain, options);
        return value === void 0 || value === null ? "" : value;
      });
    };
  }
});

// node_modules/@hapi/hoek/lib/wait.js
var require_wait = __commonJS({
  "node_modules/@hapi/hoek/lib/wait.js"(exports, module2) {
    "use strict";
    var internals = {
      maxTimer: 2 ** 31 - 1
    };
    module2.exports = function(timeout, returnValue, options) {
      if (typeof timeout === "bigint") {
        timeout = Number(timeout);
      }
      if (timeout >= Number.MAX_SAFE_INTEGER) {
        timeout = Infinity;
      }
      if (typeof timeout !== "number" && timeout !== void 0) {
        throw new TypeError("Timeout must be a number or bigint");
      }
      return new Promise((resolve) => {
        const _setTimeout = options ? options.setTimeout : setTimeout;
        const activate = () => {
          const time = Math.min(timeout, internals.maxTimer);
          timeout -= time;
          _setTimeout(() => timeout > 0 ? activate() : resolve(returnValue), time);
        };
        if (timeout !== Infinity) {
          activate();
        }
      });
    };
  }
});

// node_modules/@hapi/hoek/lib/index.js
var require_lib = __commonJS({
  "node_modules/@hapi/hoek/lib/index.js"(exports) {
    "use strict";
    exports.applyToDefaults = require_applyToDefaults();
    exports.assert = require_assert();
    exports.Bench = require_bench();
    exports.block = require_block();
    exports.clone = require_clone();
    exports.contain = require_contain();
    exports.deepEqual = require_deepEqual();
    exports.Error = require_error();
    exports.escapeHeaderAttribute = require_escapeHeaderAttribute();
    exports.escapeHtml = require_escapeHtml();
    exports.escapeJson = require_escapeJson();
    exports.escapeRegex = require_escapeRegex();
    exports.flatten = require_flatten();
    exports.ignore = require_ignore();
    exports.intersect = require_intersect();
    exports.isPromise = require_isPromise();
    exports.merge = require_merge();
    exports.once = require_once();
    exports.reach = require_reach();
    exports.reachTemplate = require_reachTemplate();
    exports.stringify = require_stringify();
    exports.wait = require_wait();
  }
});

// node_modules/@hapi/validate/package.json
var require_package = __commonJS({
  "node_modules/@hapi/validate/package.json"(exports, module2) {
    module2.exports = {
      name: "@hapi/validate",
      description: "Object schema validation",
      version: "1.1.3",
      repository: "git://github.com/hapijs/validate",
      main: "lib/index.js",
      files: [
        "lib/**/*"
      ],
      dependencies: {
        "@hapi/hoek": "^9.0.0",
        "@hapi/topo": "^5.0.0"
      },
      devDependencies: {
        "@hapi/bourne": "2.x.x",
        "@hapi/code": "8.x.x",
        "@hapi/lab": "24.x.x"
      },
      scripts: {
        test: "lab -t 100 -a @hapi/code -L",
        "test-cov-html": "lab -r html -o coverage.html -a @hapi/code"
      },
      license: "BSD-3-Clause"
    };
  }
});

// node_modules/@hapi/validate/lib/schemas.js
var require_schemas = __commonJS({
  "node_modules/@hapi/validate/lib/schemas.js"(exports) {
    "use strict";
    var Joi2 = require_lib3();
    var internals = {};
    internals.wrap = Joi2.string().min(1).max(2).allow(false);
    exports.preferences = Joi2.object({
      allowUnknown: Joi2.boolean(),
      abortEarly: Joi2.boolean(),
      context: Joi2.object(),
      convert: Joi2.boolean(),
      dateFormat: Joi2.valid("date", "iso", "string", "time", "utc"),
      errors: {
        escapeHtml: Joi2.boolean(),
        label: Joi2.valid("path", "key", false),
        language: [
          Joi2.string(),
          Joi2.object().ref()
        ],
        render: Joi2.boolean(),
        stack: Joi2.boolean(),
        wrap: {
          label: internals.wrap,
          array: internals.wrap
        }
      },
      messages: Joi2.object(),
      noDefaults: Joi2.boolean(),
      nonEnumerables: Joi2.boolean(),
      presence: Joi2.valid("required", "optional", "forbidden"),
      skipFunctions: Joi2.boolean(),
      stripUnknown: Joi2.object({
        arrays: Joi2.boolean(),
        objects: Joi2.boolean()
      }).or("arrays", "objects").allow(true, false)
    }).strict();
  }
});

// node_modules/@hapi/validate/lib/ref.js
var require_ref = __commonJS({
  "node_modules/@hapi/validate/lib/ref.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Reach = require_reach();
    var Common = require_common();
    var internals = {
      symbol: Symbol("ref"),
      defaults: {
        adjust: null,
        in: false,
        iterables: null,
        map: null,
        separator: ".",
        type: "value"
      }
    };
    exports.create = function(key, options = {}) {
      Assert(typeof key === "string", "Invalid reference key:", key);
      Common.assertOptions(options, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "separator"]);
      Assert(!options.prefix || typeof options.prefix === "object", "options.prefix must be of type object");
      const ref = Object.assign({}, internals.defaults, options);
      delete ref.prefix;
      const separator = ref.separator;
      const context = internals.context(key, separator, options.prefix);
      ref.type = context.type;
      key = context.key;
      if (ref.type === "value") {
        if (context.root) {
          Assert(!separator || key[0] !== separator, "Cannot specify relative path with root prefix");
          ref.ancestor = "root";
          if (!key) {
            key = null;
          }
        }
        if (separator && separator === key) {
          key = null;
          ref.ancestor = 0;
        } else {
          if (ref.ancestor !== void 0) {
            Assert(!separator || !key || key[0] !== separator, "Cannot combine prefix with ancestor option");
          } else {
            const [ancestor, slice] = internals.ancestor(key, separator);
            if (slice) {
              key = key.slice(slice);
              if (key === "") {
                key = null;
              }
            }
            ref.ancestor = ancestor;
          }
        }
      }
      ref.path = separator ? key === null ? [] : key.split(separator) : [key];
      return new internals.Ref(ref);
    };
    exports.in = function(key, options = {}) {
      return exports.create(key, Object.assign({}, options, { in: true }));
    };
    exports.isRef = function(ref) {
      return ref ? !!ref[Common.symbols.ref] : false;
    };
    internals.Ref = class {
      constructor(options) {
        Assert(typeof options === "object", "Invalid reference construction");
        Common.assertOptions(options, [
          "adjust",
          "ancestor",
          "in",
          "iterables",
          "map",
          "path",
          "separator",
          "type",
          "depth",
          "key",
          "root",
          "display"
        ]);
        Assert([false, void 0].includes(options.separator) || typeof options.separator === "string" && options.separator.length === 1, "Invalid separator");
        Assert(!options.adjust || typeof options.adjust === "function", "options.adjust must be a function");
        Assert(!options.map || Array.isArray(options.map), "options.map must be an array");
        Assert(!options.map || !options.adjust, "Cannot set both map and adjust options");
        Object.assign(this, internals.defaults, options);
        Assert(this.type === "value" || this.ancestor === void 0, "Non-value references cannot reference ancestors");
        if (Array.isArray(this.map)) {
          this.map = new Map(this.map);
        }
        this.depth = this.path.length;
        this.key = this.path.length ? this.path.join(this.separator) : null;
        this.root = this.path[0];
        this.updateDisplay();
      }
      resolve(value, state, prefs, local2, options = {}) {
        Assert(!this.in || options.in, "Invalid in() reference usage");
        if (this.type === "global") {
          return this._resolve(prefs.context, state, options);
        }
        if (this.type === "local") {
          return this._resolve(local2, state, options);
        }
        if (!this.ancestor) {
          return this._resolve(value, state, options);
        }
        if (this.ancestor === "root") {
          return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);
        }
        Assert(this.ancestor <= state.ancestors.length, "Invalid reference exceeds the schema root:", this.display);
        return this._resolve(state.ancestors[this.ancestor - 1], state, options);
      }
      _resolve(target, state, options) {
        let resolved;
        if (this.type === "value" && state.mainstay.shadow && options.shadow !== false) {
          resolved = state.mainstay.shadow.get(this.absolute(state));
        }
        if (resolved === void 0) {
          resolved = Reach(target, this.path, { iterables: this.iterables, functions: true });
        }
        if (this.adjust) {
          resolved = this.adjust(resolved);
        }
        if (this.map) {
          const mapped = this.map.get(resolved);
          if (mapped !== void 0) {
            resolved = mapped;
          }
        }
        return resolved;
      }
      toString() {
        return this.display;
      }
      absolute(state) {
        return [...state.path.slice(0, -this.ancestor), ...this.path];
      }
      clone() {
        return new internals.Ref(this);
      }
      updateDisplay() {
        const key = this.key !== null ? this.key : "";
        if (this.type !== "value") {
          this.display = `ref:${this.type}:${key}`;
          return;
        }
        if (!this.separator) {
          this.display = `ref:${key}`;
          return;
        }
        if (!this.ancestor) {
          this.display = `ref:${this.separator}${key}`;
          return;
        }
        if (this.ancestor === "root") {
          this.display = `ref:root:${key}`;
          return;
        }
        if (this.ancestor === 1) {
          this.display = `ref:${key || ".."}`;
          return;
        }
        const lead = new Array(this.ancestor + 1).fill(this.separator).join("");
        this.display = `ref:${lead}${key || ""}`;
      }
    };
    internals.Ref.prototype[Common.symbols.ref] = true;
    internals.context = function(key, separator, prefix = {}) {
      key = key.trim();
      if (prefix) {
        const globalp = prefix.global === void 0 ? "$" : prefix.global;
        if (globalp !== separator && key.startsWith(globalp)) {
          return { key: key.slice(globalp.length), type: "global" };
        }
        const local2 = prefix.local === void 0 ? "#" : prefix.local;
        if (local2 !== separator && key.startsWith(local2)) {
          return { key: key.slice(local2.length), type: "local" };
        }
        const root = prefix.root === void 0 ? "/" : prefix.root;
        if (root !== separator && key.startsWith(root)) {
          return { key: key.slice(root.length), type: "value", root: true };
        }
      }
      return { key, type: "value" };
    };
    internals.ancestor = function(key, separator) {
      if (!separator) {
        return [1, 0];
      }
      if (key[0] !== separator) {
        return [1, 0];
      }
      if (key[1] !== separator) {
        return [0, 1];
      }
      let i = 2;
      while (key[i] === separator) {
        ++i;
      }
      return [i - 1, i];
    };
    exports.toSibling = 0;
    exports.toParent = 1;
    exports.Manager = class {
      constructor() {
        this.refs = [];
      }
      register(source, target) {
        if (!source) {
          return;
        }
        target = target === void 0 ? exports.toParent : target;
        if (Array.isArray(source)) {
          for (const ref of source) {
            this.register(ref, target);
          }
          return;
        }
        if (Common.isSchema(source)) {
          for (const item of source._refs.refs) {
            if (item.ancestor - target >= 0) {
              this.refs.push({ ancestor: item.ancestor - target, root: item.root });
            }
          }
          return;
        }
        if (exports.isRef(source) && source.type === "value" && source.ancestor - target >= 0) {
          this.refs.push({ ancestor: source.ancestor - target, root: source.root });
        }
      }
      clone() {
        const copy = new exports.Manager();
        copy.refs = Clone(this.refs);
        return copy;
      }
      reset() {
        this.refs = [];
      }
      roots() {
        return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);
      }
    };
  }
});

// node_modules/@hapi/validate/lib/template.js
var require_template = __commonJS({
  "node_modules/@hapi/validate/lib/template.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var EscapeHtml = require_escapeHtml();
    var Common = require_common();
    var Ref = require_ref();
    var internals = {
      symbol: Symbol("template"),
      opens: new Array(1e3).join("\0"),
      closes: new Array(1e3).join(""),
      dateFormat: {
        date: Date.prototype.toDateString,
        iso: Date.prototype.toISOString,
        string: Date.prototype.toString,
        time: Date.prototype.toTimeString,
        utc: Date.prototype.toUTCString
      }
    };
    module2.exports = exports = internals.Template = class {
      constructor(source, options) {
        Assert(typeof source === "string", "Template source must be a string");
        Assert(!source.includes("\0") && !source.includes(""), "Template source cannot contain reserved control characters");
        this.source = source;
        this.rendered = source;
        this._template = null;
        this._settings = Clone(options);
        this._parse();
      }
      _parse() {
        if (!this.source.includes("{")) {
          return;
        }
        const encoded = internals.encode(this.source);
        const parts = internals.split(encoded);
        const processed = [];
        const head = parts.shift();
        if (head) {
          processed.push(head);
        }
        for (const part of parts) {
          const raw = part[0] !== "{";
          const ender = raw ? "}" : "}}";
          const end = part.indexOf(ender);
          let variable = part.slice(raw ? 0 : 1, end);
          const wrapped = variable[0] === ":";
          if (wrapped) {
            variable = variable.slice(1);
          }
          const dynamic = this._ref(internals.decode(variable), { raw, wrapped });
          processed.push(dynamic);
          const rest = part.slice(end + ender.length);
          if (rest) {
            processed.push(internals.decode(rest));
          }
        }
        this._template = processed;
      }
      static date(date, prefs) {
        return internals.dateFormat[prefs.dateFormat].call(date);
      }
      isDynamic() {
        return !!this._template;
      }
      static isTemplate(template) {
        return template ? !!template[Common.symbols.template] : false;
      }
      render(value, state, prefs, local2, options = {}) {
        if (!this.isDynamic()) {
          return this.rendered;
        }
        const parts = [];
        for (const part of this._template) {
          if (typeof part === "string") {
            parts.push(part);
          } else {
            const rendered = part.ref.resolve(value, state, prefs, local2, options);
            const string = internals.stringify(rendered, prefs, options.errors);
            const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : EscapeHtml(string);
            parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));
          }
        }
        return parts.join("");
      }
      _ref(content, { raw, wrapped }) {
        const ref = Ref.create(content, this._settings);
        return { ref, raw, wrapped: wrapped || ref.type === "local" && ref.key === "label" };
      }
      toString() {
        return this.source;
      }
    };
    internals.Template.prototype[Common.symbols.template] = true;
    internals.Template.prototype.isImmutable = true;
    internals.encode = function(string) {
      return string.replace(/\\(\{+)/g, ($0, $1) => {
        return internals.opens.slice(0, $1.length);
      }).replace(/\\(\}+)/g, ($0, $1) => {
        return internals.closes.slice(0, $1.length);
      });
    };
    internals.decode = function(string) {
      return string.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
    };
    internals.split = function(string) {
      const parts = [];
      let current = "";
      for (let i = 0; i < string.length; ++i) {
        const char = string[i];
        if (char === "{") {
          let next = "";
          while (i + 1 < string.length && string[i + 1] === "{") {
            next += "{";
            ++i;
          }
          parts.push(current);
          current = next;
        } else {
          current += char;
        }
      }
      parts.push(current);
      return parts;
    };
    internals.wrap = function(value, ends) {
      if (!ends) {
        return value;
      }
      if (ends.length === 1) {
        return `${ends}${value}${ends}`;
      }
      return `${ends[0]}${value}${ends[1]}`;
    };
    internals.stringify = function(value, prefs, options) {
      const type = typeof value;
      if (value === null) {
        return "null";
      }
      if (value === void 0) {
        return "";
      }
      if (type === "string") {
        return value;
      }
      if (type === "number" || type === "function" || type === "symbol") {
        return value.toString();
      }
      if (type !== "object") {
        return JSON.stringify(value);
      }
      if (value instanceof Date) {
        return internals.Template.date(value, prefs);
      }
      if (value instanceof Map) {
        const pairs = [];
        for (const [key, sym] of value.entries()) {
          pairs.push(`${key.toString()} -> ${sym.toString()}`);
        }
        value = pairs;
      }
      if (!Array.isArray(value)) {
        return value.toString();
      }
      let partial = "";
      for (const item of value) {
        partial = partial + (partial.length ? ", " : "") + internals.stringify(item, prefs, options);
      }
      return internals.wrap(partial, prefs.errors.wrap.array);
    };
  }
});

// node_modules/@hapi/validate/lib/messages.js
var require_messages = __commonJS({
  "node_modules/@hapi/validate/lib/messages.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Template = require_template();
    exports.compile = function(messages, target) {
      if (typeof messages === "string") {
        Assert(!target, "Cannot set single message string");
        return new Template(messages);
      }
      if (Template.isTemplate(messages)) {
        Assert(!target, "Cannot set single message template");
        return messages;
      }
      Assert(typeof messages === "object" && !Array.isArray(messages), "Invalid message options");
      target = target ? Clone(target) : {};
      for (let code in messages) {
        const message = messages[code];
        if (code === "root" || Template.isTemplate(message)) {
          target[code] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code] = new Template(message);
          continue;
        }
        Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
        const language = code;
        target[language] = target[language] || {};
        for (code in message) {
          const localized = message[code];
          if (code === "root" || Template.isTemplate(localized)) {
            target[language][code] = localized;
            continue;
          }
          Assert(typeof localized === "string", "Invalid message for", code, "in", language);
          target[language][code] = new Template(localized);
        }
      }
      return target;
    };
    exports.merge = function(base, extended) {
      if (!base) {
        return exports.compile(extended);
      }
      if (!extended) {
        return base;
      }
      if (typeof extended === "string") {
        return new Template(extended);
      }
      if (Template.isTemplate(extended)) {
        return extended;
      }
      const target = Clone(base);
      for (let code in extended) {
        const message = extended[code];
        if (code === "root" || Template.isTemplate(message)) {
          target[code] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code] = new Template(message);
          continue;
        }
        Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
        const language = code;
        target[language] = target[language] || {};
        for (code in message) {
          const localized = message[code];
          if (code === "root" || Template.isTemplate(localized)) {
            target[language][code] = localized;
            continue;
          }
          Assert(typeof localized === "string", "Invalid message for", code, "in", language);
          target[language][code] = new Template(localized);
        }
      }
      return target;
    };
  }
});

// node_modules/@hapi/validate/lib/common.js
var require_common = __commonJS({
  "node_modules/@hapi/validate/lib/common.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var AssertError = require_error();
    var Pkg = require_package();
    var Messages;
    var Schemas;
    var internals = {
      isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
    };
    exports.version = Pkg.version;
    exports.defaults = {
      abortEarly: true,
      allowUnknown: false,
      context: null,
      convert: true,
      dateFormat: "iso",
      errors: {
        escapeHtml: false,
        label: "path",
        language: null,
        render: true,
        stack: false,
        wrap: {
          label: '"',
          array: "[]"
        }
      },
      messages: {},
      nonEnumerables: false,
      noDefaults: false,
      presence: "optional",
      skipFunctions: false,
      stripUnknown: false
    };
    exports.symbols = {
      any: Symbol.for("@hapi/joi/schema"),
      arraySingle: Symbol("arraySingle"),
      deepDefault: Symbol("deepDefault"),
      errors: Symbol("errors"),
      literal: Symbol("literal"),
      override: Symbol("override"),
      parent: Symbol("parent"),
      prefs: Symbol("prefs"),
      ref: Symbol("ref"),
      template: Symbol("template"),
      values: Symbol("values")
    };
    exports.assertOptions = function(options, keys, name = "Options") {
      Assert(options && typeof options === "object" && !Array.isArray(options), "Options must be of type object");
      const unknownKeys = Object.keys(options).filter((k) => !keys.includes(k));
      Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);
    };
    exports.checkPreferences = function(prefs) {
      Schemas = Schemas || require_schemas();
      const result = Schemas.preferences.validate(prefs);
      if (result.error) {
        throw new AssertError([result.error.details[0].message]);
      }
    };
    exports.compare = function(a, b, operator) {
      switch (operator) {
        case "=":
          return a === b;
        case ">":
          return a > b;
        case "<":
          return a < b;
        case ">=":
          return a >= b;
        case "<=":
          return a <= b;
      }
    };
    exports.default = function(value, defaultValue) {
      return value === void 0 ? defaultValue : value;
    };
    exports.isIsoDate = function(date) {
      return internals.isoDate.test(date);
    };
    exports.isNumber = function(value) {
      return typeof value === "number" && !isNaN(value);
    };
    exports.isResolvable = function(obj) {
      if (!obj) {
        return false;
      }
      return obj[exports.symbols.ref] || obj[exports.symbols.template];
    };
    exports.isSchema = function(schema, options = {}) {
      const any = schema && schema[exports.symbols.any];
      if (!any) {
        return false;
      }
      return true;
    };
    exports.limit = function(value) {
      return Number.isSafeInteger(value) && value >= 0;
    };
    exports.preferences = function(target, source) {
      Messages = Messages || require_messages();
      target = target || {};
      source = source || {};
      const merged = Object.assign({}, target, source);
      if (source.errors && target.errors) {
        merged.errors = Object.assign({}, target.errors, source.errors);
        merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);
      }
      if (source.messages) {
        merged.messages = Messages.compile(source.messages, target.messages);
      }
      delete merged[exports.symbols.prefs];
      return merged;
    };
    exports.tryWithPath = function(fn, key, options = {}) {
      try {
        return fn();
      } catch (err) {
        if (err.path !== void 0) {
          err.path = key + "." + err.path;
        } else {
          err.path = key;
        }
        if (options.append) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    exports.validateArg = function(value, label, { assert, message }) {
      if (exports.isSchema(assert)) {
        const result = assert.validate(value);
        if (!result.error) {
          return;
        }
        return result.error.message;
      } else if (!assert(value)) {
        return label ? `${label} ${message}` : message;
      }
    };
    exports.verifyFlat = function(args, method) {
      for (const arg of args) {
        Assert(!Array.isArray(arg), "Method no longer accepts array arguments:", method);
      }
    };
  }
});

// node_modules/@hapi/validate/lib/compile.js
var require_compile = __commonJS({
  "node_modules/@hapi/validate/lib/compile.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Common = require_common();
    var Ref = require_ref();
    var internals = {};
    exports.schema = function(Joi2, config, options = {}) {
      Common.assertOptions(options, ["appendPath", "override"]);
      try {
        return internals.schema(Joi2, config, options);
      } catch (err) {
        if (options.appendPath && err.path !== void 0) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    internals.schema = function(Joi2, config, options) {
      Assert(config !== void 0, "Invalid undefined schema");
      if (Array.isArray(config)) {
        Assert(config.length, "Invalid empty array schema");
        if (config.length === 1) {
          config = config[0];
        }
      }
      const valid = (base, ...values) => {
        if (options.override !== false) {
          return base.valid(Joi2.override, ...values);
        }
        return base.valid(...values);
      };
      if (internals.simple(config)) {
        return valid(Joi2, config);
      }
      if (typeof config === "function") {
        return Joi2.custom(config);
      }
      Assert(typeof config === "object", "Invalid schema content:", typeof config);
      if (Common.isResolvable(config)) {
        return valid(Joi2, config);
      }
      if (Common.isSchema(config)) {
        return config;
      }
      if (Array.isArray(config)) {
        for (const item of config) {
          if (!internals.simple(item)) {
            return Joi2.alternatives().try(...config);
          }
        }
        return valid(Joi2, ...config);
      }
      if (config instanceof RegExp) {
        return Joi2.string().regex(config);
      }
      if (config instanceof Date) {
        return valid(Joi2.date(), config);
      }
      Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      return Joi2.object().keys(config);
    };
    exports.ref = function(id, options) {
      return Ref.isRef(id) ? id : Ref.create(id, options);
    };
    exports.compile = function(root, schema) {
      const any = schema && schema[Common.symbols.any];
      if (any) {
        Assert(any.version === Common.version, "Cannot mix different versions of joi schemas:", any.version, Common.version);
        return schema;
      }
      return exports.schema(root, schema, { appendPath: true });
    };
    internals.simple = function(value) {
      return value === null || ["boolean", "string", "number"].includes(typeof value);
    };
    exports.when = function(schema, condition, options) {
      if (options === void 0) {
        Assert(condition && typeof condition === "object", "Missing options");
        options = condition;
        condition = Ref.create(".");
      }
      if (Array.isArray(options)) {
        options = { switch: options };
      }
      Common.assertOptions(options, ["is", "not", "then", "otherwise", "switch", "break"]);
      if (Common.isSchema(condition)) {
        Assert(options.is === void 0, '"is" can not be used with a schema condition');
        Assert(options.not === void 0, '"not" can not be used with a schema condition');
        Assert(options.switch === void 0, '"switch" can not be used with a schema condition');
        return internals.condition(schema, { is: condition, then: options.then, otherwise: options.otherwise, break: options.break });
      }
      Assert(Ref.isRef(condition) || typeof condition === "string", "Invalid condition:", condition);
      Assert(options.not === void 0 || options.is === void 0, 'Cannot combine "is" with "not"');
      if (options.switch === void 0) {
        let rule2 = options;
        if (options.not !== void 0) {
          rule2 = { is: options.not, then: options.otherwise, otherwise: options.then, break: options.break };
        }
        let is = rule2.is !== void 0 ? schema.$_compile(rule2.is) : schema.$_root.invalid(null, false, 0, "").required();
        Assert(rule2.then !== void 0 || rule2.otherwise !== void 0, 'options must have at least one of "then", "otherwise", or "switch"');
        Assert(rule2.break === void 0 || rule2.then === void 0 || rule2.otherwise === void 0, "Cannot specify then, otherwise, and break all together");
        if (options.is !== void 0 && !Ref.isRef(options.is) && !Common.isSchema(options.is)) {
          is = is.required();
        }
        return internals.condition(schema, { ref: exports.ref(condition), is, then: rule2.then, otherwise: rule2.otherwise, break: rule2.break });
      }
      Assert(Array.isArray(options.switch), '"switch" must be an array');
      Assert(options.is === void 0, 'Cannot combine "switch" with "is"');
      Assert(options.not === void 0, 'Cannot combine "switch" with "not"');
      Assert(options.then === void 0, 'Cannot combine "switch" with "then"');
      const rule = {
        ref: exports.ref(condition),
        switch: [],
        break: options.break
      };
      for (let i = 0; i < options.switch.length; ++i) {
        const test = options.switch[i];
        const last = i === options.switch.length - 1;
        Common.assertOptions(test, last ? ["is", "then", "otherwise"] : ["is", "then"]);
        Assert(test.is !== void 0, 'Switch statement missing "is"');
        Assert(test.then !== void 0, 'Switch statement missing "then"');
        const item = {
          is: schema.$_compile(test.is),
          then: schema.$_compile(test.then)
        };
        if (!Ref.isRef(test.is) && !Common.isSchema(test.is)) {
          item.is = item.is.required();
        }
        if (last) {
          Assert(options.otherwise === void 0 || test.otherwise === void 0, 'Cannot specify "otherwise" inside and outside a "switch"');
          const otherwise = options.otherwise !== void 0 ? options.otherwise : test.otherwise;
          if (otherwise !== void 0) {
            Assert(rule.break === void 0, "Cannot specify both otherwise and break");
            item.otherwise = schema.$_compile(otherwise);
          }
        }
        rule.switch.push(item);
      }
      return rule;
    };
    internals.condition = function(schema, condition) {
      for (const key of ["then", "otherwise"]) {
        if (condition[key] === void 0) {
          delete condition[key];
        } else {
          condition[key] = schema.$_compile(condition[key]);
        }
      }
      return condition;
    };
  }
});

// node_modules/@hapi/validate/lib/annotate.js
var require_annotate = __commonJS({
  "node_modules/@hapi/validate/lib/annotate.js"(exports) {
    "use strict";
    var Clone = require_clone();
    var Common = require_common();
    var internals = {
      annotations: Symbol("annotations")
    };
    exports.error = function(stripColorCodes) {
      if (!this._original || typeof this._original !== "object") {
        return this.details[0].message;
      }
      const redFgEscape = stripColorCodes ? "" : "\x1B[31m";
      const redBgEscape = stripColorCodes ? "" : "\x1B[41m";
      const endColor = stripColorCodes ? "" : "\x1B[0m";
      const obj = Clone(this._original);
      for (let i = this.details.length - 1; i >= 0; --i) {
        const pos = i + 1;
        const error = this.details[i];
        const path = error.path;
        let node = obj;
        for (let j = 0; ; ++j) {
          const seg = path[j];
          if (Common.isSchema(node)) {
            node = node.clone();
          }
          if (j + 1 < path.length && typeof node[seg] !== "string") {
            node = node[seg];
          } else {
            const refAnnotations = node[internals.annotations] || { errors: {}, missing: {} };
            node[internals.annotations] = refAnnotations;
            const cacheKey = seg || error.context.key;
            if (node[seg] !== void 0) {
              refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
              refAnnotations.errors[cacheKey].push(pos);
            } else {
              refAnnotations.missing[cacheKey] = pos;
            }
            break;
          }
        }
      }
      const replacers = {
        key: /_\$key\$_([, \d]+)_\$end\$_"/g,
        missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
        arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
        specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
      };
      let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`).replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`).replace(replacers.arrayIndex, ($0, $1, $2) => `
${$2} ${redFgEscape}[${$1}]${endColor}`).replace(replacers.specials, ($0, $1) => $1);
      message = `${message}
${redFgEscape}`;
      for (let i = 0; i < this.details.length; ++i) {
        const pos = i + 1;
        message = `${message}
[${pos}] ${this.details[i].message}`;
      }
      message = message + endColor;
      return message;
    };
    internals.safeStringify = function(obj, spaces) {
      return JSON.stringify(obj, internals.serializer(), spaces);
    };
    internals.serializer = function() {
      const keys = [];
      const stack = [];
      const cycleReplacer = (key, value) => {
        if (stack[0] === value) {
          return "[Circular ~]";
        }
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };
      return function(key, value) {
        if (stack.length > 0) {
          const thisPos = stack.indexOf(this);
          if (~thisPos) {
            stack.length = thisPos + 1;
            keys.length = thisPos + 1;
            keys[thisPos] = key;
          } else {
            stack.push(this);
            keys.push(key);
          }
          if (~stack.indexOf(value)) {
            value = cycleReplacer.call(this, key, value);
          }
        } else {
          stack.push(value);
        }
        if (value) {
          const annotations = value[internals.annotations];
          if (annotations) {
            if (Array.isArray(value)) {
              const annotated = [];
              for (let i = 0; i < value.length; ++i) {
                if (annotations.errors[i]) {
                  annotated.push(`_$idx$_${annotations.errors[i].sort().join(", ")}_$end$_`);
                }
                annotated.push(value[i]);
              }
              value = annotated;
            } else {
              for (const errorKey in annotations.errors) {
                value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(", ")}_$end$_`] = value[errorKey];
                value[errorKey] = void 0;
              }
              for (const missingKey in annotations.missing) {
                value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = "__missing__";
              }
            }
            return value;
          }
        }
        if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === "function" || typeof value === "symbol") {
          return "[" + value.toString() + "]";
        }
        return value;
      };
    };
  }
});

// node_modules/@hapi/validate/lib/errors.js
var require_errors = __commonJS({
  "node_modules/@hapi/validate/lib/errors.js"(exports) {
    "use strict";
    var Annotate = require_annotate();
    var Common = require_common();
    var Template = require_template();
    exports.Report = class {
      constructor(code, value, local2, flags, messages, state, prefs) {
        this.code = code;
        this.flags = flags;
        this.messages = messages;
        this.path = state.path;
        this.prefs = prefs;
        this.state = state;
        this.value = value;
        this.message = null;
        this.local = local2 || {};
        this.local.label = exports.label(this.flags, this.state, this.prefs, this.messages);
        if (this.value !== void 0 && !this.local.hasOwnProperty("value")) {
          this.local.value = this.value;
        }
        if (this.path.length) {
          const key = this.path[this.path.length - 1];
          if (typeof key !== "object") {
            this.local.key = key;
          }
        }
      }
      toString() {
        if (this.message) {
          return this.message;
        }
        const code = this.code;
        if (!this.prefs.errors.render) {
          return this.code;
        }
        const template = this._template(this.prefs.messages) || this._template(this.messages);
        if (template === void 0) {
          return `Error code "${code}" is not defined, your custom type is missing the correct messages definition`;
        }
        this.message = template.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] });
        if (!this.prefs.errors.label) {
          this.message = this.message.replace(/^"" /, "").trim();
        }
        return this.message;
      }
      _template(messages) {
        return exports.template(this.value, messages, this.code, this.state, this.prefs);
      }
    };
    exports.path = function(path) {
      let label = "";
      for (const segment of path) {
        if (typeof segment === "object") {
          continue;
        }
        if (typeof segment === "string") {
          if (label) {
            label += ".";
          }
          label += segment;
        } else {
          label += `[${segment}]`;
        }
      }
      return label;
    };
    exports.template = function(value, messages, code, state, prefs) {
      if (Template.isTemplate(messages)) {
        return code !== "root" ? messages : null;
      }
      let lang = prefs.errors.language;
      if (Common.isResolvable(lang)) {
        lang = lang.resolve(value, state, prefs);
      }
      if (lang && messages[lang] && messages[lang][code] !== void 0) {
        return messages[lang][code];
      }
      return messages[code];
    };
    exports.label = function(flags, state, prefs, messages) {
      if (!prefs.errors.label) {
        return "";
      }
      let path = state.path;
      if (prefs.errors.label === "key" && state.path.length > 1) {
        path = state.path.slice(-1);
      }
      const normalized = exports.path(path);
      if (normalized) {
        return normalized;
      }
      return exports.template(null, prefs.messages, "root", state, prefs) || exports.template(null, messages, "root", state, prefs) || "value";
    };
    exports.process = function(errors, original, prefs) {
      if (!errors) {
        return null;
      }
      const { override, message, details } = exports.details(errors);
      if (override) {
        return override;
      }
      if (prefs.errors.stack) {
        return new exports.ValidationError(message, details, original);
      }
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      const validationError = new exports.ValidationError(message, details, original);
      Error.stackTraceLimit = limit;
      return validationError;
    };
    exports.details = function(errors, options = {}) {
      let messages = [];
      const details = [];
      for (const item of errors) {
        if (item instanceof Error) {
          if (options.override !== false) {
            return { override: item };
          }
          const message2 = item.toString();
          messages.push(message2);
          details.push({
            message: message2,
            type: "override",
            context: { error: item }
          });
          continue;
        }
        const message = item.toString();
        messages.push(message);
        details.push({
          message,
          path: item.path.filter((v) => typeof v !== "object"),
          type: item.code,
          context: item.local
        });
      }
      if (messages.length > 1) {
        messages = [...new Set(messages)];
      }
      return { message: messages.join(". "), details };
    };
    exports.ValidationError = class extends Error {
      constructor(message, details, original) {
        super(message);
        this._original = original;
        this.details = details;
      }
      static isError(err) {
        return err instanceof exports.ValidationError;
      }
    };
    exports.ValidationError.prototype.isJoi = true;
    exports.ValidationError.prototype.name = "ValidationError";
    exports.ValidationError.prototype.annotate = Annotate.error;
  }
});

// node_modules/@hapi/validate/lib/extend.js
var require_extend = __commonJS({
  "node_modules/@hapi/validate/lib/extend.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var Messages = require_messages();
    exports.type = function(from, options) {
      const base = Object.getPrototypeOf(from);
      const prototype = Clone(base);
      const schema = from._assign(Object.create(prototype));
      const def = Object.assign({}, options);
      delete def.base;
      prototype._definition = def;
      const parent = base._definition || {};
      def.messages = Messages.merge(parent.messages, def.messages);
      def.properties = Object.assign({}, parent.properties, def.properties);
      schema.type = def.type;
      def.flags = Object.assign({}, parent.flags, def.flags);
      const terms = Object.assign({}, parent.terms);
      if (def.terms) {
        for (const name in def.terms) {
          const term = def.terms[name];
          Assert(schema.$_terms[name] === void 0, "Invalid term override for", def.type, name);
          schema.$_terms[name] = term.init;
          terms[name] = term;
        }
      }
      def.terms = terms;
      if (!def.args) {
        def.args = parent.args;
      }
      if (def.coerce) {
        if (typeof def.coerce === "function") {
          def.coerce = { method: def.coerce };
        }
        if (def.coerce.from && !Array.isArray(def.coerce.from)) {
          def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };
        }
      }
      def.coerce = def.coerce || parent.coerce;
      def.validate = def.validate || parent.validate;
      const rules = Object.assign({}, parent.rules);
      if (def.rules) {
        for (const name in def.rules) {
          const rule = def.rules[name];
          Assert(typeof rule === "object", "Invalid rule definition for", def.type, name);
          const method = rule.method;
          if (method) {
            Assert(!prototype[name], "Rule conflict in", def.type, name);
            prototype[name] = method;
          }
          Assert(!rules[name], "Rule conflict in", def.type, name);
          rules[name] = rule;
          if (rule.alias) {
            const aliases = [].concat(rule.alias);
            for (const alias of aliases) {
              prototype[alias] = rule.method;
            }
          }
          if (rule.args) {
            rule.argsByName = /* @__PURE__ */ new Map();
            rule.args = rule.args.map((arg) => {
              if (typeof arg === "string") {
                arg = { name: arg };
              }
              Assert(!rule.argsByName.has(arg.name), "Duplicated argument name", arg.name);
              rule.argsByName.set(arg.name, arg);
              return arg;
            });
          }
        }
      }
      def.rules = rules;
      if (def.overrides) {
        prototype._super = base;
        schema.$_super = {};
        for (const override in def.overrides) {
          Assert(base[override], "Cannot override missing", override);
          def.overrides[override][Common.symbols.parent] = base[override];
          schema.$_super[override] = base[override].bind(schema);
        }
        Object.assign(prototype, def.overrides);
      }
      def.cast = Object.assign({}, parent.cast, def.cast);
      def.rebuild = def.rebuild || parent.rebuild;
      return schema;
    };
  }
});

// node_modules/@hapi/validate/lib/modify.js
var require_modify = __commonJS({
  "node_modules/@hapi/validate/lib/modify.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Common = require_common();
    var Ref = require_ref();
    var internals = {};
    exports.Ids = internals.Ids = class {
      constructor() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      clone() {
        const clone = new internals.Ids();
        clone._byId = new Map(this._byId);
        clone._byKey = new Map(this._byKey);
        clone._schemaChain = this._schemaChain;
        return clone;
      }
      concat(source) {
        if (source._schemaChain) {
          this._schemaChain = true;
        }
        for (const [id, value] of source._byId.entries()) {
          Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, value);
        }
        for (const [key, value] of source._byKey.entries()) {
          Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, value);
        }
      }
      reach(path, behind = []) {
        const current = path[0];
        const node = this._get(current);
        Assert(node, "Schema does not contain path", [...behind, ...path].join("."));
        const forward = path.slice(1);
        if (!forward.length) {
          return node.schema;
        }
        return node.schema._ids.reach(forward, [...behind, current]);
      }
      register(schema, { key } = {}) {
        if (!schema || !Common.isSchema(schema)) {
          return;
        }
        if (schema.$_property("schemaChain") || schema._ids._schemaChain) {
          this._schemaChain = true;
        }
        const id = schema._flags.id;
        if (id) {
          const existing = this._byId.get(id);
          Assert(!existing || existing.schema === schema, "Cannot add different schemas with the same id:", id);
          Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, { schema, id });
        }
        if (key) {
          Assert(!this._byKey.has(key), "Schema already contains key:", key);
          Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, { schema, id: key });
        }
      }
      reset() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      _get(id) {
        return this._byId.get(id) || this._byKey.get(id);
      }
    };
    exports.schema = function(schema, options) {
      let obj;
      for (const name in schema._flags) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema._flags[name], { source: "flags", name }, options);
        if (result !== void 0) {
          obj = obj || schema.clone();
          obj._flags[name] = result;
        }
      }
      for (let i = 0; i < schema._rules.length; ++i) {
        const rule = schema._rules[i];
        const result = internals.scan(rule.args, { source: "rules", name: rule.name }, options);
        if (result !== void 0) {
          obj = obj || schema.clone();
          const clone = Object.assign({}, rule);
          clone.args = result;
          obj._rules[i] = clone;
          const existingUnique = obj._singleRules.get(rule.name);
          if (existingUnique === rule) {
            obj._singleRules.set(rule.name, clone);
          }
        }
      }
      for (const name in schema.$_terms) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema.$_terms[name], { source: "terms", name }, options);
        if (result !== void 0) {
          obj = obj || schema.clone();
          obj.$_terms[name] = result;
        }
      }
      return obj;
    };
    internals.scan = function(item, source, options, _path, _key) {
      const path = _path || [];
      if (item === null || typeof item !== "object") {
        return;
      }
      let clone;
      if (Array.isArray(item)) {
        for (let i = 0; i < item.length; ++i) {
          const key = source.name === "keys" && item[i].key;
          const result = internals.scan(item[i], source, options, [i, ...path], key);
          if (result !== void 0) {
            clone = clone || item.slice();
            clone[i] = result;
          }
        }
        return clone;
      }
      if (options.schema !== false && Common.isSchema(item) || options.ref !== false && Ref.isRef(item)) {
        const result = options.each(item, { ...source, path, key: _key });
        return result;
      }
      for (const key in item) {
        if (key[0] === "_") {
          continue;
        }
        const result = internals.scan(item[key], source, options, [key, ...path], _key);
        if (result !== void 0) {
          clone = clone || Object.assign({}, item);
          clone[key] = result;
        }
      }
      return clone;
    };
  }
});

// node_modules/@hapi/validate/lib/state.js
var require_state = __commonJS({
  "node_modules/@hapi/validate/lib/state.js"(exports, module2) {
    "use strict";
    var Clone = require_clone();
    var Reach = require_reach();
    var Common = require_common();
    var internals = {
      value: Symbol("value")
    };
    module2.exports = internals.State = class {
      constructor(path, ancestors, state) {
        this.path = path;
        this.ancestors = ancestors;
        this.mainstay = state.mainstay;
        this.schemas = state.schemas;
      }
      localize(path, ancestors = null, schema = null) {
        const state = new internals.State(path, ancestors, this);
        if (schema && state.schemas) {
          state.schemas = [internals.schemas(schema), ...state.schemas];
        }
        return state;
      }
      nest(schema) {
        const state = new internals.State(this.path, this.ancestors, this);
        state.schemas = state.schemas && [internals.schemas(schema), ...state.schemas];
        return state;
      }
      shadow(value, reason) {
        this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();
        this.mainstay.shadow.set(this.path, value, reason);
      }
      snapshot() {
        if (this.mainstay.shadow) {
          this._snapshot = Clone(this.mainstay.shadow.node(this.path));
        }
      }
      restore() {
        if (this.mainstay.shadow) {
          this.mainstay.shadow.override(this.path, this._snapshot);
          this._snapshot = void 0;
        }
      }
    };
    internals.schemas = function(schema) {
      if (Common.isSchema(schema)) {
        return { schema };
      }
      return schema;
    };
    internals.Shadow = class {
      constructor() {
        this._values = null;
      }
      set(path, value, reason) {
        if (!path.length) {
          return;
        }
        if (reason === "strip" && typeof path[path.length - 1] === "number") {
          return;
        }
        this._values = this._values || /* @__PURE__ */ new Map();
        let node = this._values;
        for (let i = 0; i < path.length; ++i) {
          const segment = path[i];
          let next = node.get(segment);
          if (!next) {
            next = /* @__PURE__ */ new Map();
            node.set(segment, next);
          }
          node = next;
        }
        node[internals.value] = value;
      }
      get(path) {
        const node = this.node(path);
        if (node) {
          return node[internals.value];
        }
      }
      node(path) {
        if (!this._values) {
          return;
        }
        return Reach(this._values, path, { iterables: true });
      }
      override(path, node) {
        if (!this._values) {
          return;
        }
        const parents = path.slice(0, -1);
        const own = path[path.length - 1];
        const parent = Reach(this._values, parents, { iterables: true });
        if (node) {
          parent.set(own, node);
          return;
        }
        if (parent) {
          parent.delete(own);
        }
      }
    };
  }
});

// node_modules/@hapi/validate/lib/validator.js
var require_validator = __commonJS({
  "node_modules/@hapi/validate/lib/validator.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var Errors = require_errors();
    var State = require_state();
    var internals = {
      result: Symbol("result")
    };
    exports.entry = function(value, schema, prefs) {
      let settings = Common.defaults;
      if (prefs) {
        settings = Common.preferences(Common.defaults, prefs);
      }
      const result = internals.entry(value, schema, settings);
      const outcome = { value: result.value };
      if (result.error) {
        outcome.error = result.error;
      }
      return outcome;
    };
    internals.entry = function(value, schema, prefs) {
      const links = schema._ids._schemaChain ? /* @__PURE__ */ new Map() : null;
      const mainstay = { links };
      const schemas = schema._ids._schemaChain ? [{ schema }] : null;
      const state = new State([], [], { mainstay, schemas });
      const result = exports.validate(value, schema, state, prefs);
      const error = Errors.process(result.errors, value, prefs);
      return { value: result.value, error, mainstay };
    };
    exports.validate = function(value, schema, state, prefs, overrides = {}) {
      if (schema.$_terms.whens) {
        schema = schema._generate(value, state, prefs).schema;
      }
      if (schema._preferences) {
        prefs = internals.prefs(schema, prefs);
      }
      const createError = (code, local2, localState) => schema.$_createError(code, value, local2, localState || state, prefs);
      const helpers = {
        original: value,
        prefs,
        schema,
        state,
        error: createError,
        errorsArray: internals.errorsArray,
        message: (messages, local2) => schema.$_createError("custom", value, local2, state, prefs, { messages })
      };
      const def = schema._definition;
      if (def.coerce && value !== void 0 && prefs.convert && (!def.coerce.from || def.coerce.from.includes(typeof value))) {
        const coerced = def.coerce.method(value, helpers);
        if (coerced) {
          if (coerced.errors) {
            return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);
          }
          value = coerced.value;
        }
      }
      const empty = schema._flags.empty;
      if (empty && empty.$_match(internals.trim(value, schema), state.nest(empty), Common.defaults)) {
        value = void 0;
      }
      const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? null : prefs.presence);
      if (value === void 0) {
        if (presence === "forbidden") {
          return internals.finalize(value, null, helpers);
        }
        if (presence === "required") {
          return internals.finalize(value, [schema.$_createError("any.required", value, null, state, prefs)], helpers);
        }
        if (presence === "optional") {
          if (schema._flags.default !== Common.symbols.deepDefault) {
            return internals.finalize(value, null, helpers);
          }
          value = {};
        }
      } else if (presence === "forbidden") {
        return internals.finalize(value, [schema.$_createError("any.unknown", value, null, state, prefs)], helpers);
      }
      const errors = [];
      if (schema._valids) {
        const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
          if (prefs.convert) {
            value = match.value;
          }
          return internals.finalize(value, null, helpers);
        }
        if (schema._flags.only) {
          const report = schema.$_createError("any.only", value, { valids: schema._valids.values({ display: true }) }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [report], helpers);
          }
          errors.push(report);
        }
      }
      if (schema._invalids) {
        const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
          const report = schema.$_createError("any.invalid", value, { invalids: schema._invalids.values({ display: true }) }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [report], helpers);
          }
          errors.push(report);
        }
      }
      if (def.validate) {
        const base = def.validate(value, helpers);
        if (base) {
          value = base.value;
          if (base.errors) {
            if (!Array.isArray(base.errors)) {
              errors.push(base.errors);
              return internals.finalize(value, errors, helpers);
            }
            if (base.errors.length) {
              errors.push(...base.errors);
              return internals.finalize(value, errors, helpers);
            }
          }
        }
      }
      if (!schema._rules.length) {
        return internals.finalize(value, errors, helpers);
      }
      return internals.rules(value, errors, helpers);
    };
    internals.rules = function(value, errors, helpers) {
      const { schema, state, prefs } = helpers;
      for (const rule of schema._rules) {
        const definition = schema._definition.rules[rule.method];
        if (definition.convert && prefs.convert) {
          continue;
        }
        let ret;
        let args = rule.args;
        if (rule._resolve.length) {
          args = Object.assign({}, args);
          for (const key of rule._resolve) {
            const resolver = definition.argsByName.get(key);
            const resolved = args[key].resolve(value, state, prefs);
            const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;
            const invalid = Common.validateArg(normalized, null, resolver);
            if (invalid) {
              ret = schema.$_createError("any.ref", resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);
              break;
            }
            args[key] = normalized;
          }
        }
        ret = ret || definition.validate(value, helpers, args, rule);
        const result = internals.rule(ret, rule);
        if (result.errors) {
          if (prefs.abortEarly) {
            return internals.finalize(value, result.errors, helpers);
          }
          errors.push(...result.errors);
        } else {
          value = result.value;
        }
      }
      return internals.finalize(value, errors, helpers);
    };
    internals.rule = function(ret, rule) {
      if (ret instanceof Errors.Report) {
        return { errors: [ret], value: null };
      }
      if (Array.isArray(ret) && ret[Common.symbols.errors]) {
        return { errors: ret, value: null };
      }
      return { errors: null, value: ret };
    };
    internals.finalize = function(value, errors, helpers) {
      errors = errors || [];
      const { schema, state } = helpers;
      if (errors.length) {
        const failover = internals.default("failover", void 0, errors, helpers);
        if (failover !== void 0) {
          value = failover;
          errors = [];
        }
      }
      if (errors.length && schema._flags.error) {
        if (typeof schema._flags.error === "function") {
          errors = schema._flags.error(errors);
          if (!Array.isArray(errors)) {
            errors = [errors];
          }
          for (const error of errors) {
            Assert(error instanceof Error || error instanceof Errors.Report, "error() must return an Error object");
          }
        } else {
          errors = [schema._flags.error];
        }
      }
      if (value === void 0) {
        const defaulted = internals.default("default", value, errors, helpers);
        value = defaulted;
      }
      if (schema._flags.cast && value !== void 0) {
        const caster = schema._definition.cast[schema._flags.cast];
        if (caster.from(value)) {
          const casted = caster.to(value, helpers);
          value = casted;
        }
      }
      const result = { value, errors: errors.length ? errors : null };
      if (schema._flags.result) {
        result.value = schema._flags.result === "strip" ? void 0 : helpers.original;
        state.shadow(value, schema._flags.result);
      }
      return result;
    };
    internals.prefs = function(schema, prefs) {
      const isDefaultOptions = prefs === Common.defaults;
      if (isDefaultOptions && schema._preferences[Common.symbols.prefs]) {
        return schema._preferences[Common.symbols.prefs];
      }
      prefs = Common.preferences(prefs, schema._preferences);
      if (isDefaultOptions) {
        schema._preferences[Common.symbols.prefs] = prefs;
      }
      return prefs;
    };
    internals.default = function(flag, value, errors, helpers) {
      const { schema, state, prefs } = helpers;
      const source = schema._flags[flag];
      if (prefs.noDefaults || source === void 0) {
        return value;
      }
      if (!source) {
        return source;
      }
      if (typeof source === "function") {
        const args = source.length ? [Clone(state.ancestors[0]), helpers] : [];
        try {
          return source(...args);
        } catch (err) {
          errors.push(schema.$_createError(`any.${flag}`, null, { error: err }, state, prefs));
          return;
        }
      }
      if (typeof source !== "object") {
        return source;
      }
      if (source[Common.symbols.literal]) {
        return source.literal;
      }
      if (Common.isResolvable(source)) {
        return source.resolve(value, state, prefs);
      }
      return Clone(source);
    };
    internals.trim = function(value, schema) {
      if (typeof value !== "string") {
        return value;
      }
      const trim = schema.$_getRule("trim");
      if (!trim || !trim.args.enabled) {
        return value;
      }
      return value.trim();
    };
    internals.errorsArray = function() {
      const errors = [];
      errors[Common.symbols.errors] = true;
      return errors;
    };
  }
});

// node_modules/@hapi/validate/lib/values.js
var require_values = __commonJS({
  "node_modules/@hapi/validate/lib/values.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var Common = require_common();
    var internals = {};
    module2.exports = internals.Values = class {
      constructor(values, refs) {
        this._values = new Set(values);
        this._refs = new Set(refs);
        this._lowercase = internals.lowercases(values);
        this._override = false;
      }
      get length() {
        return this._values.size + this._refs.size;
      }
      add(value, refs) {
        if (Common.isResolvable(value)) {
          if (!this._refs.has(value)) {
            this._refs.add(value);
            if (refs) {
              refs.register(value);
            }
          }
          return;
        }
        if (!this.has(value, null, null, false)) {
          this._values.add(value);
          if (typeof value === "string") {
            this._lowercase.set(value.toLowerCase(), value);
          }
        }
      }
      static merge(target, source, remove) {
        target = target || new internals.Values();
        if (source) {
          if (source._override) {
            return source.clone();
          }
          for (const item of [...source._values, ...source._refs]) {
            target.add(item);
          }
        }
        if (remove) {
          for (const item of [...remove._values, ...remove._refs]) {
            target.remove(item);
          }
        }
        return target.length ? target : null;
      }
      remove(value) {
        if (Common.isResolvable(value)) {
          this._refs.delete(value);
          return;
        }
        this._values.delete(value);
        if (typeof value === "string") {
          this._lowercase.delete(value.toLowerCase());
        }
      }
      has(value, state, prefs, insensitive) {
        return !!this.get(value, state, prefs, insensitive);
      }
      get(value, state, prefs, insensitive) {
        if (!this.length) {
          return false;
        }
        if (this._values.has(value)) {
          return { value };
        }
        if (typeof value === "string" && value && insensitive) {
          const found = this._lowercase.get(value.toLowerCase());
          if (found) {
            return { value: found };
          }
        }
        if (!this._refs.size && typeof value !== "object") {
          return false;
        }
        if (typeof value === "object") {
          for (const item of this._values) {
            if (DeepEqual(item, value)) {
              return { value: item };
            }
          }
        }
        if (state) {
          for (const ref of this._refs) {
            const resolved = ref.resolve(value, state, prefs, null, { in: true });
            if (resolved === void 0) {
              continue;
            }
            const items = !ref.in || typeof resolved !== "object" ? [resolved] : Array.isArray(resolved) ? resolved : Object.keys(resolved);
            for (const item of items) {
              if (typeof item !== typeof value) {
                continue;
              }
              if (insensitive && value && typeof value === "string") {
                if (item.toLowerCase() === value.toLowerCase()) {
                  return { value: item, ref };
                }
              } else {
                if (DeepEqual(item, value)) {
                  return { value: item, ref };
                }
              }
            }
          }
        }
        return false;
      }
      override() {
        this._override = true;
      }
      values(options) {
        if (options && options.display) {
          const values = [];
          for (const item of [...this._values, ...this._refs]) {
            if (item !== void 0) {
              values.push(item);
            }
          }
          return values;
        }
        return Array.from([...this._values, ...this._refs]);
      }
      clone() {
        const set = new internals.Values(this._values, this._refs);
        set._override = this._override;
        return set;
      }
      concat(source) {
        Assert(!source._override, "Cannot concat override set of values");
        const set = new internals.Values([...this._values, ...source._values], [...this._refs, ...source._refs]);
        set._override = this._override;
        return set;
      }
    };
    internals.Values.prototype[Common.symbols.values] = true;
    internals.Values.prototype.slice = internals.Values.prototype.clone;
    internals.lowercases = function(from) {
      const map = /* @__PURE__ */ new Map();
      if (from) {
        for (const value of from) {
          if (typeof value === "string") {
            map.set(value.toLowerCase(), value);
          }
        }
      }
      return map;
    };
  }
});

// node_modules/@hapi/validate/lib/base.js
var require_base = __commonJS({
  "node_modules/@hapi/validate/lib/base.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var DeepEqual = require_deepEqual();
    var Merge = require_merge();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Extend = require_extend();
    var Messages = require_messages();
    var Modify = require_modify();
    var Ref = require_ref();
    var Validator = require_validator();
    var Values = require_values();
    var internals = {};
    internals.Base = class {
      constructor(type) {
        this.type = type;
        this.$_root = null;
        this._definition = {};
        this._ids = new Modify.Ids();
        this._preferences = null;
        this._refs = new Ref.Manager();
        this._cache = null;
        this._valids = null;
        this._invalids = null;
        this._flags = {};
        this._rules = [];
        this._singleRules = /* @__PURE__ */ new Map();
        this.$_terms = {};
        this.$_temp = {
          whens: {}
        };
      }
      allow(...values) {
        Common.verifyFlat(values, "allow");
        return this._values(values, "_valids");
      }
      cast(to) {
        Assert(to === false || typeof to === "string", "Invalid to value");
        Assert(to === false || this._definition.cast[to], "Type", this.type, "does not support casting to", to);
        return this.$_setFlag("cast", to === false ? void 0 : to);
      }
      default(value, options) {
        return this._default("default", value, options);
      }
      empty(schema) {
        const obj = this.clone();
        if (schema !== void 0) {
          schema = obj.$_compile(schema, { override: false });
        }
        return obj.$_setFlag("empty", schema, { clone: false });
      }
      error(err) {
        Assert(err, "Missing error");
        Assert(err instanceof Error || typeof err === "function", "Must provide a valid Error object or a function");
        return this.$_setFlag("error", err);
      }
      failover(value, options) {
        return this._default("failover", value, options);
      }
      forbidden() {
        return this.presence("forbidden");
      }
      id(id) {
        if (!id) {
          return this.$_setFlag("id", void 0);
        }
        Assert(typeof id === "string", "id must be a non-empty string");
        Assert(/^[^\.]+$/.test(id), "id cannot contain period character");
        return this.$_setFlag("id", id);
      }
      invalid(...values) {
        return this._values(values, "_invalids");
      }
      only(mode = true) {
        Assert(typeof mode === "boolean", "Invalid mode:", mode);
        return this.$_setFlag("only", mode);
      }
      optional() {
        return this.presence("optional");
      }
      prefs(prefs) {
        Assert(prefs, "Missing preferences");
        Assert(prefs.context === void 0, "Cannot override context");
        Common.checkPreferences(prefs);
        const obj = this.clone();
        obj._preferences = Common.preferences(obj._preferences, prefs);
        return obj;
      }
      presence(mode) {
        Assert(["optional", "required", "forbidden"].includes(mode), "Unknown presence mode", mode);
        return this.$_setFlag("presence", mode);
      }
      raw(enabled = true) {
        return this.$_setFlag("result", enabled ? "raw" : void 0);
      }
      required() {
        return this.presence("required");
      }
      strict(enabled) {
        const obj = this.clone();
        const convert = enabled === void 0 ? false : !enabled;
        obj._preferences = Common.preferences(obj._preferences, { convert });
        return obj;
      }
      strip(enabled = true) {
        return this.$_setFlag("result", enabled ? "strip" : void 0);
      }
      valid(...values) {
        Common.verifyFlat(values, "valid");
        const obj = this.allow(...values);
        obj.$_setFlag("only", !!obj._valids, { clone: false });
        return obj;
      }
      when(condition, options) {
        const obj = this.clone();
        if (!obj.$_terms.whens) {
          obj.$_terms.whens = [];
        }
        const when = Compile.when(obj, condition, options);
        if (!["any", "link"].includes(obj.type)) {
          const conditions = when.is ? [when] : when.switch;
          for (const item of conditions) {
            Assert(!item.then || item.then.type === "any" || item.then.type === obj.type, "Cannot combine", obj.type, "with", item.then && item.then.type);
            Assert(!item.otherwise || item.otherwise.type === "any" || item.otherwise.type === obj.type, "Cannot combine", obj.type, "with", item.otherwise && item.otherwise.type);
          }
        }
        obj.$_terms.whens.push(when);
        return obj.$_mutateRebuild();
      }
      clone() {
        const obj = Object.create(Object.getPrototypeOf(this));
        return this._assign(obj);
      }
      concat(source) {
        Assert(Common.isSchema(source), "Invalid schema object");
        Assert(this.type === "any" || source.type === "any" || source.type === this.type, "Cannot merge type", this.type, "with another type:", source.type);
        let obj = this.clone();
        if (this.type === "any" && source.type !== "any") {
          const tmpObj = source.clone();
          for (const key of Object.keys(obj)) {
            if (key !== "type") {
              tmpObj[key] = obj[key];
            }
          }
          obj = tmpObj;
        }
        obj._ids.concat(source._ids);
        obj._refs.register(source, Ref.toSibling);
        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);
        for (const name of source._singleRules.keys()) {
          if (obj._singleRules.has(name)) {
            obj._rules = obj._rules.filter((target) => target.name !== name);
            obj._singleRules.delete(name);
          }
        }
        for (const test of source._rules) {
          if (!source._definition.rules[test.method].multi) {
            obj._singleRules.set(test.name, test);
          }
          obj._rules.push(test);
        }
        if (obj._flags.empty && source._flags.empty) {
          obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
          const flags = Object.assign({}, source._flags);
          delete flags.empty;
          Merge(obj._flags, flags);
        } else if (source._flags.empty) {
          obj._flags.empty = source._flags.empty;
          const flags = Object.assign({}, source._flags);
          delete flags.empty;
          Merge(obj._flags, flags);
        } else {
          Merge(obj._flags, source._flags);
        }
        for (const key in source.$_terms) {
          const terms = source.$_terms[key];
          if (!terms) {
            if (!obj.$_terms[key]) {
              obj.$_terms[key] = terms;
            }
            continue;
          }
          if (!obj.$_terms[key]) {
            obj.$_terms[key] = terms.slice();
            continue;
          }
          obj.$_terms[key] = obj.$_terms[key].concat(terms);
        }
        return obj.$_mutateRebuild();
      }
      validate(value, options) {
        return Validator.entry(value, this, options);
      }
      validateAsync(value, options) {
        const result = this.validate(value, options);
        if (result.error) {
          throw result.error;
        }
        return result.value;
      }
      $_addRule(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        Assert(options && typeof options === "object", "Invalid options");
        Assert(options.name && typeof options.name === "string", "Invalid rule name");
        for (const key in options) {
          Assert(key[0] !== "_", "Cannot set private rule properties");
        }
        const rule = Object.assign({}, options);
        rule._resolve = [];
        rule.method = rule.method || rule.name;
        const definition = this._definition.rules[rule.method];
        const args = rule.args;
        Assert(definition, "Unknown rule", rule.method);
        const obj = this.clone();
        if (args) {
          Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, "Invalid rule definition for", this.type, rule.name);
          for (const key in args) {
            let arg = args[key];
            if (arg === void 0) {
              delete args[key];
              continue;
            }
            if (definition.argsByName) {
              const resolver = definition.argsByName.get(key);
              if (resolver.ref && Common.isResolvable(arg)) {
                rule._resolve.push(key);
                obj.$_mutateRegister(arg);
              } else {
                if (resolver.normalize) {
                  arg = resolver.normalize(arg);
                  args[key] = arg;
                }
                if (resolver.assert) {
                  const error = Common.validateArg(arg, key, resolver);
                  Assert(!error, error, "or reference");
                }
              }
            }
            args[key] = arg;
          }
        }
        if (!definition.multi) {
          obj._ruleRemove(rule.name);
          obj._singleRules.set(rule.name, rule);
        }
        if (definition.priority) {
          obj._rules.unshift(rule);
        } else {
          obj._rules.push(rule);
        }
        return obj;
      }
      $_compile(schema, options) {
        return Compile.schema(this.$_root, schema, options);
      }
      $_createError(code, value, local2, state, prefs, options = {}) {
        const flags = options.flags !== false ? this._flags : {};
        const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;
        return new Errors.Report(code, value, local2, flags, messages, state, prefs);
      }
      $_getRule(name) {
        return this._singleRules.get(name);
      }
      $_match(value, state, prefs, overrides) {
        prefs = Object.assign({}, prefs);
        prefs.abortEarly = true;
        prefs._externals = false;
        state.snapshot();
        const result = !Validator.validate(value, this, state, prefs, overrides).errors;
        state.restore();
        return result;
      }
      $_modify(options) {
        Common.assertOptions(options, ["each", "once", "ref", "schema"]);
        return Modify.schema(this, options) || this;
      }
      $_mutateRebuild() {
        this._refs.reset();
        this._ids.reset();
        const each = (item, { source, name, path, key }) => {
          const family = this._definition[source][name] && this._definition[source][name].register;
          if (family !== false) {
            this.$_mutateRegister(item, { family, key });
          }
        };
        this.$_modify({ each });
        if (this._definition.rebuild) {
          this._definition.rebuild(this);
        }
        return this;
      }
      $_mutateRegister(schema, { family, key } = {}) {
        this._refs.register(schema, family);
        this._ids.register(schema, { key });
      }
      $_property(name) {
        return this._definition.properties[name];
      }
      $_reach(path) {
        return this._ids.reach(path);
      }
      $_rootReferences() {
        return this._refs.roots();
      }
      $_setFlag(name, value, options = {}) {
        const flag = this._definition.flags[name] || {};
        if (DeepEqual(value, flag.default)) {
          value = void 0;
        }
        if (DeepEqual(value, this._flags[name])) {
          return this;
        }
        const obj = options.clone !== false ? this.clone() : this;
        if (value !== void 0) {
          obj._flags[name] = value;
          obj.$_mutateRegister(value);
        } else {
          delete obj._flags[name];
        }
        return obj;
      }
      $_parent(method, ...args) {
        return this[method][Common.symbols.parent].call(this, ...args);
      }
      $_validate(value, state, prefs) {
        return Validator.validate(value, this, state, prefs);
      }
      _assign(target) {
        target.type = this.type;
        target.$_root = this.$_root;
        target.$_temp = Object.assign({}, this.$_temp);
        target.$_temp.whens = {};
        target._ids = this._ids.clone();
        target._preferences = this._preferences;
        target._valids = this._valids && this._valids.clone();
        target._invalids = this._invalids && this._invalids.clone();
        target._rules = this._rules.slice();
        target._singleRules = Clone(this._singleRules, { shallow: true });
        target._refs = this._refs.clone();
        target._flags = Object.assign({}, this._flags);
        target._cache = null;
        target.$_terms = {};
        for (const key in this.$_terms) {
          target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
        }
        target.$_super = {};
        for (const override in this.$_super) {
          target.$_super[override] = this._super[override].bind(target);
        }
        return target;
      }
      _default(flag, value, options = {}) {
        Common.assertOptions(options, "literal");
        Assert(value !== void 0, "Missing", flag, "value");
        Assert(typeof value === "function" || !options.literal, "Only function value supports literal option");
        if (typeof value === "function" && options.literal) {
          value = {
            [Common.symbols.literal]: true,
            literal: value
          };
        }
        const obj = this.$_setFlag(flag, value);
        return obj;
      }
      _extend(options) {
        Assert(!options.base, "Cannot extend type with another base");
        return Extend.type(this, options);
      }
      _generate(value, state, prefs) {
        if (!this.$_terms.whens) {
          return { schema: this };
        }
        const whens = [];
        const ids = [];
        for (let i = 0; i < this.$_terms.whens.length; ++i) {
          const when = this.$_terms.whens[i];
          if (when.concat) {
            whens.push(when.concat);
            ids.push(`${i}.concat`);
            continue;
          }
          const input = when.ref ? when.ref.resolve(value, state, prefs) : value;
          const tests = when.is ? [when] : when.switch;
          const before = ids.length;
          for (let j = 0; j < tests.length; ++j) {
            const { is, then, otherwise } = tests[j];
            const baseId = `${i}${when.switch ? "." + j : ""}`;
            if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {
              if (then) {
                const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);
                const { schema: generated, id: id2 } = then._generate(value, localState, prefs);
                whens.push(generated);
                ids.push(`${baseId}.then${id2 ? `(${id2})` : ""}`);
                break;
              }
            } else if (otherwise) {
              const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);
              const { schema: generated, id: id2 } = otherwise._generate(value, localState, prefs);
              whens.push(generated);
              ids.push(`${baseId}.otherwise${id2 ? `(${id2})` : ""}`);
              break;
            }
          }
          if (when.break && ids.length > before) {
            break;
          }
        }
        const id = ids.join(", ");
        if (!id) {
          return { schema: this };
        }
        if (this.$_temp.whens[id]) {
          return { schema: this.$_temp.whens[id], id };
        }
        let obj = this;
        if (this._definition.generate) {
          obj = this._definition.generate(this, value, state, prefs);
        }
        for (const when of whens) {
          obj = obj.concat(when);
        }
        this.$_temp.whens[id] = obj;
        return { schema: obj, id };
      }
      _ruleRemove(name) {
        if (!this._singleRules.has(name)) {
          return this;
        }
        this._singleRules.delete(name);
        const filtered = [];
        for (let i = 0; i < this._rules.length; ++i) {
          const test = this._rules[i];
          if (test.name === name) {
            continue;
          }
          filtered.push(test);
        }
        this._rules = filtered;
      }
      _values(values, key) {
        Common.verifyFlat(values, key.slice(1, -1));
        const obj = this.clone();
        const override = values[0] === Common.symbols.override;
        if (override) {
          values = values.slice(1);
        }
        if (!obj[key] && values.length) {
          obj[key] = new Values();
        } else if (override) {
          obj[key] = values.length ? new Values() : null;
          obj.$_mutateRebuild();
        }
        if (!obj[key]) {
          return obj;
        }
        if (override) {
          obj[key].override();
        }
        for (const value of values) {
          Assert(value !== void 0, "Cannot call allow/valid/invalid with undefined");
          Assert(value !== Common.symbols.override, "Override must be the first value");
          const other = key === "_invalids" ? "_valids" : "_invalids";
          if (obj[other]) {
            obj[other].remove(value);
            if (!obj[other].length) {
              Assert(key === "_valids" || !obj._flags.only, "Setting invalid value", value, "leaves schema rejecting all values due to previous valid rule");
              obj[other] = null;
            }
          }
          obj[key].add(value, obj._refs);
        }
        return obj;
      }
    };
    internals.Base.prototype[Common.symbols.any] = {
      version: Common.version,
      compile: Compile.compile,
      root: "$_root"
    };
    internals.Base.prototype.isImmutable = true;
    internals.Base.prototype.deny = internals.Base.prototype.invalid;
    internals.Base.prototype.disallow = internals.Base.prototype.invalid;
    internals.Base.prototype.equal = internals.Base.prototype.valid;
    internals.Base.prototype.exist = internals.Base.prototype.required;
    internals.Base.prototype.not = internals.Base.prototype.invalid;
    internals.Base.prototype.options = internals.Base.prototype.prefs;
    internals.Base.prototype.preferences = internals.Base.prototype.prefs;
    module2.exports = new internals.Base();
  }
});

// node_modules/@hapi/validate/lib/types/any.js
var require_any = __commonJS({
  "node_modules/@hapi/validate/lib/types/any.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Base = require_base();
    var Common = require_common();
    module2.exports = Base._extend({
      type: "any",
      flags: {
        only: { default: false }
      },
      terms: {
        alterations: { init: null },
        examples: { init: null },
        metas: { init: [] },
        notes: { init: [] },
        shared: { init: null },
        tags: { init: [] },
        whens: { init: null }
      },
      rules: {
        custom: {
          method(method, description) {
            Assert(typeof method === "function", "Method must be a function");
            Assert(description === void 0 || description && typeof description === "string", "Description must be a non-empty string");
            return this.$_addRule({ name: "custom", args: { method, description } });
          },
          validate(value, helpers, { method }) {
            try {
              return method(value, helpers);
            } catch (err) {
              return helpers.error("any.custom", { error: err });
            }
          },
          args: ["method", "description"],
          multi: true
        },
        messages: {
          method(messages) {
            return this.prefs({ messages });
          }
        },
        shared: {
          method(schema) {
            Assert(Common.isSchema(schema) && schema._flags.id, "Schema must be a schema with an id");
            const obj = this.clone();
            obj.$_terms.shared = obj.$_terms.shared || [];
            obj.$_terms.shared.push(schema);
            obj.$_mutateRegister(schema);
            return obj;
          }
        }
      },
      messages: {
        "any.custom": "{{#label}} failed custom validation because {{#error.message}}",
        "any.default": "{{#label}} threw an error when running default method",
        "any.failover": "{{#label}} threw an error when running failover method",
        "any.invalid": "{{#label}} contains an invalid value",
        "any.only": "{{#label}} must be one of {{#valids}}",
        "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}",
        "any.required": "{{#label}} is required",
        "any.unknown": "{{#label}} is not allowed"
      }
    });
  }
});

// node_modules/@hapi/validate/lib/types/alternatives.js
var require_alternatives = __commonJS({
  "node_modules/@hapi/validate/lib/types/alternatives.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Ref = require_ref();
    var internals = {};
    module2.exports = Any._extend({
      type: "alternatives",
      flags: {
        match: { default: "any" }
      },
      terms: {
        matches: { init: [], register: Ref.toSibling }
      },
      args(schema, ...schemas) {
        if (schemas.length === 1) {
          if (Array.isArray(schemas[0])) {
            return schema.try(...schemas[0]);
          }
        }
        return schema.try(...schemas);
      },
      validate(value, helpers) {
        const { schema, error, state, prefs } = helpers;
        if (schema._flags.match) {
          let hits = 0;
          let matched;
          for (let i = 0; i < schema.$_terms.matches.length; ++i) {
            const item = schema.$_terms.matches[i];
            const localState = state.nest(item.schema, `match.${i}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              ++hits;
              matched = result.value;
            } else {
              localState.restore();
            }
          }
          if (!hits) {
            return { errors: error("alternatives.any") };
          }
          if (schema._flags.match === "one") {
            return hits === 1 ? { value: matched } : { errors: error("alternatives.one") };
          }
          return hits === schema.$_terms.matches.length ? { value } : { errors: error("alternatives.all") };
        }
        const errors = [];
        for (let i = 0; i < schema.$_terms.matches.length; ++i) {
          const item = schema.$_terms.matches[i];
          if (item.schema) {
            const localState = state.nest(item.schema, `match.${i}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              return result;
            }
            localState.restore();
            errors.push({ schema: item.schema, reports: result.errors });
            continue;
          }
          const input = item.ref ? item.ref.resolve(value, state, prefs) : value;
          const tests = item.is ? [item] : item.switch;
          for (let j = 0; j < tests.length; ++j) {
            const test = tests[j];
            const { is, then, otherwise } = test;
            const id = `match.${i}${item.switch ? "." + j : ""}`;
            if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {
              if (otherwise) {
                return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);
              }
            } else if (then) {
              return then.$_validate(value, state.nest(then, `${id}.then`), prefs);
            }
          }
        }
        return internals.errors(errors, helpers);
      },
      rules: {
        conditional: {
          method(condition, options) {
            Assert(!this._flags._endedSwitch, "Unreachable condition");
            Assert(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule");
            Assert(options.break === void 0, "Cannot use break option with alternatives conditional");
            const obj = this.clone();
            const match = Compile.when(obj, condition, options);
            const conditions = match.is ? [match] : match.switch;
            for (const item of conditions) {
              if (item.then && item.otherwise) {
                obj.$_setFlag("_endedSwitch", true, { clone: false });
                break;
              }
            }
            obj.$_terms.matches.push(match);
            return obj.$_mutateRebuild();
          }
        },
        match: {
          method(mode) {
            Assert(["any", "one", "all"].includes(mode), "Invalid alternatives match mode", mode);
            if (mode !== "any") {
              for (const match of this.$_terms.matches) {
                Assert(match.schema, "Cannot combine match mode", mode, "with conditional rules");
              }
            }
            return this.$_setFlag("match", mode);
          }
        },
        try: {
          method(...schemas) {
            Assert(schemas.length, "Missing alternative schemas");
            Common.verifyFlat(schemas, "try");
            Assert(!this._flags._endedSwitch, "Unreachable condition");
            const obj = this.clone();
            for (const schema of schemas) {
              obj.$_terms.matches.push({ schema: obj.$_compile(schema) });
            }
            return obj.$_mutateRebuild();
          }
        }
      },
      rebuild(schema) {
        const each = (item) => {
          if (Common.isSchema(item) && item.type === "array") {
            schema.$_setFlag("_arrayItems", true, { clone: false });
          }
        };
        schema.$_modify({ each });
      },
      messages: {
        "alternatives.all": "{{#label}} does not match all of the required types",
        "alternatives.any": "{{#label}} does not match any of the allowed types",
        "alternatives.match": "{{#label}} does not match any of the allowed types",
        "alternatives.one": "{{#label}} matches more than one allowed type",
        "alternatives.types": "{{#label}} must be one of {{#types}}"
      }
    });
    internals.errors = function(failures, { error, state }) {
      if (!failures.length) {
        return { errors: error("alternatives.any") };
      }
      if (failures.length === 1) {
        return { errors: failures[0].reports };
      }
      const valids = /* @__PURE__ */ new Set();
      const complex = [];
      for (const { reports, schema } of failures) {
        if (reports.length > 1) {
          return internals.unmatched(failures, error);
        }
        const report = reports[0];
        if (report instanceof Errors.Report === false) {
          return internals.unmatched(failures, error);
        }
        if (report.state.path.length !== state.path.length) {
          complex.push({ type: schema.type, report });
          continue;
        }
        if (report.code === "any.only") {
          for (const valid of report.local.valids) {
            valids.add(valid);
          }
          continue;
        }
        const [type, code] = report.code.split(".");
        if (code !== "base") {
          complex.push({ type: schema.type, report });
          continue;
        }
        valids.add(type);
      }
      if (!complex.length) {
        return { errors: error("alternatives.types", { types: [...valids] }) };
      }
      if (complex.length === 1) {
        return { errors: complex[0].report };
      }
      return internals.unmatched(failures, error);
    };
    internals.unmatched = function(failures, error) {
      const errors = [];
      for (const failure of failures) {
        errors.push(...failure.reports);
      }
      return { errors: error("alternatives.match", Errors.details(errors, { override: false })) };
    };
  }
});

// node_modules/@hapi/validate/lib/types/array.js
var require_array = __commonJS({
  "node_modules/@hapi/validate/lib/types/array.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var Reach = require_reach();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var internals = {};
    module2.exports = Any._extend({
      type: "array",
      flags: {
        single: { default: false },
        sparse: { default: false }
      },
      terms: {
        items: { init: [] },
        ordered: { init: [] },
        _exclusions: { init: [] },
        _inclusions: { init: [] },
        _requireds: { init: [] }
      },
      coerce: {
        from: "object",
        method(value, { schema, state, prefs }) {
          if (!Array.isArray(value)) {
            return;
          }
          const sort = schema.$_getRule("sort");
          if (!sort) {
            return;
          }
          return internals.sort(schema, value, sort.args.options, state, prefs);
        }
      },
      validate(value, { schema, error }) {
        if (!Array.isArray(value)) {
          if (schema._flags.single) {
            const single = [value];
            single[Common.symbols.arraySingle] = true;
            return { value: single };
          }
          return { errors: error("array.base") };
        }
        if (!schema.$_getRule("items")) {
          return;
        }
        return { value: value.slice() };
      },
      rules: {
        has: {
          method(schema) {
            schema = this.$_compile(schema, { appendPath: true });
            const obj = this.$_addRule({ name: "has", args: { schema } });
            obj.$_mutateRegister(schema);
            return obj;
          },
          validate(value, { state, prefs, error }, { schema: has }) {
            const ancestors = [value, ...state.ancestors];
            for (let i = 0; i < value.length; ++i) {
              const localState = state.localize([...state.path, i], ancestors, has);
              if (has.$_match(value[i], localState, prefs)) {
                return value;
              }
            }
            return error("array.hasUnknown", null);
          },
          multi: true
        },
        items: {
          method(...schemas) {
            Common.verifyFlat(schemas, "items");
            const obj = this.$_addRule("items");
            for (let i = 0; i < schemas.length; ++i) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
              obj.$_terms.items.push(type);
            }
            return obj.$_mutateRebuild();
          },
          validate(value, { schema, error, state, prefs, errorsArray }) {
            const requireds = schema.$_terms._requireds.slice();
            const ordereds = schema.$_terms.ordered.slice();
            const inclusions = [...schema.$_terms._inclusions, ...requireds];
            const wasArray = !value[Common.symbols.arraySingle];
            delete value[Common.symbols.arraySingle];
            const errors = errorsArray();
            let il = value.length;
            for (let i = 0; i < il; ++i) {
              const item = value[i];
              let errored = false;
              let isValid = false;
              const key = wasArray ? i : new Number(i);
              const path = [...state.path, key];
              if (!schema._flags.sparse && item === void 0) {
                errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
                ordereds.shift();
                continue;
              }
              const ancestors = [value, ...state.ancestors];
              for (const exclusion of schema.$_terms._exclusions) {
                if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, { presence: "ignore" })) {
                  continue;
                }
                errors.push(error("array.excludes", { pos: i, value: item }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
                errored = true;
                ordereds.shift();
                break;
              }
              if (errored) {
                continue;
              }
              if (schema.$_terms.ordered.length) {
                if (ordereds.length) {
                  const ordered = ordereds.shift();
                  const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);
                  if (!res.errors) {
                    if (ordered._flags.result === "strip") {
                      internals.fastSplice(value, i);
                      --i;
                      --il;
                    } else if (!schema._flags.sparse && res.value === void 0) {
                      errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                      if (prefs.abortEarly) {
                        return errors;
                      }
                      continue;
                    } else {
                      value[i] = res.value;
                    }
                  } else {
                    errors.push(...res.errors);
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  continue;
                } else if (!schema.$_terms.items.length) {
                  errors.push(error("array.orderedLength", { pos: i, limit: schema.$_terms.ordered.length }));
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  break;
                }
              }
              const requiredChecks = [];
              let jl = requireds.length;
              for (let j = 0; j < jl; ++j) {
                const localState = state.localize(path, ancestors, requireds[j]);
                localState.snapshot();
                const res = requireds[j].$_validate(item, localState, prefs);
                requiredChecks[j] = res;
                if (!res.errors) {
                  value[i] = res.value;
                  isValid = true;
                  internals.fastSplice(requireds, j);
                  --j;
                  --jl;
                  if (!schema._flags.sparse && res.value === void 0) {
                    errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  break;
                }
                localState.restore();
              }
              if (isValid) {
                continue;
              }
              const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;
              jl = inclusions.length;
              for (const inclusion of inclusions) {
                let res;
                const previousCheck = requireds.indexOf(inclusion);
                if (previousCheck !== -1) {
                  res = requiredChecks[previousCheck];
                } else {
                  const localState = state.localize(path, ancestors, inclusion);
                  localState.snapshot();
                  res = inclusion.$_validate(item, localState, prefs);
                  if (!res.errors) {
                    if (inclusion._flags.result === "strip") {
                      internals.fastSplice(value, i);
                      --i;
                      --il;
                    } else if (!schema._flags.sparse && res.value === void 0) {
                      errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                      errored = true;
                    } else {
                      value[i] = res.value;
                    }
                    isValid = true;
                    break;
                  }
                  localState.restore();
                }
                if (jl === 1) {
                  if (stripUnknown) {
                    internals.fastSplice(value, i);
                    --i;
                    --il;
                    isValid = true;
                    break;
                  }
                  errors.push(...res.errors);
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  errored = true;
                  break;
                }
              }
              if (errored) {
                continue;
              }
              if (schema.$_terms._inclusions.length && !isValid) {
                if (stripUnknown) {
                  internals.fastSplice(value, i);
                  --i;
                  --il;
                  continue;
                }
                errors.push(error("array.includes", { pos: i, value: item }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
              }
            }
            if (requireds.length) {
              internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);
            }
            if (ordereds.length) {
              internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);
            }
            return errors.length ? errors : value;
          },
          priority: true
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("array." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        },
        ordered: {
          method(...schemas) {
            Common.verifyFlat(schemas, "ordered");
            const obj = this.$_addRule("items");
            for (let i = 0; i < schemas.length; ++i) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
              internals.validateSingle(type, obj);
              obj.$_mutateRegister(type);
              obj.$_terms.ordered.push(type);
            }
            return obj.$_mutateRebuild();
          }
        },
        single: {
          method(enabled) {
            const value = enabled === void 0 ? true : !!enabled;
            Assert(!value || !this._flags._arrayItems, "Cannot specify single rule when array has array items");
            return this.$_setFlag("single", value);
          }
        },
        sort: {
          method(options = {}) {
            Common.assertOptions(options, ["by", "order"]);
            const settings = {
              order: options.order || "ascending"
            };
            if (options.by) {
              settings.by = Compile.ref(options.by, { ancestor: 0 });
              Assert(!settings.by.ancestor, "Cannot sort by ancestor");
            }
            return this.$_addRule({ name: "sort", args: { options: settings } });
          },
          validate(value, { error, state, prefs, schema }, { options }) {
            const { value: sorted, errors } = internals.sort(schema, value, options, state, prefs);
            if (errors) {
              return errors;
            }
            for (let i = 0; i < value.length; ++i) {
              if (value[i] !== sorted[i]) {
                return error("array.sort", { order: options.order, by: options.by ? options.by.key : "value" });
              }
            }
            return value;
          },
          convert: true
        },
        sparse: {
          method(enabled) {
            const value = enabled === void 0 ? true : !!enabled;
            if (this._flags.sparse === value) {
              return this;
            }
            const obj = value ? this.clone() : this.$_addRule("items");
            return obj.$_setFlag("sparse", value, { clone: false });
          }
        },
        unique: {
          method(comparator, options = {}) {
            Assert(!comparator || typeof comparator === "function" || typeof comparator === "string", "comparator must be a function or a string");
            Common.assertOptions(options, ["ignoreUndefined", "separator"]);
            const rule = { name: "unique", args: { options, comparator } };
            if (comparator) {
              if (typeof comparator === "string") {
                const separator = Common.default(options.separator, ".");
                rule.path = separator ? comparator.split(separator) : [comparator];
              } else {
                rule.comparator = comparator;
              }
            }
            return this.$_addRule(rule);
          },
          validate(value, { state, error, schema }, { comparator: raw, options }, { comparator, path }) {
            const found = {
              string: /* @__PURE__ */ Object.create(null),
              number: /* @__PURE__ */ Object.create(null),
              undefined: /* @__PURE__ */ Object.create(null),
              boolean: /* @__PURE__ */ Object.create(null),
              object: /* @__PURE__ */ new Map(),
              function: /* @__PURE__ */ new Map(),
              custom: /* @__PURE__ */ new Map()
            };
            const compare = comparator || DeepEqual;
            const ignoreUndefined = options.ignoreUndefined;
            for (let i = 0; i < value.length; ++i) {
              const item = path ? Reach(value[i], path) : value[i];
              const records = comparator ? found.custom : found[typeof item];
              Assert(records, "Failed to find unique map container for type", typeof item);
              if (records instanceof Map) {
                const entries = records.entries();
                let current;
                while (!(current = entries.next()).done) {
                  if (compare(current.value[0], item)) {
                    const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                    const context = {
                      pos: i,
                      value: value[i],
                      dupePos: current.value[1],
                      dupeValue: value[current.value[1]]
                    };
                    if (path) {
                      context.path = raw;
                    }
                    return error("array.unique", context, localState);
                  }
                }
                records.set(item, i);
              } else {
                if ((!ignoreUndefined || item !== void 0) && records[item] !== void 0) {
                  const context = {
                    pos: i,
                    value: value[i],
                    dupePos: records[item],
                    dupeValue: value[records[item]]
                  };
                  if (path) {
                    context.path = raw;
                  }
                  const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                  return error("array.unique", context, localState);
                }
                records[item] = i;
              }
            }
            return value;
          },
          args: ["comparator", "options"],
          multi: true
        }
      },
      cast: {
        set: {
          from: Array.isArray,
          to(value, helpers) {
            return new Set(value);
          }
        }
      },
      rebuild(schema) {
        schema.$_terms._inclusions = [];
        schema.$_terms._exclusions = [];
        schema.$_terms._requireds = [];
        for (const type of schema.$_terms.items) {
          internals.validateSingle(type, schema);
          if (type._flags.presence === "required") {
            schema.$_terms._requireds.push(type);
          } else if (type._flags.presence === "forbidden") {
            schema.$_terms._exclusions.push(type);
          } else {
            schema.$_terms._inclusions.push(type);
          }
        }
        for (const type of schema.$_terms.ordered) {
          internals.validateSingle(type, schema);
        }
      },
      messages: {
        "array.base": "{{#label}} must be an array",
        "array.excludes": "{{#label}} contains an excluded value",
        "array.hasUnknown": "{{#label}} does not contain at least one required match",
        "array.includes": "{{#label}} does not match any of the allowed types",
        "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
        "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}",
        "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)",
        "array.length": "{{#label}} must contain {{#limit}} items",
        "array.max": "{{#label}} must contain less than or equal to {{#limit}} items",
        "array.min": "{{#label}} must contain at least {{#limit}} items",
        "array.orderedLength": "{{#label}} must contain at most {{#limit}} items",
        "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}",
        "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types",
        "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}",
        "array.sparse": "{{#label}} must not be a sparse array item",
        "array.unique": "{{#label}} contains a duplicate value"
      }
    });
    internals.fillMissedErrors = function(schema, errors, requireds, value, state, prefs) {
      let unknownMisses = 0;
      for (let i = 0; i < requireds.length; ++i) {
        ++unknownMisses;
      }
      errors.push(schema.$_createError("array.includesRequiredUnknowns", value, { unknownMisses }, state, prefs));
    };
    internals.fillOrderedErrors = function(schema, errors, ordereds, value, state, prefs) {
      const requiredOrdereds = [];
      for (const ordered of ordereds) {
        if (ordered._flags.presence === "required") {
          requiredOrdereds.push(ordered);
        }
      }
      if (requiredOrdereds.length) {
        internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);
      }
    };
    internals.fastSplice = function(arr, i) {
      let pos = i;
      while (pos < arr.length) {
        arr[pos++] = arr[pos];
      }
      --arr.length;
    };
    internals.validateSingle = function(type, obj) {
      if (type.type === "array" || type._flags._arrayItems) {
        Assert(!obj._flags.single, "Cannot specify array item with single rule enabled");
        obj.$_setFlag("_arrayItems", true, { clone: false });
      }
    };
    internals.sort = function(schema, value, settings, state, prefs) {
      const order = settings.order === "ascending" ? 1 : -1;
      const aFirst = -1 * order;
      const bFirst = order;
      const sort = (a, b) => {
        let compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        if (settings.by) {
          a = settings.by.resolve(a, state, prefs);
          b = settings.by.resolve(b, state, prefs);
        }
        compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        const type = typeof a;
        if (type !== typeof b) {
          throw schema.$_createError("array.sort.mismatching", value, null, state, prefs);
        }
        if (type !== "number" && type !== "string") {
          throw schema.$_createError("array.sort.unsupported", value, { type }, state, prefs);
        }
        if (type === "number") {
          return (a - b) * order;
        }
        return a < b ? aFirst : bFirst;
      };
      try {
        return { value: value.slice().sort(sort) };
      } catch (err) {
        return { errors: err };
      }
    };
    internals.compare = function(a, b, aFirst, bFirst) {
      if (a === b) {
        return 0;
      }
      if (a === void 0) {
        return 1;
      }
      if (b === void 0) {
        return -1;
      }
      if (a === null) {
        return bFirst;
      }
      if (b === null) {
        return aFirst;
      }
      return null;
    };
  }
});

// node_modules/@hapi/validate/lib/types/boolean.js
var require_boolean = __commonJS({
  "node_modules/@hapi/validate/lib/types/boolean.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Values = require_values();
    var internals = {};
    internals.isBool = function(value) {
      return typeof value === "boolean";
    };
    module2.exports = Any._extend({
      type: "boolean",
      flags: {
        sensitive: { default: false }
      },
      terms: {
        falsy: {
          init: null
        },
        truthy: {
          init: null
        }
      },
      coerce(value, { schema }) {
        if (typeof value === "boolean") {
          return;
        }
        if (typeof value === "string") {
          const normalized = schema._flags.sensitive ? value : value.toLowerCase();
          value = normalized === "true" ? true : normalized === "false" ? false : value;
        }
        if (typeof value !== "boolean") {
          value = schema.$_terms.truthy && schema.$_terms.truthy.has(value, null, null, !schema._flags.sensitive) || (schema.$_terms.falsy && schema.$_terms.falsy.has(value, null, null, !schema._flags.sensitive) ? false : value);
        }
        return { value };
      },
      validate(value, { error }) {
        if (typeof value !== "boolean") {
          return { value, errors: error("boolean.base") };
        }
      },
      rules: {
        truthy: {
          method(...values) {
            Common.verifyFlat(values, "truthy");
            const obj = this.clone();
            obj.$_terms.truthy = obj.$_terms.truthy || new Values();
            for (let i = 0; i < values.length; ++i) {
              const value = values[i];
              Assert(value !== void 0, "Cannot call truthy with undefined");
              obj.$_terms.truthy.add(value);
            }
            return obj;
          }
        },
        falsy: {
          method(...values) {
            Common.verifyFlat(values, "falsy");
            const obj = this.clone();
            obj.$_terms.falsy = obj.$_terms.falsy || new Values();
            for (let i = 0; i < values.length; ++i) {
              const value = values[i];
              Assert(value !== void 0, "Cannot call falsy with undefined");
              obj.$_terms.falsy.add(value);
            }
            return obj;
          }
        },
        sensitive: {
          method(enabled = true) {
            return this.$_setFlag("sensitive", enabled);
          }
        }
      },
      cast: {
        number: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? 1 : 0;
          }
        },
        string: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? "true" : "false";
          }
        }
      },
      messages: {
        "boolean.base": "{{#label}} must be a boolean"
      }
    });
  }
});

// node_modules/@hapi/validate/lib/types/date.js
var require_date = __commonJS({
  "node_modules/@hapi/validate/lib/types/date.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Template = require_template();
    var internals = {};
    internals.isDate = function(value) {
      return value instanceof Date;
    };
    module2.exports = Any._extend({
      type: "date",
      coerce: {
        from: ["number", "string"],
        method(value, { schema }) {
          return { value: internals.parse(value, schema._flags.format) || value };
        }
      },
      validate(value, { schema, error, prefs }) {
        if (value instanceof Date && !isNaN(value.getTime())) {
          return;
        }
        const format = schema._flags.format;
        if (!prefs.convert || !format || typeof value !== "string") {
          return { value, errors: error("date.base") };
        }
        return { value, errors: error("date.format", { format }) };
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { date }, { name, operator, args }) {
            const to = date === "now" ? Date.now() : date.getTime();
            if (Common.compare(value.getTime(), to, operator)) {
              return value;
            }
            return helpers.error("date." + name, { limit: args.date, value });
          },
          args: [
            {
              name: "date",
              ref: true,
              normalize: (date) => {
                return date === "now" ? date : internals.parse(date);
              },
              assert: (date) => date !== null,
              message: "must have a valid date format"
            }
          ]
        },
        format: {
          method(format) {
            Assert(["iso", "javascript", "unix"].includes(format), "Unknown date format", format);
            return this.$_setFlag("format", format);
          }
        },
        greater: {
          method(date) {
            return this.$_addRule({ name: "greater", method: "compare", args: { date }, operator: ">" });
          }
        },
        iso: {
          method() {
            return this.format("iso");
          }
        },
        less: {
          method(date) {
            return this.$_addRule({ name: "less", method: "compare", args: { date }, operator: "<" });
          }
        },
        max: {
          method(date) {
            return this.$_addRule({ name: "max", method: "compare", args: { date }, operator: "<=" });
          }
        },
        min: {
          method(date) {
            return this.$_addRule({ name: "min", method: "compare", args: { date }, operator: ">=" });
          }
        },
        timestamp: {
          method(type = "javascript") {
            Assert(["javascript", "unix"].includes(type), '"type" must be one of "javascript, unix"');
            return this.format(type);
          }
        }
      },
      cast: {
        number: {
          from: internals.isDate,
          to(value, helpers) {
            return value.getTime();
          }
        },
        string: {
          from: internals.isDate,
          to(value, { prefs }) {
            return Template.date(value, prefs);
          }
        }
      },
      messages: {
        "date.base": "{{#label}} must be a valid date",
        "date.format": "{{#label}} must be in {{#format}} format",
        "date.greater": "{{#label}} must be greater than {{:#limit}}",
        "date.less": "{{#label}} must be less than {{:#limit}}",
        "date.max": "{{#label}} must be less than or equal to {{:#limit}}",
        "date.min": "{{#label}} must be greater than or equal to {{:#limit}}"
      }
    });
    internals.parse = function(value, format) {
      if (value instanceof Date) {
        return value;
      }
      if (typeof value !== "string" && (isNaN(value) || !isFinite(value))) {
        return null;
      }
      if (/^\s*$/.test(value)) {
        return null;
      }
      if (format === "iso") {
        if (!Common.isIsoDate(value)) {
          return null;
        }
        return internals.date(value.toString());
      }
      const original = value;
      if (typeof value === "string" && /^[+-]?\d+(\.\d+)?$/.test(value)) {
        value = parseFloat(value);
      }
      if (format) {
        if (format === "javascript") {
          return internals.date(1 * value);
        }
        if (format === "unix") {
          return internals.date(1e3 * value);
        }
        if (typeof original === "string") {
          return null;
        }
      }
      return internals.date(value);
    };
    internals.date = function(value) {
      const date = new Date(value);
      if (!isNaN(date.getTime())) {
        return date;
      }
      return null;
    };
  }
});

// node_modules/@hapi/topo/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@hapi/topo/lib/index.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var internals = {};
    exports.Sorter = class {
      constructor() {
        this._items = [];
        this.nodes = [];
      }
      add(nodes, options) {
        options = options || {};
        const before = [].concat(options.before || []);
        const after = [].concat(options.after || []);
        const group = options.group || "?";
        const sort = options.sort || 0;
        Assert(!before.includes(group), `Item cannot come before itself: ${group}`);
        Assert(!before.includes("?"), "Item cannot come before unassociated items");
        Assert(!after.includes(group), `Item cannot come after itself: ${group}`);
        Assert(!after.includes("?"), "Item cannot come after unassociated items");
        if (!Array.isArray(nodes)) {
          nodes = [nodes];
        }
        for (const node of nodes) {
          const item = {
            seq: this._items.length,
            sort,
            before,
            after,
            group,
            node
          };
          this._items.push(item);
        }
        if (!options.manual) {
          const valid = this._sort();
          Assert(valid, "item", group !== "?" ? `added into group ${group}` : "", "created a dependencies error");
        }
        return this.nodes;
      }
      merge(others) {
        if (!Array.isArray(others)) {
          others = [others];
        }
        for (const other of others) {
          if (other) {
            for (const item of other._items) {
              this._items.push(Object.assign({}, item));
            }
          }
        }
        this._items.sort(internals.mergeSort);
        for (let i = 0; i < this._items.length; ++i) {
          this._items[i].seq = i;
        }
        const valid = this._sort();
        Assert(valid, "merge created a dependencies error");
        return this.nodes;
      }
      sort() {
        const valid = this._sort();
        Assert(valid, "sort created a dependencies error");
        return this.nodes;
      }
      _sort() {
        const graph = {};
        const graphAfters = /* @__PURE__ */ Object.create(null);
        const groups = /* @__PURE__ */ Object.create(null);
        for (const item of this._items) {
          const seq = item.seq;
          const group = item.group;
          groups[group] = groups[group] || [];
          groups[group].push(seq);
          graph[seq] = item.before;
          for (const after of item.after) {
            graphAfters[after] = graphAfters[after] || [];
            graphAfters[after].push(seq);
          }
        }
        for (const node in graph) {
          const expandedGroups = [];
          for (const graphNodeItem in graph[node]) {
            const group = graph[node][graphNodeItem];
            groups[group] = groups[group] || [];
            expandedGroups.push(...groups[group]);
          }
          graph[node] = expandedGroups;
        }
        for (const group in graphAfters) {
          if (groups[group]) {
            for (const node of groups[group]) {
              graph[node].push(...graphAfters[group]);
            }
          }
        }
        const ancestors = {};
        for (const node in graph) {
          const children = graph[node];
          for (const child of children) {
            ancestors[child] = ancestors[child] || [];
            ancestors[child].push(node);
          }
        }
        const visited = {};
        const sorted = [];
        for (let i = 0; i < this._items.length; ++i) {
          let next = i;
          if (ancestors[i]) {
            next = null;
            for (let j = 0; j < this._items.length; ++j) {
              if (visited[j] === true) {
                continue;
              }
              if (!ancestors[j]) {
                ancestors[j] = [];
              }
              const shouldSeeCount = ancestors[j].length;
              let seenCount = 0;
              for (let k = 0; k < shouldSeeCount; ++k) {
                if (visited[ancestors[j][k]]) {
                  ++seenCount;
                }
              }
              if (seenCount === shouldSeeCount) {
                next = j;
                break;
              }
            }
          }
          if (next !== null) {
            visited[next] = true;
            sorted.push(next);
          }
        }
        if (sorted.length !== this._items.length) {
          return false;
        }
        const seqIndex = {};
        for (const item of this._items) {
          seqIndex[item.seq] = item;
        }
        this._items = [];
        this.nodes = [];
        for (const value of sorted) {
          const sortedItem = seqIndex[value];
          this.nodes.push(sortedItem.node);
          this._items.push(sortedItem);
        }
        return true;
      }
    };
    internals.mergeSort = (a, b) => {
      return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;
    };
  }
});

// node_modules/@hapi/validate/lib/types/keys.js
var require_keys = __commonJS({
  "node_modules/@hapi/validate/lib/types/keys.js"(exports, module2) {
    "use strict";
    var ApplyToDefaults = require_applyToDefaults();
    var Assert = require_assert();
    var Clone = require_clone();
    var Topo = require_lib2();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Ref = require_ref();
    var internals = {
      renameDefaults: {
        alias: false,
        multiple: false,
        override: false
      }
    };
    module2.exports = Any._extend({
      type: "_keys",
      properties: {
        typeof: "object"
      },
      flags: {
        unknown: { default: false }
      },
      terms: {
        dependencies: { init: null },
        keys: { init: null },
        patterns: { init: null },
        renames: { init: null }
      },
      args(schema, keys) {
        return schema.keys(keys);
      },
      validate(value, { schema, error, state, prefs }) {
        if (!value || typeof value !== schema.$_property("typeof") || Array.isArray(value)) {
          return { value, errors: error("object.base", { type: schema.$_property("typeof") }) };
        }
        if (!schema.$_terms.renames && !schema.$_terms.dependencies && !schema.$_terms.keys && !schema.$_terms.patterns) {
          return;
        }
        value = internals.clone(value, prefs);
        const errors = [];
        if (schema.$_terms.renames && !internals.rename(schema, value, state, prefs, errors)) {
          return { value, errors };
        }
        if (!schema.$_terms.keys && !schema.$_terms.patterns && !schema.$_terms.dependencies) {
          return { value, errors };
        }
        const unprocessed = new Set(Object.keys(value));
        if (schema.$_terms.keys) {
          const ancestors = [value, ...state.ancestors];
          for (const child of schema.$_terms.keys) {
            const key = child.key;
            const item = value[key];
            unprocessed.delete(key);
            const localState = state.localize([...state.path, key], ancestors, child);
            const result = child.schema.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return { value, errors: result.errors };
              }
              errors.push(...result.errors);
            } else if (child.schema._flags.result === "strip" || result.value === void 0 && item !== void 0) {
              delete value[key];
            } else if (result.value !== void 0) {
              value[key] = result.value;
            }
          }
        }
        if (unprocessed.size || schema._flags._hasPatternMatch) {
          const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);
          if (early) {
            return early;
          }
        }
        if (schema.$_terms.dependencies) {
          for (const dep of schema.$_terms.dependencies) {
            if (dep.key && dep.key.resolve(value, state, prefs, null, { shadow: false }) === void 0) {
              continue;
            }
            const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);
            if (failed) {
              const report = schema.$_createError(failed.code, value, failed.context, state, prefs);
              if (prefs.abortEarly) {
                return { value, errors: report };
              }
              errors.push(report);
            }
          }
        }
        return { value, errors };
      },
      rules: {
        and: {
          method(...peers) {
            Common.verifyFlat(peers, "and");
            return internals.dependency(this, "and", null, peers);
          }
        },
        append: {
          method(schema) {
            if (schema === null || schema === void 0 || Object.keys(schema).length === 0) {
              return this;
            }
            return this.keys(schema);
          }
        },
        assert: {
          method(subject, schema, message) {
            subject = Compile.ref(subject);
            Assert(message === void 0 || typeof message === "string", "Message must be a string");
            schema = this.$_compile(schema, { appendPath: true });
            const obj = this.$_addRule({ name: "assert", args: { subject, schema, message } });
            obj.$_mutateRegister(subject);
            obj.$_mutateRegister(schema);
            return obj;
          },
          validate(value, { error, prefs, state }, { subject, schema, message }) {
            const about = subject.resolve(value, state, prefs);
            const path = subject.absolute(state);
            if (schema.$_match(about, state.localize(path, [value, ...state.ancestors], schema), prefs)) {
              return value;
            }
            return error("object.assert", { subject, message });
          },
          args: ["subject", "schema", "message"],
          multi: true
        },
        instance: {
          method(constructor, name) {
            Assert(typeof constructor === "function", "constructor must be a function");
            name = name || constructor.name;
            return this.$_addRule({ name: "instance", args: { constructor, name } });
          },
          validate(value, helpers, { constructor, name }) {
            if (value instanceof constructor) {
              return value;
            }
            return helpers.error("object.instance", { type: name, value });
          },
          args: ["constructor", "name"]
        },
        keys: {
          method(schema) {
            Assert(schema === void 0 || typeof schema === "object", "Object schema must be a valid object");
            Assert(!Common.isSchema(schema), "Object schema cannot be a joi schema");
            const obj = this.clone();
            if (!schema) {
              obj.$_terms.keys = null;
            } else if (!Object.keys(schema).length) {
              obj.$_terms.keys = new internals.Keys();
            } else {
              obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : new internals.Keys();
              for (const key in schema) {
                Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema[key]) }), key);
              }
            }
            return obj.$_mutateRebuild();
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(Object.keys(value).length, limit, operator)) {
              return value;
            }
            return helpers.error("object." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        },
        nand: {
          method(...peers) {
            Common.verifyFlat(peers, "nand");
            return internals.dependency(this, "nand", null, peers);
          }
        },
        or: {
          method(...peers) {
            Common.verifyFlat(peers, "or");
            return internals.dependency(this, "or", null, peers);
          }
        },
        oxor: {
          method(...peers) {
            return internals.dependency(this, "oxor", null, peers);
          }
        },
        pattern: {
          method(pattern, schema, options = {}) {
            const isRegExp = pattern instanceof RegExp;
            if (!isRegExp) {
              pattern = this.$_compile(pattern, { appendPath: true });
            }
            Assert(schema !== void 0, "Invalid rule");
            Common.assertOptions(options, ["fallthrough", "matches"]);
            if (isRegExp) {
              Assert(!pattern.flags.includes("g") && !pattern.flags.includes("y"), "pattern should not use global or sticky mode");
            }
            schema = this.$_compile(schema, { appendPath: true });
            const obj = this.clone();
            obj.$_terms.patterns = obj.$_terms.patterns || [];
            const config = { [isRegExp ? "regex" : "schema"]: pattern, rule: schema };
            if (options.matches) {
              config.matches = this.$_compile(options.matches);
              if (config.matches.type !== "array") {
                config.matches = config.matches.$_root.array().items(config.matches);
              }
              obj.$_mutateRegister(config.matches);
              obj.$_setFlag("_hasPatternMatch", true, { clone: false });
            }
            if (options.fallthrough) {
              config.fallthrough = true;
            }
            obj.$_terms.patterns.push(config);
            obj.$_mutateRegister(schema);
            return obj;
          }
        },
        ref: {
          method() {
            return this.$_addRule("ref");
          },
          validate(value, helpers) {
            if (Ref.isRef(value)) {
              return value;
            }
            return helpers.error("object.refType", { value });
          }
        },
        regex: {
          method() {
            return this.$_addRule("regex");
          },
          validate(value, helpers) {
            if (value instanceof RegExp) {
              return value;
            }
            return helpers.error("object.regex", { value });
          }
        },
        rename: {
          method(from, to, options = {}) {
            Assert(typeof from === "string" || from instanceof RegExp, "Rename missing the from argument");
            Assert(typeof to === "string", "Invalid rename to argument");
            Assert(to !== from, "Cannot rename key to same name:", from);
            Common.assertOptions(options, ["alias", "ignoreUndefined", "override", "multiple"]);
            const obj = this.clone();
            obj.$_terms.renames = obj.$_terms.renames || [];
            for (const rename of obj.$_terms.renames) {
              Assert(rename.from !== from, "Cannot rename the same key multiple times");
            }
            obj.$_terms.renames.push({
              from,
              to,
              options: ApplyToDefaults(internals.renameDefaults, options)
            });
            return obj;
          }
        },
        schema: {
          method(type = "any") {
            return this.$_addRule({ name: "schema", args: { type } });
          },
          validate(value, helpers, { type }) {
            if (Common.isSchema(value) && (type === "any" || value.type === type)) {
              return value;
            }
            return helpers.error("object.schema", { type });
          }
        },
        unknown: {
          method(allow) {
            return this.$_setFlag("unknown", allow !== false);
          }
        },
        with: {
          method(key, peers, options = {}) {
            return internals.dependency(this, "with", key, peers, options);
          }
        },
        without: {
          method(key, peers, options = {}) {
            return internals.dependency(this, "without", key, peers, options);
          }
        },
        xor: {
          method(...peers) {
            Common.verifyFlat(peers, "xor");
            return internals.dependency(this, "xor", null, peers);
          }
        }
      },
      overrides: {
        default(value, options) {
          if (value === void 0) {
            value = Common.symbols.deepDefault;
          }
          return this.$_parent("default", value, options);
        }
      },
      rebuild(schema) {
        if (schema.$_terms.keys) {
          const topo = new Topo.Sorter();
          for (const child of schema.$_terms.keys) {
            Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);
          }
          schema.$_terms.keys = new internals.Keys(...topo.nodes);
        }
      },
      messages: {
        "object.and": "{{#label}} contains {{#present}} without its required peers {{#missing}}",
        "object.assert": "{{#label}} is invalid because it failed to pass the assertion test",
        "object.base": "{{#label}} must be of type {{#type}}",
        "object.instance": "{{#label}} must be an instance of {{:#type}}",
        "object.length": "{{#label}} must have {{#limit}} keys",
        "object.max": "{{#label}} must have less than or equal to {{#limit}} keys",
        "object.min": "{{#label}} must have at least {{#limit}} keys",
        "object.missing": "{{#label}} must contain at least one of {{#peers}}",
        "object.nand": "{{:#main}} must not exist simultaneously with {{#peers}}",
        "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peers}}",
        "object.pattern.match": "{{#label}} keys failed to match pattern requirements",
        "object.refType": "{{#label}} must be a Joi reference",
        "object.regex": "{{#label}} must be a RegExp object",
        "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
        "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
        "object.schema": "{{#label}} must be a Joi schema of {{#type}} type",
        "object.unknown": "{{#label}} is not allowed",
        "object.with": "{{:#main}} missing required peer {{:#peer}}",
        "object.without": "{{:#main}} conflict with forbidden peer {{:#peer}}",
        "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peers}}"
      }
    });
    internals.clone = function(value, prefs) {
      if (typeof value === "object") {
        if (prefs.nonEnumerables) {
          return Clone(value, { shallow: true });
        }
        const clone2 = Object.create(Object.getPrototypeOf(value));
        Object.assign(clone2, value);
        return clone2;
      }
      const clone = function(...args) {
        return value.apply(this, args);
      };
      clone.prototype = Clone(value.prototype);
      Object.defineProperty(clone, "name", { value: value.name, writable: false });
      Object.defineProperty(clone, "length", { value: value.length, writable: false });
      Object.assign(clone, value);
      return clone;
    };
    internals.dependency = function(schema, rel, key, peers, options) {
      Assert(key === null || typeof key === "string", rel, "key must be a strings");
      if (!options) {
        options = peers.length > 1 && typeof peers[peers.length - 1] === "object" ? peers.pop() : {};
      }
      Common.assertOptions(options, ["separator"]);
      peers = [].concat(peers);
      const separator = Common.default(options.separator, ".");
      const paths = [];
      for (const peer of peers) {
        Assert(typeof peer === "string", rel, "peers must be a string or a reference");
        paths.push(Compile.ref(peer, { separator, ancestor: 0, prefix: false }));
      }
      if (key !== null) {
        key = Compile.ref(key, { separator, ancestor: 0, prefix: false });
      }
      const obj = schema.clone();
      obj.$_terms.dependencies = obj.$_terms.dependencies || [];
      obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers));
      return obj;
    };
    internals.dependencies = {
      and(schema, dep, value, state, prefs) {
        const missing = [];
        const present = [];
        const count = dep.peers.length;
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) === void 0) {
            missing.push(peer.key);
          } else {
            present.push(peer.key);
          }
        }
        if (missing.length !== count && present.length !== count) {
          return {
            code: "object.and",
            context: {
              present,
              missing
            }
          };
        }
      },
      nand(schema, dep, value, state, prefs) {
        const present = [];
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) !== void 0) {
            present.push(peer.key);
          }
        }
        if (present.length !== dep.peers.length) {
          return;
        }
        const main = dep.paths[0];
        const values = dep.paths.slice(1);
        return {
          code: "object.nand",
          context: {
            main,
            peers: values
          }
        };
      },
      or(schema, dep, value, state, prefs) {
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) !== void 0) {
            return;
          }
        }
        return {
          code: "object.missing",
          context: {
            peers: dep.paths
          }
        };
      },
      oxor(schema, dep, value, state, prefs) {
        const present = [];
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) !== void 0) {
            present.push(peer.key);
          }
        }
        if (!present.length || present.length === 1) {
          return;
        }
        const context = { peers: dep.paths };
        context.present = present;
        return { code: "object.oxor", context };
      },
      with(schema, dep, value, state, prefs) {
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) === void 0) {
            return {
              code: "object.with",
              context: {
                main: dep.key.key,
                peer: peer.key
              }
            };
          }
        }
      },
      without(schema, dep, value, state, prefs) {
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) !== void 0) {
            return {
              code: "object.without",
              context: {
                main: dep.key.key,
                peer: peer.key
              }
            };
          }
        }
      },
      xor(schema, dep, value, state, prefs) {
        const present = [];
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) !== void 0) {
            present.push(peer.key);
          }
        }
        if (present.length === 1) {
          return;
        }
        const context = { peers: dep.paths };
        if (present.length === 0) {
          return { code: "object.missing", context };
        }
        context.present = present;
        return { code: "object.xor", context };
      }
    };
    internals.rename = function(schema, value, state, prefs, errors) {
      const renamed = {};
      for (const rename of schema.$_terms.renames) {
        const matches = [];
        const pattern = typeof rename.from !== "string";
        if (!pattern) {
          if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== void 0 || !rename.options.ignoreUndefined)) {
            matches.push(rename);
          }
        } else {
          for (const from in value) {
            if (value[from] === void 0 && rename.options.ignoreUndefined) {
              continue;
            }
            if (from === rename.to) {
              continue;
            }
            const match = rename.from.exec(from);
            if (!match) {
              continue;
            }
            matches.push({ from, to: rename.to, match });
          }
        }
        for (const match of matches) {
          const from = match.from;
          const to = match.to;
          if (!rename.options.multiple && renamed[to]) {
            errors.push(schema.$_createError("object.rename.multiple", value, { from, to, pattern }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {
            errors.push(schema.$_createError("object.rename.override", value, { from, to, pattern }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (value[from] === void 0) {
            delete value[to];
          } else {
            value[to] = value[from];
          }
          renamed[to] = true;
          if (!rename.options.alias) {
            delete value[from];
          }
        }
      }
      return true;
    };
    internals.unknown = function(schema, value, unprocessed, errors, state, prefs) {
      if (schema.$_terms.patterns) {
        let hasMatches = false;
        const matches = schema.$_terms.patterns.map((pattern) => {
          if (pattern.matches) {
            hasMatches = true;
            return [];
          }
        });
        const ancestors = [value, ...state.ancestors];
        for (const key of unprocessed) {
          const item = value[key];
          const path = [...state.path, key];
          for (let i = 0; i < schema.$_terms.patterns.length; ++i) {
            const pattern = schema.$_terms.patterns[i];
            if (pattern.regex) {
              const match = pattern.regex.test(key);
              if (!match) {
                continue;
              }
            } else {
              if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {
                continue;
              }
            }
            unprocessed.delete(key);
            const localState = state.localize(path, ancestors, { schema: pattern.rule, key });
            const result = pattern.rule.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return { value, errors: result.errors };
              }
              errors.push(...result.errors);
            }
            if (pattern.matches) {
              matches[i].push(key);
            }
            value[key] = result.value;
            if (!pattern.fallthrough) {
              break;
            }
          }
        }
        if (hasMatches) {
          for (let i = 0; i < matches.length; ++i) {
            const match = matches[i];
            if (!match) {
              continue;
            }
            const stpm = schema.$_terms.patterns[i].matches;
            const localState = state.localize(state.path, ancestors, stpm);
            const result = stpm.$_validate(match, localState, prefs);
            if (result.errors) {
              const details = Errors.details(result.errors, { override: false });
              details.matches = match;
              const report = schema.$_createError("object.pattern.match", value, details, state, prefs);
              if (prefs.abortEarly) {
                return { value, errors: report };
              }
              errors.push(report);
            }
          }
        }
      }
      if (!unprocessed.size || !schema.$_terms.keys && !schema.$_terms.patterns) {
        return;
      }
      if (prefs.stripUnknown && !schema._flags.unknown || prefs.skipFunctions) {
        const stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;
        for (const key of unprocessed) {
          if (stripUnknown) {
            delete value[key];
            unprocessed.delete(key);
          } else if (typeof value[key] === "function") {
            unprocessed.delete(key);
          }
        }
      }
      const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);
      if (forbidUnknown) {
        for (const unprocessedKey of unprocessed) {
          const localState = state.localize([...state.path, unprocessedKey], []);
          const report = schema.$_createError("object.unknown", value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });
          if (prefs.abortEarly) {
            return { value, errors: report };
          }
          errors.push(report);
        }
      }
    };
    internals.Dependency = class {
      constructor(rel, key, peers, paths) {
        this.rel = rel;
        this.key = key;
        this.peers = peers;
        this.paths = paths;
      }
    };
    internals.Keys = class extends Array {
      concat(source) {
        const result = this.slice();
        const keys = /* @__PURE__ */ new Map();
        for (let i = 0; i < result.length; ++i) {
          keys.set(result[i].key, i);
        }
        for (const item of source) {
          const key = item.key;
          const pos = keys.get(key);
          if (pos !== void 0) {
            result[pos] = { key, schema: result[pos].schema.concat(item.schema) };
          } else {
            result.push(item);
          }
        }
        return result;
      }
    };
  }
});

// node_modules/@hapi/validate/lib/types/function.js
var require_function = __commonJS({
  "node_modules/@hapi/validate/lib/types/function.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Keys = require_keys();
    module2.exports = Keys._extend({
      type: "function",
      properties: {
        typeof: "function"
      },
      rules: {
        arity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({ name: "arity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length === n) {
              return value;
            }
            return helpers.error("function.arity", { n });
          }
        },
        class: {
          method() {
            return this.$_addRule("class");
          },
          validate(value, helpers) {
            if (/^\s*class\s/.test(value.toString())) {
              return value;
            }
            return helpers.error("function.class", { value });
          }
        },
        minArity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n > 0, "n must be a strict positive integer");
            return this.$_addRule({ name: "minArity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length >= n) {
              return value;
            }
            return helpers.error("function.minArity", { n });
          }
        },
        maxArity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({ name: "maxArity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length <= n) {
              return value;
            }
            return helpers.error("function.maxArity", { n });
          }
        }
      },
      messages: {
        "function.arity": "{{#label}} must have an arity of {{#n}}",
        "function.class": "{{#label}} must be a class",
        "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}",
        "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}"
      }
    });
  }
});

// node_modules/@hapi/validate/lib/types/link.js
var require_link = __commonJS({
  "node_modules/@hapi/validate/lib/types/link.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var internals = {};
    module2.exports = Any._extend({
      type: "link",
      properties: {
        schemaChain: true
      },
      terms: {
        link: { init: null, register: false }
      },
      args(schema, ref) {
        return schema.ref(ref);
      },
      validate(value, { schema, state, prefs }) {
        Assert(schema.$_terms.link, "Uninitialized link schema");
        const linked = internals.generate(schema, value, state, prefs);
        const ref = schema.$_terms.link[0].ref;
        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);
      },
      generate(schema, value, state, prefs) {
        return internals.generate(schema, value, state, prefs);
      },
      rules: {
        ref: {
          method(ref) {
            Assert(!this.$_terms.link, "Cannot reinitialize schema");
            ref = Compile.ref(ref);
            Assert(ref.type === "value" || ref.type === "local", "Invalid reference type:", ref.type);
            Assert(ref.type === "local" || ref.ancestor === "root" || ref.ancestor > 0, "Link cannot reference itself");
            const obj = this.clone();
            obj.$_terms.link = [{ ref }];
            return obj;
          }
        },
        relative: {
          method(enabled = true) {
            return this.$_setFlag("relative", enabled);
          }
        }
      },
      overrides: {
        concat(source) {
          Assert(this.$_terms.link, "Uninitialized link schema");
          Assert(Common.isSchema(source), "Invalid schema object");
          Assert(source.type !== "link", "Cannot merge type link with another link");
          const obj = this.clone();
          if (!obj.$_terms.whens) {
            obj.$_terms.whens = [];
          }
          obj.$_terms.whens.push({ concat: source });
          return obj.$_mutateRebuild();
        }
      }
    });
    internals.generate = function(schema, value, state, prefs) {
      let linked = state.mainstay.links.get(schema);
      if (linked) {
        return linked._generate(value, state, prefs).schema;
      }
      const ref = schema.$_terms.link[0].ref;
      const { perspective, path } = internals.perspective(ref, state);
      internals.assert(perspective, "which is outside of schema boundaries", ref, schema, state, prefs);
      try {
        linked = path.length ? perspective.$_reach(path) : perspective;
      } catch (ignoreErr) {
        internals.assert(false, "to non-existing schema", ref, schema, state, prefs);
      }
      internals.assert(linked.type !== "link", "which is another link", ref, schema, state, prefs);
      if (!schema._flags.relative) {
        state.mainstay.links.set(schema, linked);
      }
      return linked._generate(value, state, prefs).schema;
    };
    internals.perspective = function(ref, state) {
      if (ref.type === "local") {
        for (const { schema, key } of state.schemas) {
          const id = schema._flags.id || key;
          if (id === ref.path[0]) {
            return { perspective: schema, path: ref.path.slice(1) };
          }
          if (schema.$_terms.shared) {
            for (const shared of schema.$_terms.shared) {
              if (shared._flags.id === ref.path[0]) {
                return { perspective: shared, path: ref.path.slice(1) };
              }
            }
          }
        }
        return { perspective: null, path: null };
      }
      if (ref.ancestor === "root") {
        return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };
      }
      return { perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema, path: ref.path };
    };
    internals.assert = function(condition, message, ref, schema, state, prefs) {
      if (condition) {
        return;
      }
      Assert(false, `"${Errors.label(schema._flags, state, prefs)}" contains link reference "${ref.display}" ${message}`);
    };
  }
});

// node_modules/@hapi/validate/lib/types/number.js
var require_number = __commonJS({
  "node_modules/@hapi/validate/lib/types/number.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    var internals = {
      numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
      precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/
    };
    module2.exports = Any._extend({
      type: "number",
      flags: {
        unsafe: { default: false }
      },
      coerce: {
        from: "string",
        method(value, { schema, error }) {
          const matches = value.match(internals.numberRx);
          if (!matches) {
            return;
          }
          value = value.trim();
          const result = { value: parseFloat(value) };
          if (result.value === 0) {
            result.value = 0;
          }
          if (!schema._flags.unsafe) {
            if (value.match(/e/i)) {
              const constructed = internals.normalizeExponent(`${result.value / Math.pow(10, matches[1])}e${matches[1]}`);
              if (constructed !== internals.normalizeExponent(value)) {
                result.errors = error("number.unsafe");
                return result;
              }
            } else {
              const string = result.value.toString();
              if (string.match(/e/i)) {
                return result;
              }
              if (string !== internals.normalizeDecimal(value)) {
                result.errors = error("number.unsafe");
                return result;
              }
            }
          }
          return result;
        }
      },
      validate(value, { schema, error, prefs }) {
        if (value === Infinity || value === -Infinity) {
          return { value, errors: error("number.infinity") };
        }
        if (!Common.isNumber(value)) {
          return { value, errors: error("number.base") };
        }
        const result = { value };
        if (prefs.convert) {
          const rule = schema.$_getRule("precision");
          if (rule) {
            const precision = Math.pow(10, rule.args.limit);
            result.value = Math.round(result.value * precision) / precision;
          }
        }
        if (result.value === 0) {
          result.value = 0;
        }
        if (!schema._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
          result.errors = error("number.unsafe");
        }
        return result;
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value, limit, operator)) {
              return value;
            }
            return helpers.error("number." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.isNumber,
              message: "must be a number"
            }
          ]
        },
        greater: {
          method(limit) {
            return this.$_addRule({ name: "greater", method: "compare", args: { limit }, operator: ">" });
          }
        },
        integer: {
          method() {
            return this.$_addRule("integer");
          },
          validate(value, helpers) {
            if (Math.trunc(value) - value === 0) {
              return value;
            }
            return helpers.error("number.integer");
          }
        },
        less: {
          method(limit) {
            return this.$_addRule({ name: "less", method: "compare", args: { limit }, operator: "<" });
          }
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "compare", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "compare", args: { limit }, operator: ">=" });
          }
        },
        multiple: {
          method(base) {
            return this.$_addRule({ name: "multiple", args: { base } });
          },
          validate(value, helpers, { base }, options) {
            if (value % base === 0) {
              return value;
            }
            return helpers.error("number.multiple", { multiple: options.args.base, value });
          },
          args: [
            {
              name: "base",
              ref: true,
              assert: (value) => typeof value === "number" && isFinite(value) && value > 0,
              message: "must be a positive number"
            }
          ],
          multi: true
        },
        negative: {
          method() {
            return this.sign("negative");
          }
        },
        port: {
          method() {
            return this.$_addRule("port");
          },
          validate(value, helpers) {
            if (Number.isSafeInteger(value) && value >= 0 && value <= 65535) {
              return value;
            }
            return helpers.error("number.port");
          }
        },
        positive: {
          method() {
            return this.sign("positive");
          }
        },
        precision: {
          method(limit) {
            Assert(Number.isSafeInteger(limit), "limit must be an integer");
            return this.$_addRule({ name: "precision", args: { limit } });
          },
          validate(value, helpers, { limit }) {
            const places = value.toString().match(internals.precisionRx);
            const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
            if (decimals <= limit) {
              return value;
            }
            return helpers.error("number.precision", { limit, value });
          },
          convert: true
        },
        sign: {
          method(sign) {
            Assert(["negative", "positive"].includes(sign), "Invalid sign", sign);
            return this.$_addRule({ name: "sign", args: { sign } });
          },
          validate(value, helpers, { sign }) {
            if (sign === "negative" && value < 0 || sign === "positive" && value > 0) {
              return value;
            }
            return helpers.error(`number.${sign}`);
          }
        },
        unsafe: {
          method(enabled = true) {
            Assert(typeof enabled === "boolean", "enabled must be a boolean");
            return this.$_setFlag("unsafe", enabled);
          }
        }
      },
      cast: {
        string: {
          from: (value) => typeof value === "number",
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "number.base": "{{#label}} must be a number",
        "number.greater": "{{#label}} must be greater than {{#limit}}",
        "number.infinity": "{{#label}} cannot be infinity",
        "number.integer": "{{#label}} must be an integer",
        "number.less": "{{#label}} must be less than {{#limit}}",
        "number.max": "{{#label}} must be less than or equal to {{#limit}}",
        "number.min": "{{#label}} must be greater than or equal to {{#limit}}",
        "number.multiple": "{{#label}} must be a multiple of {{#multiple}}",
        "number.negative": "{{#label}} must be a negative number",
        "number.port": "{{#label}} must be a valid port",
        "number.positive": "{{#label}} must be a positive number",
        "number.precision": "{{#label}} must have no more than {{#limit}} decimal places",
        "number.unsafe": "{{#label}} must be a safe number"
      }
    });
    internals.normalizeExponent = function(str) {
      return str.replace(/E/, "e").replace(/\.(\d*[1-9])?0+e/, ".$1e").replace(/\.e/, "e").replace(/e\+/, "e").replace(/^\+/, "").replace(/^(-?)0+([1-9])/, "$1$2");
    };
    internals.normalizeDecimal = function(str) {
      str = str.replace(/^\+/, "").replace(/\.0+$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([1-9])/, "$1$2");
      if (str.includes(".") && str.endsWith("0")) {
        str = str.replace(/0+$/, "");
      }
      if (str === "-0") {
        return "0";
      }
      return str;
    };
  }
});

// node_modules/@hapi/validate/lib/types/object.js
var require_object = __commonJS({
  "node_modules/@hapi/validate/lib/types/object.js"(exports, module2) {
    "use strict";
    var Keys = require_keys();
    module2.exports = Keys._extend({
      type: "object",
      cast: {
        map: {
          from: (value) => value && typeof value === "object",
          to(value, helpers) {
            return new Map(Object.entries(value));
          }
        }
      }
    });
  }
});

// node_modules/@hapi/validate/lib/types/string.js
var require_string = __commonJS({
  "node_modules/@hapi/validate/lib/types/string.js"(exports, module2) {
    "use strict";
    var Url = require("url");
    var Assert = require_assert();
    var EscapeRegex = require_escapeRegex();
    var Any = require_any();
    var Common = require_common();
    var internals = {
      base64Regex: {
        true: {
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
        },
        false: {
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
        }
      },
      dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
      hexRegex: /^[a-f0-9]+$/i,
      isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
      guidBrackets: {
        "{": "}",
        "[": "]",
        "(": ")",
        "": ""
      },
      guidVersions: {
        uuidv1: "1",
        uuidv2: "2",
        uuidv3: "3",
        uuidv4: "4",
        uuidv5: "5"
      },
      guidSeparators: /* @__PURE__ */ new Set([void 0, true, false, "-", ":"]),
      normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"],
      domainControlRx: /[\x00-\x20@\:\/]/,
      domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
      finalSegmentAdditionalRx: /[^0-9]/
    };
    module2.exports = Any._extend({
      type: "string",
      flags: {
        insensitive: { default: false },
        truncate: { default: false }
      },
      terms: {
        replacements: { init: null }
      },
      coerce: {
        from: "string",
        method(value, { schema, state, prefs }) {
          const normalize = schema.$_getRule("normalize");
          if (normalize) {
            value = value.normalize(normalize.args.form);
          }
          const casing = schema.$_getRule("case");
          if (casing) {
            value = casing.args.direction === "upper" ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
          }
          const trim = schema.$_getRule("trim");
          if (trim && trim.args.enabled) {
            value = value.trim();
          }
          if (schema.$_terms.replacements) {
            for (const replacement of schema.$_terms.replacements) {
              value = value.replace(replacement.pattern, replacement.replacement);
            }
          }
          const hex = schema.$_getRule("hex");
          if (hex && hex.args.options.byteAligned && value.length % 2 !== 0) {
            value = `0${value}`;
          }
          if (schema.$_getRule("isoDate")) {
            const iso = internals.isoDate(value);
            if (iso) {
              value = iso;
            }
          }
          if (schema._flags.truncate) {
            const rule = schema.$_getRule("max");
            if (rule) {
              let limit = rule.args.limit;
              if (Common.isResolvable(limit)) {
                limit = limit.resolve(value, state, prefs);
                if (!Common.limit(limit)) {
                  return { value, errors: schema.$_createError("any.ref", limit, { ref: rule.args.limit, arg: "limit", reason: "must be a positive integer" }, state, prefs) };
                }
              }
              value = value.slice(0, limit);
            }
          }
          return { value };
        }
      },
      validate(value, { error }) {
        if (typeof value !== "string") {
          return { value, errors: error("string.base") };
        }
        if (value === "") {
          return { value, errors: error("string.empty") };
        }
      },
      rules: {
        alphanum: {
          method() {
            return this.$_addRule("alphanum");
          },
          validate(value, helpers) {
            if (/^[a-zA-Z0-9]+$/.test(value)) {
              return value;
            }
            return helpers.error("string.alphanum");
          }
        },
        base64: {
          method(options = {}) {
            Common.assertOptions(options, ["paddingRequired", "urlSafe"]);
            options = { urlSafe: false, paddingRequired: true, ...options };
            Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
            Assert(typeof options.urlSafe === "boolean", "urlSafe must be boolean");
            return this.$_addRule({ name: "base64", args: { options } });
          },
          validate(value, helpers, { options }) {
            const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];
            if (regex.test(value)) {
              return value;
            }
            return helpers.error("string.base64");
          }
        },
        case: {
          method(direction) {
            Assert(["lower", "upper"].includes(direction), "Invalid case:", direction);
            return this.$_addRule({ name: "case", args: { direction } });
          },
          validate(value, helpers, { direction }) {
            if (direction === "lower" && value === value.toLocaleLowerCase() || direction === "upper" && value === value.toLocaleUpperCase()) {
              return value;
            }
            return helpers.error(`string.${direction}case`);
          },
          convert: true
        },
        creditCard: {
          method() {
            return this.$_addRule("creditCard");
          },
          validate(value, helpers) {
            let i = value.length;
            let sum = 0;
            let mul = 1;
            while (i--) {
              const char = value.charAt(i) * mul;
              sum = sum + (char - (char > 9) * 9);
              mul = mul ^ 3;
            }
            if (sum > 0 && sum % 10 === 0) {
              return value;
            }
            return helpers.error("string.creditCard");
          }
        },
        dataUri: {
          method(options = {}) {
            Common.assertOptions(options, ["paddingRequired"]);
            options = { paddingRequired: true, ...options };
            Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
            return this.$_addRule({ name: "dataUri", args: { options } });
          },
          validate(value, helpers, { options }) {
            const matches = value.match(internals.dataUriRegex);
            if (matches) {
              if (!matches[2]) {
                return value;
              }
              if (matches[2] !== "base64") {
                return value;
              }
              const base64regex = internals.base64Regex[options.paddingRequired].false;
              if (base64regex.test(matches[3])) {
                return value;
              }
            }
            return helpers.error("string.dataUri");
          }
        },
        guid: {
          alias: "uuid",
          method(options = {}) {
            Common.assertOptions(options, ["version", "separator"]);
            let versionNumbers = "";
            if (options.version) {
              const versions = [].concat(options.version);
              Assert(versions.length >= 1, "version must have at least 1 valid version specified");
              const set = /* @__PURE__ */ new Set();
              for (let i = 0; i < versions.length; ++i) {
                const version = versions[i];
                Assert(typeof version === "string", "version at position " + i + " must be a string");
                const versionNumber = internals.guidVersions[version.toLowerCase()];
                Assert(versionNumber, "version at position " + i + " must be one of " + Object.keys(internals.guidVersions).join(", "));
                Assert(!set.has(versionNumber), "version at position " + i + " must not be a duplicate");
                versionNumbers += versionNumber;
                set.add(versionNumber);
              }
            }
            Assert(internals.guidSeparators.has(options.separator), 'separator must be one of true, false, "-", or ":"');
            const separator = options.separator === void 0 ? "[:-]?" : options.separator === true ? "[:-]" : options.separator === false ? "[]?" : `\\${options.separator}`;
            const regex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${separator})[0-9A-F]{4}\\2?[${versionNumbers || "0-9A-F"}][0-9A-F]{3}\\2?[${versionNumbers ? "89AB" : "0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, "i");
            return this.$_addRule({ name: "guid", args: { options }, regex });
          },
          validate(value, helpers, args, { regex }) {
            const results = regex.exec(value);
            if (!results) {
              return helpers.error("string.guid");
            }
            if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
              return helpers.error("string.guid");
            }
            return value;
          }
        },
        hex: {
          method(options = {}) {
            Common.assertOptions(options, ["byteAligned"]);
            options = { byteAligned: false, ...options };
            Assert(typeof options.byteAligned === "boolean", "byteAligned must be boolean");
            return this.$_addRule({ name: "hex", args: { options } });
          },
          validate(value, helpers, { options }) {
            if (!internals.hexRegex.test(value)) {
              return helpers.error("string.hex");
            }
            if (options.byteAligned && value.length % 2 !== 0) {
              return helpers.error("string.hexAlign");
            }
            return value;
          }
        },
        hostname: {
          method() {
            return this.$_addRule("hostname");
          },
          validate(value, helpers) {
            if (internals.isDomainValid(value) || internals.ipRegex.test(value)) {
              return value;
            }
            return helpers.error("string.hostname");
          }
        },
        insensitive: {
          method() {
            return this.$_setFlag("insensitive", true);
          }
        },
        isoDate: {
          method() {
            return this.$_addRule("isoDate");
          },
          validate(value, { error }) {
            if (internals.isoDate(value)) {
              return value;
            }
            return error("string.isoDate");
          }
        },
        isoDuration: {
          method() {
            return this.$_addRule("isoDuration");
          },
          validate(value, helpers) {
            if (internals.isoDurationRegex.test(value)) {
              return value;
            }
            return helpers.error("string.isoDuration");
          }
        },
        length: {
          method(limit, encoding) {
            return internals.length(this, "length", limit, "=", encoding);
          },
          validate(value, helpers, { limit, encoding }, { name, operator, args }) {
            const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;
            if (Common.compare(length, limit, operator)) {
              return value;
            }
            return helpers.error("string." + name, { limit: args.limit, value, encoding });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            },
            "encoding"
          ]
        },
        lowercase: {
          method() {
            return this.case("lower");
          }
        },
        max: {
          method(limit, encoding) {
            return internals.length(this, "max", limit, "<=", encoding);
          },
          args: ["limit", "encoding"]
        },
        min: {
          method(limit, encoding) {
            return internals.length(this, "min", limit, ">=", encoding);
          },
          args: ["limit", "encoding"]
        },
        normalize: {
          method(form = "NFC") {
            Assert(internals.normalizationForms.includes(form), "normalization form must be one of " + internals.normalizationForms.join(", "));
            return this.$_addRule({ name: "normalize", args: { form } });
          },
          validate(value, { error }, { form }) {
            if (value === value.normalize(form)) {
              return value;
            }
            return error("string.normalize", { value, form });
          },
          convert: true
        },
        pattern: {
          alias: "regex",
          method(regex, options = {}) {
            Assert(regex instanceof RegExp, "regex must be a RegExp");
            Assert(!regex.flags.includes("g") && !regex.flags.includes("y"), "regex should not use global or sticky mode");
            if (typeof options === "string") {
              options = { name: options };
            }
            Common.assertOptions(options, ["invert", "name"]);
            const errorCode = ["string.pattern", options.invert ? ".invert" : "", options.name ? ".name" : ".base"].join("");
            return this.$_addRule({ name: "pattern", args: { regex, options }, errorCode });
          },
          validate(value, helpers, { regex, options }, { errorCode }) {
            const patternMatch = regex.test(value);
            if (patternMatch ^ options.invert) {
              return value;
            }
            return helpers.error(errorCode, { name: options.name, regex, value });
          },
          args: ["regex", "options"],
          multi: true
        },
        replace: {
          method(pattern, replacement) {
            if (typeof pattern === "string") {
              pattern = new RegExp(EscapeRegex(pattern), "g");
            }
            Assert(pattern instanceof RegExp, "pattern must be a RegExp");
            Assert(typeof replacement === "string", "replacement must be a String");
            const obj = this.clone();
            if (!obj.$_terms.replacements) {
              obj.$_terms.replacements = [];
            }
            obj.$_terms.replacements.push({ pattern, replacement });
            return obj;
          }
        },
        token: {
          method() {
            return this.$_addRule("token");
          },
          validate(value, helpers) {
            if (/^\w+$/.test(value)) {
              return value;
            }
            return helpers.error("string.token");
          }
        },
        trim: {
          method(enabled = true) {
            Assert(typeof enabled === "boolean", "enabled must be a boolean");
            return this.$_addRule({ name: "trim", args: { enabled } });
          },
          validate(value, helpers, { enabled }) {
            if (!enabled || value === value.trim()) {
              return value;
            }
            return helpers.error("string.trim");
          },
          convert: true
        },
        truncate: {
          method(enabled = true) {
            Assert(typeof enabled === "boolean", "enabled must be a boolean");
            return this.$_setFlag("truncate", enabled);
          }
        },
        uppercase: {
          method() {
            return this.case("upper");
          }
        }
      },
      messages: {
        "string.alphanum": "{{#label}} must only contain alpha-numeric characters",
        "string.base": "{{#label}} must be a string",
        "string.base64": "{{#label}} must be a valid base64 string",
        "string.creditCard": "{{#label}} must be a credit card",
        "string.dataUri": "{{#label}} must be a valid dataUri string",
        "string.empty": "{{#label}} is not allowed to be empty",
        "string.guid": "{{#label}} must be a valid GUID",
        "string.hex": "{{#label}} must only contain hexadecimal characters",
        "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned",
        "string.hostname": "{{#label}} must be a valid hostname",
        "string.isoDate": "{{#label}} must be in iso format",
        "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration",
        "string.length": "{{#label}} length must be {{#limit}} characters long",
        "string.lowercase": "{{#label}} must only contain lowercase characters",
        "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long",
        "string.min": "{{#label}} length must be at least {{#limit}} characters long",
        "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form",
        "string.token": "{{#label}} must only contain alpha-numeric and underscore characters",
        "string.pattern.base": "{{#label}} with value {:.} fails to match the required pattern: {{#regex}}",
        "string.pattern.name": "{{#label}} with value {:.} fails to match the {{#name}} pattern",
        "string.pattern.invert.base": "{{#label}} with value {:.} matches the inverted pattern: {{#regex}}",
        "string.pattern.invert.name": "{{#label}} with value {:.} matches the inverted {{#name}} pattern",
        "string.trim": "{{#label}} must not have leading or trailing whitespace",
        "string.uppercase": "{{#label}} must only contain uppercase characters"
      }
    });
    internals.isoDate = function(value) {
      if (!Common.isIsoDate(value)) {
        return null;
      }
      const date = new Date(value);
      if (isNaN(date.getTime())) {
        return null;
      }
      return date.toISOString();
    };
    internals.length = function(schema, name, limit, operator, encoding) {
      Assert(!encoding || Buffer && Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
      return schema.$_addRule({ name, method: "length", args: { limit, encoding }, operator });
    };
    internals.rfc3986 = function() {
      const rfc3986 = {};
      const hexDigit = "\\dA-Fa-f";
      const hexDigitOnly = "[" + hexDigit + "]";
      const unreserved = "\\w-\\.~";
      const subDelims = "!\\$&'\\(\\)\\*\\+,;=";
      const decOctect = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
      rfc3986.ipv4 = "(?:" + decOctect + "\\.){3}" + decOctect;
      const h16 = hexDigitOnly + "{1,4}";
      const ls32 = "(?:" + h16 + ":" + h16 + "|" + rfc3986.ipv4 + ")";
      const IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
      const IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
      const IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
      const IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
      const IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
      const IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
      const IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
      const IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
      const IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
      rfc3986.v4Cidr = "(?:\\d|[1-2]\\d|3[0-2])";
      rfc3986.v6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])";
      rfc3986.ipv6 = "(?:" + IPv6SixHex + "|" + IPv6FiveHex + "|" + IPv6FourHex + "|" + IPv6ThreeHex + "|" + IPv6TwoHex + "|" + IPv6OneHex + "|" + IPv6NoneHex + "|" + IPv6NoneHex2 + "|" + IPv6NoneHex3 + ")";
      rfc3986.ipvfuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
      return rfc3986;
    };
    internals.ipRegex = function() {
      const versions = ["ipv4", "ipv6", "ipvfuture"];
      const rfc3986 = internals.rfc3986();
      const parts = versions.map((version) => {
        const cidrpart = `\\/${version === "ipv4" ? rfc3986.v4Cidr : rfc3986.v6Cidr}`;
        return `${rfc3986[version]}(?:${cidrpart})?`;
      });
      const raw = `(?:${parts.join("|")})`;
      return new RegExp(`^${raw}$`);
    }();
    internals.isDomainValid = function(domain) {
      if (domain.length > 256) {
        return false;
      }
      domain = domain.normalize("NFC");
      if (internals.domainControlRx.test(domain)) {
        return false;
      }
      domain = internals.punycode(domain);
      const segments = domain.split(".");
      for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];
        if (!segment.length) {
          return false;
        }
        if (segment.length > 63) {
          return false;
        }
        if (!internals.domainSegmentRx.test(segment)) {
          return false;
        }
        const isFinalSegment = i === segments.length - 1;
        if (isFinalSegment && !internals.finalSegmentAdditionalRx.test(segment)) {
          return false;
        }
      }
      return true;
    };
    internals.punycode = function(domain) {
      try {
        return new Url.URL(`http://${domain}`).host;
      } catch (err) {
        return domain;
      }
    };
  }
});

// node_modules/@hapi/validate/lib/types/symbol.js
var require_symbol = __commonJS({
  "node_modules/@hapi/validate/lib/types/symbol.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var internals = {};
    internals.Map = class extends Map {
      slice() {
        return new internals.Map(this);
      }
    };
    module2.exports = Any._extend({
      type: "symbol",
      terms: {
        map: { init: new internals.Map() }
      },
      coerce: {
        method(value, { schema, error }) {
          const lookup = schema.$_terms.map.get(value);
          if (lookup) {
            value = lookup;
          }
          if (!schema._flags.only || typeof value === "symbol") {
            return { value };
          }
          return { value, errors: error("symbol.map", { map: schema.$_terms.map }) };
        }
      },
      validate(value, { error }) {
        if (typeof value !== "symbol") {
          return { value, errors: error("symbol.base") };
        }
      },
      rules: {
        map: {
          method(iterable) {
            if (iterable && !iterable[Symbol.iterator] && typeof iterable === "object") {
              iterable = Object.entries(iterable);
            }
            Assert(iterable && iterable[Symbol.iterator], "Iterable must be an iterable or object");
            const obj = this.clone();
            const symbols = [];
            for (const entry of iterable) {
              Assert(entry && entry[Symbol.iterator], "Entry must be an iterable");
              const [key, value] = entry;
              Assert(typeof key !== "object" && typeof key !== "function" && typeof key !== "symbol", "Key must not be of type object, function, or Symbol");
              Assert(typeof value === "symbol", "Value must be a Symbol");
              obj.$_terms.map.set(key, value);
              symbols.push(value);
            }
            return obj.valid(...symbols);
          }
        }
      },
      messages: {
        "symbol.base": "{{#label}} must be a symbol",
        "symbol.map": "{{#label}} must be one of {{#map}}"
      }
    });
  }
});

// node_modules/@hapi/validate/lib/types/binary.js
var require_binary = __commonJS({
  "node_modules/@hapi/validate/lib/types/binary.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any();
    var Common = require_common();
    module2.exports = Any._extend({
      type: "binary",
      coerce: {
        from: "string",
        method(value, { schema }) {
          try {
            return { value: Buffer.from(value, schema._flags.encoding) };
          } catch (ignoreErr) {
          }
        }
      },
      validate(value, { error }) {
        if (!Buffer.isBuffer(value)) {
          return { value, errors: error("binary.base") };
        }
      },
      rules: {
        encoding: {
          method(encoding) {
            Assert(Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
            return this.$_setFlag("encoding", encoding);
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", method: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("binary." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        }
      },
      cast: {
        string: {
          from: (value) => Buffer.isBuffer(value),
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "binary.base": "{{#label}} must be a buffer or a string",
        "binary.length": "{{#label}} must be {{#limit}} bytes",
        "binary.max": "{{#label}} must be less than or equal to {{#limit}} bytes",
        "binary.min": "{{#label}} must be at least {{#limit}} bytes"
      }
    });
  }
});

// node_modules/@hapi/validate/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@hapi/validate/lib/index.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common();
    var Compile = require_compile();
    var Errors = require_errors();
    var Ref = require_ref();
    var internals = {
      types: {
        alternatives: require_alternatives(),
        any: require_any(),
        array: require_array(),
        boolean: require_boolean(),
        date: require_date(),
        function: require_function(),
        link: require_link(),
        number: require_number(),
        object: require_object(),
        string: require_string(),
        symbol: require_symbol()
      },
      aliases: {
        alt: "alternatives",
        bool: "boolean",
        func: "function"
      }
    };
    if (Buffer) {
      internals.types.binary = require_binary();
    }
    internals.root = function() {
      const root = {
        _types: new Set(Object.keys(internals.types))
      };
      for (const type of root._types) {
        root[type] = function(...args) {
          Assert(!args.length || ["alternatives", "link", "object"].includes(type), "The", type, "type does not allow arguments");
          return internals.generate(this, internals.types[type], args);
        };
      }
      for (const method of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"]) {
        root[method] = function(...args) {
          return this.any()[method](...args);
        };
      }
      Object.assign(root, internals.methods);
      for (const alias in internals.aliases) {
        const target = internals.aliases[alias];
        root[alias] = root[target];
      }
      return root;
    };
    internals.methods = {
      ValidationError: Errors.ValidationError,
      version: Common.version,
      assert(value, schema, ...args) {
        internals.assert(value, schema, true, args);
      },
      attempt(value, schema, ...args) {
        return internals.assert(value, schema, false, args);
      },
      checkPreferences(prefs) {
        Common.checkPreferences(prefs);
      },
      compile(schema, options) {
        return Compile.compile(this, schema, options);
      },
      isError: Errors.ValidationError.isError,
      isRef: Ref.isRef,
      isSchema: Common.isSchema,
      in(...args) {
        return Ref.in(...args);
      },
      override: Common.symbols.override,
      ref(...args) {
        return Ref.create(...args);
      }
    };
    internals.assert = function(value, schema, annotate, args) {
      const message = args[0] instanceof Error || typeof args[0] === "string" ? args[0] : null;
      const options = message ? args[1] : args[0];
      const result = schema.validate(value, Common.preferences({ errors: { stack: true } }, options || {}));
      let error = result.error;
      if (!error) {
        return result.value;
      }
      if (message instanceof Error) {
        throw message;
      }
      const display = annotate && typeof error.annotate === "function" ? error.annotate() : error.message;
      if (error instanceof Errors.ValidationError === false) {
        error = Clone(error);
      }
      error.message = message ? `${message} ${display}` : display;
      throw error;
    };
    internals.generate = function(root, schema, args) {
      Assert(root, "Must be invoked on a Joi instance.");
      schema.$_root = root;
      if (!schema._definition.args || !args.length) {
        return schema;
      }
      return schema._definition.args(schema, ...args);
    };
    module2.exports = internals.root();
  }
});

// node_modules/@hapi/shot/lib/symbols.js
var require_symbols = __commonJS({
  "node_modules/@hapi/shot/lib/symbols.js"(exports) {
    "use strict";
    exports.injection = Symbol("injection");
  }
});

// node_modules/@hapi/shot/lib/request.js
var require_request = __commonJS({
  "node_modules/@hapi/shot/lib/request.js"(exports, module2) {
    "use strict";
    var Stream = require("stream");
    var Url = require("url");
    var Symbols = require_symbols();
    var internals = {};
    exports = module2.exports = internals.Request = class extends Stream.Readable {
      constructor(options) {
        super({
          emitClose: !!(options.simulate && options.simulate.close),
          autoDestroy: true
        });
        let url = options.url;
        if (typeof url === "object") {
          url = Url.format(url);
        }
        const uri = Url.parse(url);
        this.url = uri.path;
        this.httpVersion = "1.1";
        this.method = options.method ? options.method.toUpperCase() : "GET";
        this.headers = {};
        const headers = options.headers || {};
        const fields = Object.keys(headers);
        fields.forEach((field) => {
          this.headers[field.toLowerCase()] = headers[field];
        });
        this.headers["user-agent"] = this.headers["user-agent"] || "shot";
        const hostHeaderFromUri = function() {
          if (uri.port) {
            return uri.host;
          }
          if (uri.protocol) {
            return uri.hostname + (uri.protocol === "https:" ? ":443" : ":80");
          }
          return null;
        };
        this.headers.host = this.headers.host || hostHeaderFromUri() || options.authority || "localhost:80";
        this.connection = {
          remoteAddress: options.remoteAddress || "127.0.0.1"
        };
        let payload = options.payload || null;
        if (payload && typeof payload !== "string" && !(payload instanceof Stream) && !Buffer.isBuffer(payload)) {
          payload = JSON.stringify(payload);
          this.headers["content-type"] = this.headers["content-type"] || "application/json";
        }
        if (payload && !(payload instanceof Stream) && !this.headers.hasOwnProperty("content-length")) {
          this.headers["content-length"] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
        }
        this._shot = {
          payload,
          isDone: false,
          simulate: options.simulate || {}
        };
        return this;
      }
      prepare(next) {
        if (this._shot.payload instanceof Stream === false) {
          return next();
        }
        const chunks = [];
        this._shot.payload.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
        this._shot.payload.on("end", () => {
          const payload = Buffer.concat(chunks);
          this.headers["content-length"] = this.headers["content-length"] || payload.length;
          this._shot.payload = payload;
          return next();
        });
      }
      _read(size) {
        setImmediate(() => {
          if (this._shot.isDone) {
            if (this._shot.simulate.end !== false) {
              this.push(null);
            }
            return;
          }
          this._shot.isDone = true;
          if (this._shot.payload) {
            if (this._shot.simulate.split) {
              this.push(this._shot.payload.slice(0, 1));
              this.push(this._shot.payload.slice(1));
            } else {
              this.push(this._shot.payload);
            }
          }
          if (this._shot.simulate.error) {
            this.destroy(new Error("Simulated"));
          } else if (this._shot.simulate.end !== false) {
            this.push(null);
          } else if (this._shot.simulate.close) {
            this.emit("close");
          }
        });
      }
    };
    internals.Request.prototype[Symbols.injection] = true;
  }
});

// node_modules/@hapi/shot/lib/response.js
var require_response = __commonJS({
  "node_modules/@hapi/shot/lib/response.js"(exports, module2) {
    "use strict";
    var Http = require("http");
    var Stream = require("stream");
    var Symbols = require_symbols();
    var internals = {};
    exports = module2.exports = internals.Response = class extends Http.ServerResponse {
      constructor(req, onEnd) {
        super({ method: req.method, httpVersionMajor: 1, httpVersionMinor: 1 });
        this._shot = { headers: null, trailers: {}, payloadChunks: [] };
        this.assignSocket(internals.nullSocket());
        if (req._shot.simulate.close) {
          req.once("close", () => {
            process.nextTick(() => this.emit("close"));
          });
        }
        this.once("finish", () => {
          const res = internals.payload(this);
          res.raw.req = req;
          process.nextTick(() => onEnd(res));
        });
      }
      writeHead(...args) {
        const headers = args[args.length - 1];
        if (typeof headers === "object" && headers !== null) {
          const headerNames = Object.keys(headers);
          for (let i = 0; i < headerNames.length; ++i) {
            const name = headerNames[i];
            try {
              this.setHeader(name, headers[name]);
              break;
            } catch (ignoreErr) {
            }
          }
        }
        const result = super.writeHead(...args);
        this._shot.headers = this.getHeaders();
        ["Date", "Connection", "Transfer-Encoding"].forEach((name) => {
          const regex = new RegExp("\\r\\n" + name + ": ([^\\r]*)\\r\\n");
          const field = this._header.match(regex);
          if (field) {
            this._shot.headers[name.toLowerCase()] = field[1];
          }
        });
        return result;
      }
      write(data, encoding, callback) {
        super.write(data, encoding, callback);
        this._shot.payloadChunks.push(Buffer.from(data, encoding));
        return true;
      }
      end(data, encoding, callback) {
        if (data) {
          this.write(data, encoding);
        }
        super.end(callback);
        this.emit("finish");
      }
      addTrailers(trailers) {
        for (const key in trailers) {
          this._shot.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();
        }
      }
    };
    internals.Response.prototype[Symbols.injection] = true;
    internals.payload = function(response) {
      const res = {
        raw: {
          res: response
        },
        headers: response._shot.headers,
        statusCode: response.statusCode,
        statusMessage: response.statusMessage,
        trailers: {}
      };
      const rawBuffer = Buffer.concat(response._shot.payloadChunks);
      res.rawPayload = rawBuffer;
      res.payload = rawBuffer.toString();
      res.trailers = response._shot.trailers;
      return res;
    };
    internals.nullSocket = function() {
      return new Stream.Writable({
        write(chunk, encoding, callback) {
          setImmediate(callback);
        }
      });
    };
  }
});

// node_modules/@hapi/shot/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@hapi/shot/lib/index.js"(exports) {
    "use strict";
    var Hoek = require_lib();
    var Validate = require_lib3();
    var Request = require_request();
    var Response = require_response();
    var Symbols = require_symbols();
    var internals = {};
    internals.options = Validate.object().keys({
      url: Validate.alternatives([
        Validate.string(),
        Validate.object().keys({
          protocol: Validate.string(),
          hostname: Validate.string(),
          port: Validate.any(),
          pathname: Validate.string().required(),
          query: Validate.any()
        })
      ]).required(),
      headers: Validate.object(),
      payload: Validate.any(),
      simulate: {
        end: Validate.boolean(),
        split: Validate.boolean(),
        error: Validate.boolean(),
        close: Validate.boolean()
      },
      authority: Validate.string(),
      remoteAddress: Validate.string(),
      method: Validate.string(),
      validate: Validate.boolean()
    });
    exports.inject = function(dispatchFunc, options) {
      options = typeof options === "string" ? { url: options } : options;
      if (options.validate !== false) {
        try {
          Hoek.assert(typeof dispatchFunc === "function", "Invalid dispatch function");
          Validate.assert(options, internals.options);
        } catch (err) {
          return Promise.reject(err);
        }
      }
      return new Promise((resolve) => {
        const req = new Request(options);
        const res = new Response(req, resolve);
        req.prepare(() => dispatchFunc(req, res));
      });
    };
    exports.isInjection = function(obj) {
      return !!obj[Symbols.injection];
    };
  }
});

// node_modules/@hapi/boom/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@hapi/boom/lib/index.js"(exports) {
    "use strict";
    var Hoek = require_lib();
    var internals = {
      codes: /* @__PURE__ */ new Map([
        [100, "Continue"],
        [101, "Switching Protocols"],
        [102, "Processing"],
        [200, "OK"],
        [201, "Created"],
        [202, "Accepted"],
        [203, "Non-Authoritative Information"],
        [204, "No Content"],
        [205, "Reset Content"],
        [206, "Partial Content"],
        [207, "Multi-Status"],
        [300, "Multiple Choices"],
        [301, "Moved Permanently"],
        [302, "Moved Temporarily"],
        [303, "See Other"],
        [304, "Not Modified"],
        [305, "Use Proxy"],
        [307, "Temporary Redirect"],
        [400, "Bad Request"],
        [401, "Unauthorized"],
        [402, "Payment Required"],
        [403, "Forbidden"],
        [404, "Not Found"],
        [405, "Method Not Allowed"],
        [406, "Not Acceptable"],
        [407, "Proxy Authentication Required"],
        [408, "Request Time-out"],
        [409, "Conflict"],
        [410, "Gone"],
        [411, "Length Required"],
        [412, "Precondition Failed"],
        [413, "Request Entity Too Large"],
        [414, "Request-URI Too Large"],
        [415, "Unsupported Media Type"],
        [416, "Requested Range Not Satisfiable"],
        [417, "Expectation Failed"],
        [418, "I'm a teapot"],
        [422, "Unprocessable Entity"],
        [423, "Locked"],
        [424, "Failed Dependency"],
        [425, "Too Early"],
        [426, "Upgrade Required"],
        [428, "Precondition Required"],
        [429, "Too Many Requests"],
        [431, "Request Header Fields Too Large"],
        [451, "Unavailable For Legal Reasons"],
        [500, "Internal Server Error"],
        [501, "Not Implemented"],
        [502, "Bad Gateway"],
        [503, "Service Unavailable"],
        [504, "Gateway Time-out"],
        [505, "HTTP Version Not Supported"],
        [506, "Variant Also Negotiates"],
        [507, "Insufficient Storage"],
        [509, "Bandwidth Limit Exceeded"],
        [510, "Not Extended"],
        [511, "Network Authentication Required"]
      ])
    };
    exports.Boom = class extends Error {
      constructor(message, options = {}) {
        if (message instanceof Error) {
          return exports.boomify(Hoek.clone(message), options);
        }
        const { statusCode = 500, data = null, ctor = exports.Boom } = options;
        const error = new Error(message ? message : void 0);
        Error.captureStackTrace(error, ctor);
        error.data = data;
        const boom = internals.initialize(error, statusCode);
        Object.defineProperty(boom, "typeof", { value: ctor });
        if (options.decorate) {
          Object.assign(boom, options.decorate);
        }
        return boom;
      }
      static [Symbol.hasInstance](instance) {
        if (this === exports.Boom) {
          return exports.isBoom(instance);
        }
        return this.prototype.isPrototypeOf(instance);
      }
    };
    exports.isBoom = function(err, statusCode) {
      return err instanceof Error && !!err.isBoom && (!statusCode || err.output.statusCode === statusCode);
    };
    exports.boomify = function(err, options) {
      Hoek.assert(err instanceof Error, "Cannot wrap non-Error object");
      options = options || {};
      if (options.data !== void 0) {
        err.data = options.data;
      }
      if (options.decorate) {
        Object.assign(err, options.decorate);
      }
      if (!err.isBoom) {
        return internals.initialize(err, options.statusCode || 500, options.message);
      }
      if (options.override === false || !options.statusCode && !options.message) {
        return err;
      }
      return internals.initialize(err, options.statusCode || err.output.statusCode, options.message);
    };
    exports.badRequest = function(message, data) {
      return new exports.Boom(message, { statusCode: 400, data, ctor: exports.badRequest });
    };
    exports.unauthorized = function(message, scheme, attributes) {
      const err = new exports.Boom(message, { statusCode: 401, ctor: exports.unauthorized });
      if (!scheme) {
        return err;
      }
      if (typeof scheme !== "string") {
        err.output.headers["WWW-Authenticate"] = scheme.join(", ");
        return err;
      }
      let wwwAuthenticate = `${scheme}`;
      if (attributes || message) {
        err.output.payload.attributes = {};
      }
      if (attributes) {
        if (typeof attributes === "string") {
          wwwAuthenticate += " " + Hoek.escapeHeaderAttribute(attributes);
          err.output.payload.attributes = attributes;
        } else {
          wwwAuthenticate += " " + Object.keys(attributes).map((name) => {
            let value = attributes[name];
            if (value === null || value === void 0) {
              value = "";
            }
            err.output.payload.attributes[name] = value;
            return `${name}="${Hoek.escapeHeaderAttribute(value.toString())}"`;
          }).join(", ");
        }
      }
      if (message) {
        if (attributes) {
          wwwAuthenticate += ",";
        }
        wwwAuthenticate += ` error="${Hoek.escapeHeaderAttribute(message)}"`;
        err.output.payload.attributes.error = message;
      } else {
        err.isMissing = true;
      }
      err.output.headers["WWW-Authenticate"] = wwwAuthenticate;
      return err;
    };
    exports.paymentRequired = function(message, data) {
      return new exports.Boom(message, { statusCode: 402, data, ctor: exports.paymentRequired });
    };
    exports.forbidden = function(message, data) {
      return new exports.Boom(message, { statusCode: 403, data, ctor: exports.forbidden });
    };
    exports.notFound = function(message, data) {
      return new exports.Boom(message, { statusCode: 404, data, ctor: exports.notFound });
    };
    exports.methodNotAllowed = function(message, data, allow) {
      const err = new exports.Boom(message, { statusCode: 405, data, ctor: exports.methodNotAllowed });
      if (typeof allow === "string") {
        allow = [allow];
      }
      if (Array.isArray(allow)) {
        err.output.headers.Allow = allow.join(", ");
      }
      return err;
    };
    exports.notAcceptable = function(message, data) {
      return new exports.Boom(message, { statusCode: 406, data, ctor: exports.notAcceptable });
    };
    exports.proxyAuthRequired = function(message, data) {
      return new exports.Boom(message, { statusCode: 407, data, ctor: exports.proxyAuthRequired });
    };
    exports.clientTimeout = function(message, data) {
      return new exports.Boom(message, { statusCode: 408, data, ctor: exports.clientTimeout });
    };
    exports.conflict = function(message, data) {
      return new exports.Boom(message, { statusCode: 409, data, ctor: exports.conflict });
    };
    exports.resourceGone = function(message, data) {
      return new exports.Boom(message, { statusCode: 410, data, ctor: exports.resourceGone });
    };
    exports.lengthRequired = function(message, data) {
      return new exports.Boom(message, { statusCode: 411, data, ctor: exports.lengthRequired });
    };
    exports.preconditionFailed = function(message, data) {
      return new exports.Boom(message, { statusCode: 412, data, ctor: exports.preconditionFailed });
    };
    exports.entityTooLarge = function(message, data) {
      return new exports.Boom(message, { statusCode: 413, data, ctor: exports.entityTooLarge });
    };
    exports.uriTooLong = function(message, data) {
      return new exports.Boom(message, { statusCode: 414, data, ctor: exports.uriTooLong });
    };
    exports.unsupportedMediaType = function(message, data) {
      return new exports.Boom(message, { statusCode: 415, data, ctor: exports.unsupportedMediaType });
    };
    exports.rangeNotSatisfiable = function(message, data) {
      return new exports.Boom(message, { statusCode: 416, data, ctor: exports.rangeNotSatisfiable });
    };
    exports.expectationFailed = function(message, data) {
      return new exports.Boom(message, { statusCode: 417, data, ctor: exports.expectationFailed });
    };
    exports.teapot = function(message, data) {
      return new exports.Boom(message, { statusCode: 418, data, ctor: exports.teapot });
    };
    exports.badData = function(message, data) {
      return new exports.Boom(message, { statusCode: 422, data, ctor: exports.badData });
    };
    exports.locked = function(message, data) {
      return new exports.Boom(message, { statusCode: 423, data, ctor: exports.locked });
    };
    exports.failedDependency = function(message, data) {
      return new exports.Boom(message, { statusCode: 424, data, ctor: exports.failedDependency });
    };
    exports.tooEarly = function(message, data) {
      return new exports.Boom(message, { statusCode: 425, data, ctor: exports.tooEarly });
    };
    exports.preconditionRequired = function(message, data) {
      return new exports.Boom(message, { statusCode: 428, data, ctor: exports.preconditionRequired });
    };
    exports.tooManyRequests = function(message, data) {
      return new exports.Boom(message, { statusCode: 429, data, ctor: exports.tooManyRequests });
    };
    exports.illegal = function(message, data) {
      return new exports.Boom(message, { statusCode: 451, data, ctor: exports.illegal });
    };
    exports.internal = function(message, data, statusCode = 500) {
      return internals.serverError(message, data, statusCode, exports.internal);
    };
    exports.notImplemented = function(message, data) {
      return internals.serverError(message, data, 501, exports.notImplemented);
    };
    exports.badGateway = function(message, data) {
      return internals.serverError(message, data, 502, exports.badGateway);
    };
    exports.serverUnavailable = function(message, data) {
      return internals.serverError(message, data, 503, exports.serverUnavailable);
    };
    exports.gatewayTimeout = function(message, data) {
      return internals.serverError(message, data, 504, exports.gatewayTimeout);
    };
    exports.badImplementation = function(message, data) {
      const err = internals.serverError(message, data, 500, exports.badImplementation);
      err.isDeveloperError = true;
      return err;
    };
    internals.initialize = function(err, statusCode, message) {
      const numberCode = parseInt(statusCode, 10);
      Hoek.assert(!isNaN(numberCode) && numberCode >= 400, "First argument must be a number (400+):", statusCode);
      err.isBoom = true;
      err.isServer = numberCode >= 500;
      if (!err.hasOwnProperty("data")) {
        err.data = null;
      }
      err.output = {
        statusCode: numberCode,
        payload: {},
        headers: {}
      };
      Object.defineProperty(err, "reformat", { value: internals.reformat, configurable: true });
      if (!message && !err.message) {
        err.reformat();
        message = err.output.payload.error;
      }
      if (message) {
        const props = Object.getOwnPropertyDescriptor(err, "message") || Object.getOwnPropertyDescriptor(Object.getPrototypeOf(err), "message");
        Hoek.assert(!props || props.configurable && !props.get, "The error is not compatible with boom");
        err.message = message + (err.message ? ": " + err.message : "");
        err.output.payload.message = err.message;
      }
      err.reformat();
      return err;
    };
    internals.reformat = function(debug = false) {
      this.output.payload.statusCode = this.output.statusCode;
      this.output.payload.error = internals.codes.get(this.output.statusCode) || "Unknown";
      if (this.output.statusCode === 500 && debug !== true) {
        this.output.payload.message = "An internal server error occurred";
      } else if (this.message) {
        this.output.payload.message = this.message;
      }
    };
    internals.serverError = function(message, data, statusCode, ctor) {
      if (data instanceof Error && !data.isBoom) {
        return exports.boomify(data, { statusCode, message });
      }
      return new exports.Boom(message, { statusCode, data, ctor });
    };
  }
});

// node_modules/@hapi/bounce/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@hapi/bounce/lib/index.js"(exports) {
    "use strict";
    var Assert = require("assert");
    var Boom = require_lib5();
    var Hoek = require_lib();
    var internals = {
      system: [
        EvalError,
        RangeError,
        ReferenceError,
        SyntaxError,
        TypeError,
        URIError,
        Assert.AssertionError,
        Hoek.Error
      ]
    };
    exports.rethrow = function(err, types, options = {}) {
      return internals.catch(err, types, options, true);
    };
    exports.ignore = function(err, types, options = {}) {
      return internals.catch(err, types, options, false);
    };
    internals.catch = function(err, types, options, match) {
      if (internals.match(err, types) !== match) {
        return;
      }
      if (options.override) {
        err = options.override;
      }
      if (options.decorate) {
        Object.assign(err, options.decorate);
      }
      if (options.return) {
        return err;
      }
      throw err;
    };
    exports.background = async function(operation, action = "rethrow", types = "system", options = {}) {
      try {
        if (typeof operation === "function") {
          await operation();
        } else {
          await operation;
        }
      } catch (err) {
        exports[action](err, types, options);
      }
    };
    exports.isBoom = function(err) {
      return Boom.isBoom(err);
    };
    exports.isError = function(err) {
      return err instanceof Error;
    };
    exports.isSystem = function(err) {
      if (!err) {
        return false;
      }
      if (err.isBoom) {
        return false;
      }
      for (const system of internals.system) {
        if (err instanceof system) {
          return true;
        }
      }
      return false;
    };
    internals.rules = {
      system: exports.isSystem,
      boom: exports.isBoom
    };
    internals.match = function(err, types) {
      if (!types) {
        return true;
      }
      types = Array.isArray(types) ? types : [types];
      for (const type of types) {
        if (typeof type === "string") {
          if (internals.rules[type](err)) {
            return true;
          }
        } else if (typeof type === "object") {
          if (Hoek.contain(err, type, { deep: true, part: true })) {
            return true;
          }
        } else if (err instanceof type) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/@hapi/somever/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/@hapi/somever/lib/index.js"(exports) {
    "use strict";
    var Bounce = require_lib6();
    var Hoek = require_lib();
    var internals = {
      maxLength: 256,
      wildcards: ["x", "X", "*"],
      any: Symbol("any")
    };
    internals.versionRx = /^\s*[vV]?(\d+|[xX*])(?:\.(\d+|[xX*])(?:\.(\d+|[xX*])(?:\-?([^+]+))?(?:\+(.+))?)?)?\s*$/;
    internals.strict = {
      tokenRx: /^[-\dA-Za-z]+(?:\.[-\dA-Za-z]+)*$/,
      numberRx: /^((?:0)|(?:[1-9]\d*))$/
    };
    exports.version = function(version, options) {
      return new internals.Version(version, options);
    };
    exports.range = function(range) {
      return new internals.Range(range);
    };
    exports.match = function(version, range) {
      try {
        return exports.range(range).match(version);
      } catch (err) {
        Bounce.rethrow(err, "system");
        return false;
      }
    };
    exports.compare = function(a, b, options = {}) {
      let aFirst = -1;
      let bFirst = 1;
      a = exports.version(a, options);
      b = exports.version(b, options);
      if (options.range && a.prerelease.length && (a.major !== b.major || a.minor !== b.minor || a.patch !== b.patch || !b.prerelease.length)) {
        aFirst = -2;
        bFirst = 2;
      }
      for (let i = 0; i < 3; ++i) {
        const av = a.dots[i];
        const bv = b.dots[i];
        if (av === bv || av === internals.any || bv === internals.any) {
          continue;
        }
        return av - bv < 0 ? aFirst : bFirst;
      }
      if (!a.prerelease.length && !b.prerelease.length) {
        return 0;
      }
      if (!!a.prerelease.length !== !!b.prerelease.length) {
        return a.prerelease.length ? aFirst : bFirst;
      }
      for (let i = 0; ; ++i) {
        const ai = a.prerelease[i];
        const bi = b.prerelease[i];
        if (ai === void 0 && bi === void 0) {
          return 0;
        }
        if (ai === bi) {
          continue;
        }
        if (ai === void 0) {
          return aFirst;
        }
        if (bi === void 0) {
          return bFirst;
        }
        const an = Number.isFinite(ai);
        const bn = Number.isFinite(bi);
        if (an !== bn) {
          return an ? aFirst : bFirst;
        }
        return ai < bi ? aFirst : bFirst;
      }
    };
    internals.Version = class {
      constructor(version, options = {}) {
        Hoek.assert(version, "Missing version argument");
        if (version instanceof internals.Version) {
          return version;
        }
        if (typeof version === "object") {
          this._copy(version);
        } else {
          this._parse(version, options);
        }
        this.format();
      }
      _copy(version) {
        this.major = version.major === void 0 ? internals.any : version.major;
        this.minor = version.minor === void 0 ? internals.any : version.minor;
        this.patch = version.patch === void 0 ? internals.any : version.patch;
        this.prerelease = version.prerelease || [];
        this.build = version.build || [];
      }
      _parse(version, options) {
        Hoek.assert(typeof version === "string", "Version argument must be a string");
        Hoek.assert(version.length <= internals.maxLength, "Version string too long");
        const match = version.match(internals.versionRx);
        if (!match) {
          throw new Error(`Invalid version string format: ${version}`);
        }
        this.major = internals.Version._number(match[1], "major", options);
        this.minor = internals.Version._number(match[2] || "x", "minor", options);
        this.patch = internals.Version._number(match[3] || "x", "patch", options);
        this.prerelease = internals.Version._sub(match[4], "prerelease", options);
        this.build = internals.Version._sub(match[5], "build", options);
      }
      static _number(string, source, options) {
        if (internals.wildcards.includes(string)) {
          return internals.any;
        }
        if (options.strict) {
          Hoek.assert(string.match(internals.strict.numberRx), "Value must be 0 or a number without a leading zero:", source);
        }
        const value = parseInt(string, 10);
        Hoek.assert(value <= Number.MAX_SAFE_INTEGER, "Value must be positive and less than max safe integer:", source);
        return value;
      }
      static _sub(string, source, options) {
        if (!string) {
          return [];
        }
        if (options.strict) {
          Hoek.assert(string.match(internals.strict.tokenRx), "Value can only contain dot-separated hyphens, digits, a-z or A-Z:", source);
        }
        const subs = [];
        const parts = string.split(".");
        for (const part of parts) {
          if (!part) {
            throw new Error(`Invalid empty ${source} segment`);
          }
          subs.push(part.match(/^\d+$/) ? internals.Version._number(part, source, { strict: options.strict }) : part);
        }
        return subs;
      }
      format() {
        this.version = `${internals.dot(this.major)}.${internals.dot(this.minor)}.${internals.dot(this.patch)}${internals.token(this.prerelease, "-")}${internals.token(this.build, "+")}`;
        this.dots = [this.major, this.minor, this.patch];
        this.wildcard = this.major === internals.any && this.minor === internals.any && this.patch === internals.any && !this.prerelease.length;
      }
      toString() {
        return this.version;
      }
      compare(to, options) {
        return internals.Version.compare(this, to, options);
      }
      static compare(a, b, options = {}) {
        return exports.compare(a, b, options);
      }
    };
    internals.dot = (v) => {
      return v === internals.any ? "x" : v;
    };
    internals.token = (v, prefix) => {
      if (!v.length) {
        return "";
      }
      return `${prefix}${v.join(".")}`;
    };
    internals.Range = class {
      constructor(range, options) {
        this._settings = Object.assign({}, options);
        this._anything = false;
        this._or = [];
        this._active = null;
        if (range !== void 0) {
          this.pattern(range);
        }
        this._another();
      }
      _another() {
        if (!this._active || this._active.rules.length) {
          this._active = { rules: [] };
          this._or.push(this._active);
        }
        return this;
      }
      _rule(operator, version) {
        version = exports.version(version, this._settings);
        const compare = internals.operator(operator);
        this._active.rules.push({ compare, version, operator });
        return this;
      }
      get or() {
        return this._another();
      }
      equal(version) {
        return this._rule("=", version);
      }
      above(version) {
        return this._rule(">", version);
      }
      below(version) {
        return this._rule("<", version);
      }
      between(from, to) {
        this._rule(">=", from);
        this._rule("<=", to);
        return this;
      }
      minor(version) {
        version = exports.version(version, this._settings);
        if (version.major === internals.any) {
          this._rule("=", version);
          return this;
        }
        this._rule(">=", version);
        if (version.minor === internals.any) {
          this._rule("<", { major: version.major + 1, minor: 0, patch: 0 });
        } else {
          this._rule("<", { major: version.major, minor: version.minor + 1, patch: 0 });
        }
        return this;
      }
      compatible(version) {
        version = exports.version(version, this._settings);
        if (version.major === internals.any) {
          this._rule("=", version);
          return this;
        }
        this._rule(">=", version);
        if (version.major === 0 && version.minor !== internals.any) {
          if (version.minor === 0) {
            this._rule("<", { major: 0, minor: 0, patch: version.patch + 1 });
          } else {
            this._rule("<", { major: 0, minor: version.minor + 1, patch: 0 });
          }
        } else {
          this._rule("<", { major: version.major + 1, minor: 0, patch: 0 });
        }
        return this;
      }
      pattern(range) {
        try {
          this._pattern(range);
          return this;
        } catch (err) {
          throw new Error(`Invalid range: "${range}" because: ${err.message}`);
        }
      }
      _pattern(range) {
        if (range === "") {
          this._anything = true;
          return;
        }
        const normalized = internals.normalize(range);
        const ors = normalized.split(/\s*\|\|\s*/);
        for (const condition of ors) {
          if (!condition) {
            this._anything = true;
            return;
          }
          this._another();
          const ands = condition.split(/\s+/);
          for (const and of ands) {
            const hyphen = and.indexOf("@");
            if (hyphen !== -1) {
              const from = and.slice(0, hyphen);
              const to = and.slice(hyphen + 1);
              this.between(from, to);
              continue;
            }
            const parts = and.match(/^(\^|~|<\=|>\=|<|>|\=)?(.+)$/);
            const operator = parts[1];
            const version = exports.version(parts[2], this._settings);
            if (version.wildcard) {
              this._anything = true;
              return;
            }
            if (operator === "~") {
              this.minor(version);
              continue;
            }
            if (operator === "^") {
              this.compatible(version);
              continue;
            }
            if (operator) {
              this._rule(operator, version);
              continue;
            }
            this.equal(version);
          }
        }
      }
      match(version) {
        version = exports.version(version, this._settings);
        if (this._anything) {
          return !version.prerelease.length;
        }
        for (const { rules } of this._or) {
          if (!rules.length) {
            continue;
          }
          let matches = 0;
          let excludes = 0;
          for (const rule of rules) {
            const compare = version.compare(rule.version, Object.assign(this._settings, { range: true }));
            const exclude = Math.abs(compare) === 2;
            if (rule.compare.includes(compare / (exclude ? 2 : 1))) {
              ++matches;
              if (exclude) {
                ++excludes;
              }
            } else {
              break;
            }
          }
          if (matches === rules.length && excludes < matches) {
            return true;
          }
        }
        return false;
      }
      toString() {
        if (this._anything) {
          return "*";
        }
        let string = "";
        for (const { rules } of this._or) {
          if (!rules.length) {
            continue;
          }
          const conditions = [];
          for (const rule of rules) {
            conditions.push(`${rule.operator !== "=" ? rule.operator : ""}${rule.version.version}`);
          }
          string += (string ? "||" : "") + conditions.join(" ");
        }
        return string;
      }
    };
    internals.operator = function(compare) {
      switch (compare) {
        case "=":
          return [0];
        case ">":
          return [1];
        case ">=":
          return [0, 1];
        case "<":
          return [-1];
        case "<=":
          return [0, -1];
      }
    };
    internals.normalize = function(range) {
      return range.replace(/ \- /g, "@").replace(/~>/g, "~").replace(/(\^|~|<\=|>\=|<|>|\=)\s*([^\s]+)/g, ($0, $1, $2) => `${$1}${$2}`);
    };
  }
});

// node_modules/@hapi/teamwork/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/@hapi/teamwork/lib/index.js"(exports) {
    "use strict";
    var internals = {};
    exports.Team = class {
      #meetings = null;
      #count = null;
      #notes = null;
      #done = false;
      #strict = false;
      constructor(options) {
        this._init(options);
      }
      static _notes(instance) {
        return instance.#notes;
      }
      _init(options = {}) {
        this.work = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
        const meetings = options.meetings || 1;
        this.#meetings = meetings;
        this.#count = meetings;
        this.#notes = [];
        this.#done = false;
        this.#strict = options.strict;
      }
      attend(note) {
        if (this.#strict && this.#done) {
          throw new Error("Unscheduled meeting");
        } else if (this.#done) {
          return;
        }
        if (note instanceof Error) {
          this.#done = true;
          this.#notes = null;
          return this._reject(note);
        }
        this.#notes.push(note);
        if (--this.#count) {
          return;
        }
        this.#done = true;
        this._resolve(this.#meetings === 1 ? this.#notes[0] : [...this.#notes]);
        this.#notes = null;
      }
      async regroup(options) {
        await this.work;
        this._init(options);
      }
    };
    exports.Events = class {
      #pending = null;
      #queue = [];
      static isIterator(iterator) {
        return iterator instanceof internals.EventsIterator;
      }
      iterator() {
        return new internals.EventsIterator(this);
      }
      emit(value) {
        this._queue({ value, done: false });
      }
      end() {
        this._queue({ done: true });
      }
      _next() {
        if (this.#queue.length) {
          return Promise.resolve(this.#queue.shift());
        }
        this.#pending = new exports.Team();
        return this.#pending.work;
      }
      _queue(item) {
        if (this.#pending) {
          this.#pending.attend(item);
          this.#pending = null;
        } else {
          this.#queue.push(item);
        }
      }
    };
    internals.EventsIterator = class {
      #events = null;
      constructor(events) {
        this.#events = events;
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      next() {
        return this.#events._next();
      }
    };
  }
});

// node_modules/@hapi/hapi/lib/config.js
var require_config = __commonJS({
  "node_modules/@hapi/hapi/lib/config.js"(exports) {
    "use strict";
    var Os = require("os");
    var Validate = require_lib3();
    var internals = {};
    exports.symbol = Symbol("hapi-response");
    exports.apply = function(type, options, ...message) {
      const result = internals[type].validate(options);
      if (result.error) {
        throw new Error(`Invalid ${type} options ${message.length ? "(" + message.join(" ") + ")" : ""} ${result.error.annotate()}`);
      }
      return result.value;
    };
    exports.enable = function(options) {
      const settings = options ? Object.assign({}, options) : {};
      if (settings.security === true) {
        settings.security = {};
      }
      if (settings.cors === true) {
        settings.cors = {};
      }
      return settings;
    };
    internals.access = Validate.object({
      entity: Validate.valid("user", "app", "any"),
      scope: [false, Validate.array().items(Validate.string()).single().min(1)]
    });
    internals.auth = Validate.alternatives([
      Validate.string(),
      internals.access.keys({
        mode: Validate.valid("required", "optional", "try"),
        strategy: Validate.string(),
        strategies: Validate.array().items(Validate.string()).min(1),
        access: Validate.array().items(internals.access.min(1)).single().min(1),
        payload: [
          Validate.valid("required", "optional"),
          Validate.boolean()
        ]
      }).without("strategy", "strategies").without("access", ["scope", "entity"])
    ]);
    internals.event = Validate.object({
      method: Validate.array().items(Validate.function()).single(),
      options: Validate.object({
        before: Validate.array().items(Validate.string()).single(),
        after: Validate.array().items(Validate.string()).single(),
        bind: Validate.any(),
        sandbox: Validate.valid("server", "plugin"),
        timeout: Validate.number().integer().min(1)
      }).default({})
    });
    internals.exts = Validate.array().items(internals.event.keys({ type: Validate.string().required() })).single();
    internals.failAction = Validate.alternatives([
      Validate.valid("error", "log", "ignore"),
      Validate.function()
    ]).default("error");
    internals.routeBase = Validate.object({
      app: Validate.object().allow(null),
      auth: internals.auth.allow(false),
      bind: Validate.object().allow(null),
      cache: Validate.object({
        expiresIn: Validate.number(),
        expiresAt: Validate.string(),
        privacy: Validate.valid("default", "public", "private"),
        statuses: Validate.array().items(Validate.number().integer().min(200)).min(1).single().default([200, 204]),
        otherwise: Validate.string().default("no-cache")
      }).allow(false).default(),
      compression: Validate.object().pattern(/.+/, Validate.object()).default(),
      cors: Validate.object({
        origin: Validate.array().min(1).allow("ignore").default(["*"]),
        maxAge: Validate.number().default(86400),
        headers: Validate.array().items(Validate.string()).default(["Accept", "Authorization", "Content-Type", "If-None-Match"]),
        additionalHeaders: Validate.array().items(Validate.string()).default([]),
        exposedHeaders: Validate.array().items(Validate.string()).default(["WWW-Authenticate", "Server-Authorization"]),
        additionalExposedHeaders: Validate.array().items(Validate.string()).default([]),
        credentials: Validate.boolean().when("origin", { is: "ignore", then: false }).default(false)
      }).allow(false, true).default(false),
      ext: Validate.object({
        onPreAuth: Validate.array().items(internals.event).single(),
        onCredentials: Validate.array().items(internals.event).single(),
        onPostAuth: Validate.array().items(internals.event).single(),
        onPreHandler: Validate.array().items(internals.event).single(),
        onPostHandler: Validate.array().items(internals.event).single(),
        onPreResponse: Validate.array().items(internals.event).single(),
        onPostResponse: Validate.array().items(internals.event).single()
      }).default({}),
      files: Validate.object({
        relativeTo: Validate.string().pattern(/^([\/\.])|([A-Za-z]:\\)|(\\\\)/).default(".")
      }).default(),
      json: Validate.object({
        replacer: Validate.alternatives(Validate.function(), Validate.array()).allow(null).default(null),
        space: Validate.number().allow(null).default(null),
        suffix: Validate.string().allow(null).default(null),
        escape: Validate.boolean().default(false)
      }).default(),
      jsonp: Validate.string(),
      log: Validate.object({
        collect: Validate.boolean().default(false)
      }).default(),
      payload: Validate.object({
        output: Validate.valid("data", "stream", "file").default("data"),
        parse: Validate.boolean().allow("gunzip").default(true),
        multipart: Validate.object({
          output: Validate.valid("data", "stream", "file", "annotated").required()
        }).default(false).allow(true, false),
        allow: Validate.array().items(Validate.string()).single(),
        override: Validate.string(),
        protoAction: Validate.valid("error", "remove", "ignore").default("error"),
        maxBytes: Validate.number().integer().positive().default(1024 * 1024),
        uploads: Validate.string().default(Os.tmpdir()),
        failAction: internals.failAction,
        timeout: Validate.number().integer().positive().allow(false).default(10 * 1e3),
        defaultContentType: Validate.string().default("application/json"),
        compression: Validate.object().pattern(/.+/, Validate.object()).default()
      }).default(),
      plugins: Validate.object(),
      response: Validate.object({
        disconnectStatusCode: Validate.number().integer().min(400).default(499),
        emptyStatusCode: Validate.valid(200, 204).default(204),
        failAction: internals.failAction,
        modify: Validate.boolean(),
        options: Validate.object(),
        ranges: Validate.boolean().default(true),
        sample: Validate.number().min(0).max(100).when("modify", { then: Validate.forbidden() }),
        schema: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(true, false),
        status: Validate.object().pattern(/\d\d\d/, Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(true, false))
      }).default(),
      security: Validate.object({
        hsts: Validate.alternatives([
          Validate.object({
            maxAge: Validate.number(),
            includeSubdomains: Validate.boolean(),
            includeSubDomains: Validate.boolean(),
            preload: Validate.boolean()
          }),
          Validate.boolean(),
          Validate.number()
        ]).default(15768e3),
        xframe: Validate.alternatives([
          Validate.boolean(),
          Validate.valid("sameorigin", "deny"),
          Validate.object({
            rule: Validate.valid("sameorigin", "deny", "allow-from"),
            source: Validate.string()
          })
        ]).default("deny"),
        xss: Validate.boolean().default(true),
        noOpen: Validate.boolean().default(true),
        noSniff: Validate.boolean().default(true),
        referrer: Validate.alternatives([
          Validate.boolean().valid(false),
          Validate.valid(
            "",
            "no-referrer",
            "no-referrer-when-downgrade",
            "unsafe-url",
            "same-origin",
            "origin",
            "strict-origin",
            "origin-when-cross-origin",
            "strict-origin-when-cross-origin"
          )
        ]).default(false)
      }).allow(null, false, true).default(false),
      state: Validate.object({
        parse: Validate.boolean().default(true),
        failAction: internals.failAction
      }).default(),
      timeout: Validate.object({
        socket: Validate.number().integer().positive().allow(false),
        server: Validate.number().integer().positive().allow(false).default(false)
      }).default(),
      validate: Validate.object({
        headers: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, true),
        params: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, true),
        query: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, false, true),
        payload: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, false, true),
        state: Validate.alternatives(Validate.object(), Validate.array(), Validate.function()).allow(null, false, true),
        failAction: internals.failAction,
        errorFields: Validate.object(),
        options: Validate.object().default(),
        validator: Validate.object()
      }).default()
    });
    internals.server = Validate.object({
      address: Validate.string().hostname(),
      app: Validate.object().allow(null),
      autoListen: Validate.boolean(),
      cache: Validate.allow(null),
      compression: Validate.object({
        minBytes: Validate.number().min(1).integer().default(1024)
      }).allow(false).default(),
      debug: Validate.object({
        request: Validate.array().items(Validate.string()).single().allow(false).default(["implementation"]),
        log: Validate.array().items(Validate.string()).single().allow(false)
      }).allow(false).default(),
      host: Validate.string().hostname().allow(null),
      info: Validate.object({
        remote: Validate.boolean().default(false)
      }).default({}),
      listener: Validate.any(),
      load: Validate.object({
        sampleInterval: Validate.number().integer().min(0).default(0)
      }).unknown().default(),
      mime: Validate.object().empty(null).default(),
      operations: Validate.object({
        cleanStop: Validate.boolean().default(true)
      }).default(),
      plugins: Validate.object(),
      port: Validate.alternatives([
        Validate.number().integer().min(0),
        Validate.string().pattern(/\//),
        Validate.string().pattern(/^\\\\\.\\pipe\\/)
      ]).allow(null),
      query: Validate.object({
        parser: Validate.function()
      }).default(),
      router: Validate.object({
        isCaseSensitive: Validate.boolean().default(true),
        stripTrailingSlash: Validate.boolean().default(false)
      }).default(),
      routes: internals.routeBase.default(),
      state: Validate.object(),
      tls: Validate.alternatives([
        Validate.object().allow(null),
        Validate.boolean()
      ]),
      uri: Validate.string().pattern(/[^/]$/)
    });
    internals.vhost = Validate.alternatives([
      Validate.string().hostname(),
      Validate.array().items(Validate.string().hostname()).min(1)
    ]);
    internals.handler = Validate.alternatives([
      Validate.function(),
      Validate.object().length(1)
    ]);
    internals.route = Validate.object({
      method: Validate.string().pattern(/^[a-zA-Z0-9!#\$%&'\*\+\-\.^_`\|~]+$/).required(),
      path: Validate.string().required(),
      rules: Validate.object(),
      vhost: internals.vhost,
      handler: Validate.any(),
      options: Validate.any(),
      config: Validate.any()
    }).without("config", "options");
    internals.pre = [
      Validate.function(),
      Validate.object({
        method: Validate.alternatives(Validate.string(), Validate.function()).required(),
        assign: Validate.string(),
        mode: Validate.valid("serial", "parallel"),
        failAction: internals.failAction
      })
    ];
    internals.routeConfig = internals.routeBase.keys({
      description: Validate.string(),
      id: Validate.string(),
      isInternal: Validate.boolean(),
      notes: [
        Validate.string(),
        Validate.array().items(Validate.string())
      ],
      pre: Validate.array().items(...internals.pre.concat(Validate.array().items(...internals.pre).min(1))),
      tags: [
        Validate.string(),
        Validate.array().items(Validate.string())
      ]
    });
    internals.cacheConfig = Validate.alternatives([
      Validate.function(),
      Validate.object({
        name: Validate.string().invalid("_default"),
        shared: Validate.boolean(),
        provider: [
          Validate.function(),
          {
            constructor: Validate.function().required(),
            options: Validate.object({
              partition: Validate.string().default("hapi-cache")
            }).unknown().default({})
          }
        ],
        engine: Validate.object()
      }).xor("provider", "engine")
    ]);
    internals.cache = Validate.array().items(internals.cacheConfig).min(1).single();
    internals.cachePolicy = Validate.object({
      cache: Validate.string().allow(null).allow(""),
      segment: Validate.string(),
      shared: Validate.boolean()
    }).unknown();
    internals.method = Validate.object({
      bind: Validate.object().allow(null),
      generateKey: Validate.function(),
      cache: internals.cachePolicy
    });
    internals.methodObject = Validate.object({
      name: Validate.string().required(),
      method: Validate.function().required(),
      options: Validate.object()
    });
    internals.register = Validate.object({
      once: true,
      routes: Validate.object({
        prefix: Validate.string().pattern(/^\/.+/),
        vhost: internals.vhost
      }).default({})
    });
    internals.semver = Validate.string();
    internals.plugin = internals.register.keys({
      options: Validate.any(),
      plugin: Validate.object({
        register: Validate.function().required(),
        name: Validate.string().when("pkg.name", { is: Validate.exist(), otherwise: Validate.required() }),
        version: Validate.string(),
        multiple: Validate.boolean().default(false),
        dependencies: [
          Validate.array().items(Validate.string()).single(),
          Validate.object().pattern(/.+/, internals.semver)
        ],
        once: true,
        requirements: Validate.object({
          hapi: Validate.string(),
          node: Validate.string()
        }).default(),
        pkg: Validate.object({
          name: Validate.string(),
          version: Validate.string().default("0.0.0")
        }).unknown().default({})
      }).unknown()
    }).without("once", "options").unknown();
    internals.rules = Validate.object({
      validate: Validate.object({
        schema: Validate.alternatives(Validate.object(), Validate.array()).required(),
        options: Validate.object().default({ allowUnknown: true })
      })
    });
  }
});

// node_modules/@hapi/call/lib/decode.js
var require_decode = __commonJS({
  "node_modules/@hapi/call/lib/decode.js"(exports) {
    "use strict";
    var internals = {};
    exports.decode = function(string) {
      let percentPos = string.indexOf("%");
      if (percentPos === -1) {
        return string;
      }
      let decoded = "";
      let last = 0;
      let codepoint = 0;
      let startOfOctets = percentPos;
      let state = internals.utf8.accept;
      while (percentPos > -1 && percentPos < string.length) {
        const high = internals.resolveHex(string[percentPos + 1], 4);
        const low = internals.resolveHex(string[percentPos + 2], 0);
        const byte = high | low;
        const type = internals.utf8.data[byte];
        state = internals.utf8.data[256 + state + type];
        codepoint = codepoint << 6 | byte & internals.utf8.data[364 + type];
        if (state === internals.utf8.accept) {
          decoded += string.slice(last, startOfOctets);
          decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
          codepoint = 0;
          last = percentPos + 3;
          percentPos = string.indexOf("%", last);
          startOfOctets = percentPos;
          continue;
        }
        if (state === internals.utf8.reject) {
          return null;
        }
        percentPos += 3;
        if (percentPos >= string.length || string[percentPos] !== "%") {
          return null;
        }
      }
      return decoded + string.slice(last);
    };
    internals.resolveHex = function(char, shift) {
      const i = internals.hex[char];
      return i === void 0 ? 255 : i << shift;
    };
    internals.hex = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      "a": 10,
      "A": 10,
      "b": 11,
      "B": 11,
      "c": 12,
      "C": 12,
      "d": 13,
      "D": 13,
      "e": 14,
      "E": 14,
      "f": 15,
      "F": 15
    };
    internals.utf8 = {
      accept: 12,
      reject: 0,
      data: [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        4,
        4,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        6,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        7,
        8,
        7,
        7,
        10,
        9,
        9,
        9,
        11,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        12,
        0,
        0,
        0,
        0,
        24,
        36,
        48,
        60,
        72,
        84,
        96,
        0,
        12,
        12,
        12,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        24,
        24,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        48,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        127,
        63,
        63,
        63,
        0,
        31,
        15,
        15,
        15,
        7,
        7,
        7
      ]
    };
  }
});

// node_modules/@hapi/call/lib/regex.js
var require_regex = __commonJS({
  "node_modules/@hapi/call/lib/regex.js"(exports) {
    "use strict";
    exports.generate = function() {
      const empty = "(?:^\\/$)";
      const legalChars = "[\\w\\!\\$&'\\(\\)\\*\\+\\,;\\=\\:@\\-\\.~]";
      const encoded = "%[A-F0-9]{2}";
      const literalChar = "(?:" + legalChars + "|" + encoded + ")";
      const literal = literalChar + "+";
      const literalOptional = literalChar + "*";
      const midParam = "(?:\\{\\w+(?:\\*[1-9]\\d*)?\\})";
      const endParam = "(?:\\/(?:\\{\\w+(?:(?:\\*(?:[1-9]\\d*)?)|(?:\\?))?\\})?)?";
      const partialParam = "(?:\\{\\w+\\??\\})";
      const mixedParam = "(?:(?:" + literal + partialParam + ")+" + literalOptional + ")|(?:" + partialParam + "(?:" + literal + partialParam + ")+" + literalOptional + ")|(?:" + partialParam + literal + ")";
      const segmentContent = "(?:" + literal + "|" + midParam + "|" + mixedParam + ")";
      const segment = "\\/" + segmentContent;
      const segments = "(?:" + segment + ")*";
      const path = "(?:^" + segments + endParam + "$)";
      const parseParam = "(" + literal + ")|(?:\\{(\\w+)(?:(\\*)(\\d+)?)?(\\?)?\\})";
      const expressions = {
        parseParam: new RegExp(parseParam, "g"),
        validatePath: new RegExp(empty + "|" + path),
        validatePathEncoded: /%(?:2[146-9A-E]|3[\dABD]|4[\dA-F]|5[\dAF]|6[1-9A-F]|7[\dAE])/g
      };
      return expressions;
    };
  }
});

// node_modules/@hapi/call/lib/segment.js
var require_segment = __commonJS({
  "node_modules/@hapi/call/lib/segment.js"(exports, module2) {
    "use strict";
    var Hoek = require_lib();
    var internals = {};
    exports = module2.exports = internals.Segment = function() {
      this._edge = null;
      this._fulls = null;
      this._literals = null;
      this._param = null;
      this._mixed = null;
      this._wildcard = null;
    };
    internals.Segment.prototype.add = function(segments, record) {
      const current = segments[0];
      const remaining = segments.slice(1);
      const isEdge = !remaining.length;
      const literals = [];
      let isLiteral = true;
      for (let i = 0; i < segments.length && isLiteral; ++i) {
        isLiteral = segments[i].literal !== void 0;
        literals.push(segments[i].literal);
      }
      if (isLiteral) {
        this._fulls = this._fulls || /* @__PURE__ */ new Map();
        let literal = "/" + literals.join("/");
        if (!record.settings.isCaseSensitive) {
          literal = literal.toLowerCase();
        }
        Hoek.assert(!this._fulls.has(literal), "New route", record.path, "conflicts with existing", this._fulls.has(literal) && this._fulls.get(literal).record.path);
        this._fulls.set(literal, { segment: current, record });
      } else if (current.literal !== void 0) {
        this._literals = this._literals || /* @__PURE__ */ new Map();
        const currentLiteral = record.settings.isCaseSensitive ? current.literal : current.literal.toLowerCase();
        if (!this._literals.has(currentLiteral)) {
          this._literals.set(currentLiteral, new internals.Segment());
        }
        this._literals.get(currentLiteral).add(remaining, record);
      } else if (current.wildcard) {
        Hoek.assert(!this._wildcard, "New route", record.path, "conflicts with existing", this._wildcard && this._wildcard.record.path);
        Hoek.assert(!this._param || !this._param._wildcard, "New route", record.path, "conflicts with existing", this._param && this._param._wildcard && this._param._wildcard.record.path);
        this._wildcard = { segment: current, record };
      } else if (current.mixed) {
        this._mixed = this._mixed || [];
        let mixed = this._mixedLookup(current);
        if (!mixed) {
          mixed = { segment: current, node: new internals.Segment() };
          this._mixed.push(mixed);
          this._mixed.sort(internals.mixed);
        }
        if (isEdge) {
          Hoek.assert(!mixed.node._edge, "New route", record.path, "conflicts with existing", mixed.node._edge && mixed.node._edge.record.path);
          mixed.node._edge = { segment: current, record };
        } else {
          mixed.node.add(remaining, record);
        }
      } else {
        this._param = this._param || new internals.Segment();
        if (isEdge) {
          Hoek.assert(!this._param._edge, "New route", record.path, "conflicts with existing", this._param._edge && this._param._edge.record.path);
          this._param._edge = { segment: current, record };
        } else {
          Hoek.assert(!this._wildcard || !remaining[0].wildcard, "New route", record.path, "conflicts with existing", this._wildcard && this._wildcard.record.path);
          this._param.add(remaining, record);
        }
      }
    };
    internals.Segment.prototype._mixedLookup = function(segment) {
      for (let i = 0; i < this._mixed.length; ++i) {
        if (internals.mixed({ segment }, this._mixed[i]) === 0) {
          return this._mixed[i];
        }
      }
      return null;
    };
    internals.mixed = function(a, b) {
      const aFirst = -1;
      const bFirst = 1;
      const as = a.segment;
      const bs = b.segment;
      if (as.length !== bs.length) {
        return as.length > bs.length ? aFirst : bFirst;
      }
      if (as.first !== bs.first) {
        return as.first ? bFirst : aFirst;
      }
      for (let i = 0; i < as.segments.length; ++i) {
        const am = as.segments[i];
        const bm = bs.segments[i];
        if (am === bm) {
          continue;
        }
        if (am.length === bm.length) {
          return am > bm ? bFirst : aFirst;
        }
        return am.length < bm.length ? bFirst : aFirst;
      }
      return 0;
    };
    internals.Segment.prototype.lookup = function(path, segments, options) {
      let match = null;
      if (this._fulls) {
        match = this._fulls.get(options.isCaseSensitive ? path : path.toLowerCase());
        if (match) {
          return { record: match.record, array: [] };
        }
      }
      const current = segments[0];
      const nextPath = path.slice(current.length + 1);
      const remainder = segments.length > 1 ? segments.slice(1) : null;
      if (this._literals) {
        const literal = options.isCaseSensitive ? current : current.toLowerCase();
        match = this._literals.get(literal);
        if (match) {
          const record = internals.deeper(match, nextPath, remainder, [], options);
          if (record) {
            return record;
          }
        }
      }
      if (this._mixed) {
        for (let i = 0; i < this._mixed.length; ++i) {
          match = this._mixed[i];
          const params = current.match(match.segment.mixed);
          if (params) {
            const array = [];
            for (let j = 1; j < params.length; ++j) {
              array.push(params[j]);
            }
            const record = internals.deeper(match.node, nextPath, remainder, array, options);
            if (record) {
              return record;
            }
          }
        }
      }
      if (this._param) {
        if (current || this._param._edge && this._param._edge.segment.empty) {
          const record = internals.deeper(this._param, nextPath, remainder, [current], options);
          if (record) {
            return record;
          }
        }
      }
      if (this._wildcard) {
        return { record: this._wildcard.record, array: [path.slice(1)] };
      }
      return null;
    };
    internals.deeper = function(match, path, segments, array, options) {
      if (!segments) {
        if (match._edge) {
          return { record: match._edge.record, array };
        }
        if (match._wildcard) {
          return { record: match._wildcard.record, array };
        }
      } else {
        const result = match.lookup(path, segments, options);
        if (result) {
          return { record: result.record, array: array.concat(result.array) };
        }
      }
      return null;
    };
  }
});

// node_modules/@hapi/call/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/@hapi/call/lib/index.js"(exports) {
    "use strict";
    var Boom = require_lib5();
    var Hoek = require_lib();
    var Decode = require_decode();
    var Regex = require_regex();
    var Segment = require_segment();
    var internals = {
      pathRegex: Regex.generate(),
      defaults: {
        isCaseSensitive: true
      }
    };
    exports.Router = internals.Router = function(options) {
      this.settings = Hoek.applyToDefaults(internals.defaults, options || {});
      this.routes = /* @__PURE__ */ new Map();
      this.ids = /* @__PURE__ */ new Map();
      this.vhosts = null;
      this.specials = {
        badRequest: null,
        notFound: null,
        options: null
      };
    };
    internals.Router.prototype.add = function(config, route) {
      const method = config.method.toLowerCase();
      const vhost = config.vhost || "*";
      if (vhost !== "*") {
        this.vhosts = this.vhosts || /* @__PURE__ */ new Map();
        if (!this.vhosts.has(vhost)) {
          this.vhosts.set(vhost, /* @__PURE__ */ new Map());
        }
      }
      const table = vhost === "*" ? this.routes : this.vhosts.get(vhost);
      if (!table.has(method)) {
        table.set(method, { routes: [], router: new Segment() });
      }
      const analysis = config.analysis || this.analyze(config.path);
      const record = {
        path: config.path,
        route: route || config.path,
        segments: analysis.segments,
        params: analysis.params,
        fingerprint: analysis.fingerprint,
        settings: this.settings
      };
      const map = table.get(method);
      map.router.add(analysis.segments, record);
      map.routes.push(record);
      map.routes.sort(internals.sort);
      const last = record.segments[record.segments.length - 1];
      if (last.empty) {
        map.router.add(analysis.segments.slice(0, -1), record);
      }
      if (config.id) {
        Hoek.assert(!this.ids.has(config.id), "Route id", config.id, "for path", config.path, "conflicts with existing path", this.ids.has(config.id) && this.ids.get(config.id).path);
        this.ids.set(config.id, record);
      }
      return record;
    };
    internals.Router.prototype.special = function(type, route) {
      Hoek.assert(Object.keys(this.specials).indexOf(type) !== -1, "Unknown special route type:", type);
      this.specials[type] = { route };
    };
    internals.Router.prototype.route = function(method, path, hostname) {
      const segments = path.length === 1 ? [""] : path.split("/").slice(1);
      const vhost = this.vhosts && hostname && this.vhosts.get(hostname);
      const route = vhost && this._lookup(path, segments, vhost, method) || this._lookup(path, segments, this.routes, method) || method === "head" && vhost && this._lookup(path, segments, vhost, "get") || method === "head" && this._lookup(path, segments, this.routes, "get") || method === "options" && this.specials.options || vhost && this._lookup(path, segments, vhost, "*") || this._lookup(path, segments, this.routes, "*") || this.specials.notFound || Boom.notFound();
      return route;
    };
    internals.Router.prototype._lookup = function(path, segments, table, method) {
      const set = table.get(method);
      if (!set) {
        return null;
      }
      const match = set.router.lookup(path, segments, this.settings);
      if (!match) {
        return null;
      }
      const assignments = {};
      const array = [];
      for (let i = 0; i < match.array.length; ++i) {
        const name = match.record.params[i];
        const value = Decode.decode(match.array[i]);
        if (value === null) {
          return this.specials.badRequest || Boom.badRequest("Invalid request path");
        }
        if (assignments[name] !== void 0) {
          assignments[name] = assignments[name] + "/" + value;
        } else {
          assignments[name] = value;
        }
        if (i + 1 === match.array.length || name !== match.record.params[i + 1]) {
          array.push(assignments[name]);
        }
      }
      return { params: assignments, paramsArray: array, route: match.record.route };
    };
    internals.Router.prototype.normalize = function(path) {
      if (path && path.indexOf("%") !== -1) {
        const uppercase = path.replace(/%[0-9a-fA-F][0-9a-fA-F]/g, (encoded) => encoded.toUpperCase());
        const decoded = uppercase.replace(/%(?:2[146-9A-E]|3[\dABD]|4[\dA-F]|5[\dAF]|6[1-9A-F]|7[\dAE])/g, (encoded) => String.fromCharCode(parseInt(encoded.substring(1), 16)));
        path = decoded;
      }
      if (path && (path.indexOf("/.") !== -1 || path[0] === ".")) {
        const hasLeadingSlash = path[0] === "/";
        const segments = path.split("/");
        const normalized = [];
        let segment;
        for (let i = 0; i < segments.length; ++i) {
          segment = segments[i];
          if (segment === "..") {
            normalized.pop();
          } else if (segment !== ".") {
            normalized.push(segment);
          }
        }
        if (segment === "." || segment === "..") {
          normalized.push("");
        }
        path = normalized.join("/");
        if (path[0] !== "/" && hasLeadingSlash) {
          path = "/" + path;
        }
      }
      return path;
    };
    internals.Router.prototype.analyze = function(path) {
      Hoek.assert(internals.pathRegex.validatePath.test(path), "Invalid path:", path);
      Hoek.assert(!internals.pathRegex.validatePathEncoded.test(path), "Path cannot contain encoded non-reserved path characters:", path);
      const pathParts = path.split("/");
      const segments = [];
      const params = [];
      const fingers = [];
      for (let i = 1; i < pathParts.length; ++i) {
        let segment = pathParts[i];
        if (segment.indexOf("{") === -1) {
          segment = this.settings.isCaseSensitive ? segment : segment.toLowerCase();
          fingers.push(segment);
          segments.push({ literal: segment });
          continue;
        }
        const parts = internals.parseParams(segment);
        if (parts.length === 1) {
          const item = parts[0];
          Hoek.assert(params.indexOf(item.name) === -1, "Cannot repeat the same parameter name:", item.name, "in:", path);
          params.push(item.name);
          if (item.wildcard) {
            if (item.count) {
              for (let j = 0; j < item.count; ++j) {
                fingers.push("?");
                segments.push({});
                if (j) {
                  params.push(item.name);
                }
              }
            } else {
              fingers.push("#");
              segments.push({ wildcard: true });
            }
          } else {
            fingers.push("?");
            segments.push({ empty: item.empty });
          }
        } else {
          const seg = {
            length: parts.length,
            first: typeof parts[0] !== "string",
            segments: []
          };
          let finger = "";
          let regex = "^";
          for (let j = 0; j < parts.length; ++j) {
            const part = parts[j];
            if (typeof part === "string") {
              finger = finger + part;
              regex = regex + Hoek.escapeRegex(part);
              seg.segments.push(part);
            } else {
              Hoek.assert(params.indexOf(part.name) === -1, "Cannot repeat the same parameter name:", part.name, "in:", path);
              params.push(part.name);
              finger = finger + "?";
              regex = regex + "(." + (part.empty ? "*" : "+") + ")";
            }
          }
          seg.mixed = new RegExp(regex + "$", !this.settings.isCaseSensitive ? "i" : "");
          fingers.push(finger);
          segments.push(seg);
        }
      }
      return {
        segments,
        fingerprint: "/" + fingers.join("/"),
        params
      };
    };
    internals.parseParams = function(segment) {
      const parts = [];
      segment.replace(internals.pathRegex.parseParam, ($0, literal, name, wildcard, count, empty) => {
        if (literal) {
          parts.push(literal);
        } else {
          parts.push({
            name,
            wildcard: !!wildcard,
            count: count && parseInt(count, 10),
            empty: !!empty
          });
        }
        return "";
      });
      return parts;
    };
    internals.Router.prototype.table = function(host) {
      const result = [];
      const collect = (table) => {
        if (!table) {
          return;
        }
        for (const map of table.values()) {
          for (const record of map.routes) {
            result.push(record.route);
          }
        }
      };
      if (this.vhosts) {
        const vhosts = host ? [].concat(host) : [...this.vhosts.keys()];
        for (const vhost of vhosts) {
          collect(this.vhosts.get(vhost));
        }
      }
      collect(this.routes);
      return result;
    };
    internals.sort = function(a, b) {
      const aFirst = -1;
      const bFirst = 1;
      const as = a.segments;
      const bs = b.segments;
      if (as.length !== bs.length) {
        return as.length > bs.length ? bFirst : aFirst;
      }
      for (let i = 0; ; ++i) {
        if (as[i].literal) {
          if (bs[i].literal) {
            if (as[i].literal === bs[i].literal) {
              continue;
            }
            return as[i].literal > bs[i].literal ? bFirst : aFirst;
          }
          return aFirst;
        }
        if (bs[i].literal) {
          return bFirst;
        }
        return as[i].wildcard ? bFirst : aFirst;
      }
    };
  }
});

// node_modules/@hapi/catbox/lib/client.js
var require_client = __commonJS({
  "node_modules/@hapi/catbox/lib/client.js"(exports, module2) {
    "use strict";
    var Hoek = require_lib();
    var Boom = require_lib5();
    var internals = {
      validate: Symbol("validate")
    };
    internals.defaults = {
      partition: "catbox"
    };
    module2.exports = class {
      constructor(engine, options) {
        Hoek.assert(engine, "Missing catbox client engine");
        Hoek.assert(typeof engine === "object" || typeof engine === "function", "engine must be an engine object or engine prototype (function)");
        Hoek.assert(typeof engine === "function" || !options, "Can only specify options with function engine config");
        const settings = Object.assign({}, internals.defaults, options);
        Hoek.assert(settings.partition.match(/^[\w\-]+$/), "Invalid partition name:" + settings.partition);
        this.connection = typeof engine === "object" ? engine : new engine(settings);
      }
      async start() {
        await this.connection.start();
      }
      async stop() {
        await this.connection.stop();
      }
      isReady() {
        return this.connection.isReady();
      }
      validateSegmentName(name) {
        return this.connection.validateSegmentName(name);
      }
      async get(key) {
        this[internals.validate](key, null);
        if (key === null) {
          return null;
        }
        const result = await this.connection.get(key);
        if (!result || result.item === void 0 || result.item === null) {
          return null;
        }
        const now = Date.now();
        const expires = result.stored + result.ttl;
        const ttl = expires - now;
        if (ttl <= 0) {
          return null;
        }
        const cached = {
          item: result.item,
          stored: result.stored,
          ttl
        };
        return cached;
      }
      async set(key, value, ttl) {
        this[internals.validate](key);
        if (ttl <= 0) {
          return;
        }
        await this.connection.set(key, value, ttl);
      }
      async drop(key) {
        this[internals.validate](key);
        await this.connection.drop(key);
      }
      [internals.validate](key, allow = {}) {
        if (!this.isReady()) {
          throw Boom.internal("Disconnected");
        }
        const isValidKey = key && typeof key.id === "string" && key.segment && typeof key.segment === "string";
        if (!isValidKey && key !== allow) {
          throw Boom.internal("Invalid key");
        }
      }
    };
  }
});

// node_modules/@hapi/podium/lib/index.js
var require_lib10 = __commonJS({
  "node_modules/@hapi/podium/lib/index.js"(exports, module2) {
    "use strict";
    var Hoek = require_lib();
    var Teamwork = require_lib8();
    var Validate = require_lib3();
    var internals = {
      schema: {
        base: Validate.object({
          name: Validate.string().required(),
          clone: Validate.boolean(),
          tags: Validate.boolean(),
          spread: Validate.boolean(),
          channels: Validate.array().items(Validate.string()).single().unique().min(1)
        })
      }
    };
    internals.schema.event = internals.schema.base.keys({
      shared: Validate.boolean()
    });
    internals.schema.listener = internals.schema.event.keys({
      listener: Validate.func().required(),
      context: Validate.object(),
      count: Validate.number().integer().min(1),
      filter: {
        tags: Validate.array().items(Validate.string()).single().unique().min(1).required(),
        all: Validate.boolean()
      }
    });
    exports = module2.exports = internals.Podium = class {
      constructor(events, options) {
        this._eventListeners = /* @__PURE__ */ new Map();
        this._notificationsQueue = [];
        this._eventsProcessing = false;
        this._sourcePodiums = [];
        if (events) {
          this.registerEvent(events, options);
        }
      }
      static decorate(target, source) {
        internals.Podium.constructor.call(target);
        for (const name of source._eventListeners.keys()) {
          target._eventListeners.set(name, {
            handlers: null,
            flags: source._eventListeners.get(name).flags
          });
        }
      }
      static validate(events) {
        const normalized = [];
        events = [].concat(events);
        for (let event of events) {
          if (typeof event === "string") {
            event = { name: event };
          }
          normalized.push(Validate.attempt(event, internals.schema.event, "Invalid event options"));
        }
        return normalized;
      }
      registerEvent(events, options = {}) {
        events = Hoek.flatten([].concat(events));
        for (let event of events) {
          if (!event) {
            continue;
          }
          if (event instanceof internals.Podium) {
            this.registerPodium(event);
            continue;
          }
          if (typeof event === "string") {
            event = { name: event };
          }
          if (options.validate !== false) {
            event = Validate.attempt(event, internals.schema.event, "Invalid event options");
          }
          const name = event.name;
          if (this._eventListeners.has(name)) {
            Hoek.assert(event.shared, `Event ${name} exists`);
            continue;
          }
          this._eventListeners.set(name, { handlers: null, flags: event });
          for (const podium of this._sourcePodiums) {
            if (!podium._eventListeners.has(name)) {
              podium._eventListeners.set(name, { handlers: null, flags: event });
            }
          }
        }
      }
      registerPodium(podiums) {
        podiums = [].concat(podiums);
        for (const podium of podiums) {
          if (podium._sourcePodiums.indexOf(this) !== -1) {
            continue;
          }
          podium._sourcePodiums.push(this);
          for (const name of podium._eventListeners.keys()) {
            if (!this._eventListeners.has(name)) {
              this._eventListeners.set(name, { handlers: null, flags: podium._eventListeners.get(name).flags });
            }
          }
        }
      }
      async emit(criteria, data, _generated) {
        criteria = internals.criteria(criteria);
        const name = criteria.name;
        Hoek.assert(name, "Criteria missing event name");
        const event = this._eventListeners.get(name);
        Hoek.assert(event, `Unknown event ${name}`);
        if (!event.handlers && !this._sourcePodiums.length) {
          return;
        }
        Hoek.assert(!criteria.channel || typeof criteria.channel === "string", "Invalid channel name");
        Hoek.assert(!criteria.channel || !event.flags.channels || event.flags.channels.indexOf(criteria.channel) !== -1, `Unknown ${criteria.channel} channel`);
        Hoek.assert(!event.flags.spread || Array.isArray(data) || typeof data === "function", "Data must be an array for spread event");
        if (typeof criteria.tags === "string") {
          Object.assign({}, criteria);
          criteria.tags = { [criteria.tags]: true };
        }
        if (criteria.tags && Array.isArray(criteria.tags)) {
          const tags = {};
          for (const tag of criteria.tags) {
            tags[tag] = true;
          }
          Object.assign({}, criteria);
          criteria.tags = tags;
        }
        if (event.handlers) {
          const processing = [];
          const handlers = event.handlers.slice();
          for (const handler2 of handlers) {
            if (handler2.channels && (!criteria.channel || handler2.channels.indexOf(criteria.channel) === -1)) {
              continue;
            }
            if (handler2.filter) {
              if (!criteria.tags) {
                continue;
              }
              const match = Hoek.intersect(criteria.tags, handler2.filter.tags, { first: !handler2.filter.all });
              if (!match || handler2.filter.all && match.length !== handler2.filter.tags.length) {
                continue;
              }
            }
            if (handler2.count) {
              --handler2.count;
              if (handler2.count < 1) {
                internals.removeHandler(this, criteria.name, handler2);
              }
            }
            if (!_generated && typeof data === "function") {
              data = data();
              _generated = true;
            }
            const update = internals.flag("clone", handler2, event) ? Hoek.clone(data) : data;
            const args = internals.flag("spread", handler2, event) && Array.isArray(update) ? update.slice(0) : [update];
            if (internals.flag("tags", handler2, event) && criteria.tags) {
              args.push(criteria.tags);
            }
            try {
              const result = handler2.context ? handler2.listener.apply(handler2.context, args) : handler2.listener(...args);
              if (result && typeof result.then === "function") {
                processing.push(result);
              }
            } catch (err) {
              processing.push(Promise.reject(err));
            }
          }
          if (processing.length) {
            await Promise.all(processing);
          }
        }
        if (this._sourcePodiums.length) {
          const podiums = this._sourcePodiums.slice();
          await Promise.all(podiums.map((podium) => podium.emit(criteria, data, _generated)));
        }
      }
      on(criteria, listener, context) {
        criteria = Object.assign({}, internals.criteria(criteria));
        criteria.listener = listener;
        criteria.context = context;
        if (criteria.filter && (typeof criteria.filter === "string" || Array.isArray(criteria.filter))) {
          criteria.filter = { tags: criteria.filter };
        }
        criteria = Validate.attempt(criteria, internals.schema.listener, "Invalid event listener options");
        const name = criteria.name;
        const event = this._eventListeners.get(name);
        Hoek.assert(event, `Unknown event ${name}`);
        Hoek.assert(!criteria.channels || !event.flags.channels || Hoek.intersect(event.flags.channels, criteria.channels).length === criteria.channels.length, `Unknown event channels ${criteria.channels && criteria.channels.join(", ")}`);
        event.handlers = event.handlers || [];
        event.handlers.push(criteria);
        return this;
      }
      addListener(criteria, listener, context) {
        return this.on(criteria, listener, context);
      }
      once(criteria, listener, context) {
        criteria = Object.assign({}, internals.criteria(criteria), { count: 1 });
        if (listener) {
          return this.on(criteria, listener, context);
        }
        const team = new Teamwork.Team();
        this.on(criteria, (...args) => team.attend(args));
        return team.work;
      }
      few(criteria, context) {
        Hoek.assert(typeof criteria === "object", "Criteria must be an object");
        Hoek.assert(criteria.count, "Criteria must include a count limit");
        const team = new Teamwork.Team({ meetings: criteria.count });
        this.on(criteria, (...args) => team.attend(args), context);
        return team.work;
      }
      removeListener(name, listener) {
        Hoek.assert(this._eventListeners.has(name), `Unknown event ${name}`);
        Hoek.assert(typeof listener === "function", "Listener must be a function");
        const event = this._eventListeners.get(name);
        const handlers = event.handlers;
        if (!handlers) {
          return this;
        }
        const filtered = handlers.filter((handler2) => handler2.listener !== listener);
        event.handlers = filtered.length ? filtered : null;
        return this;
      }
      removeAllListeners(name) {
        Hoek.assert(this._eventListeners.has(name), `Unknown event ${name}`);
        this._eventListeners.get(name).handlers = null;
        return this;
      }
      hasListeners(name) {
        Hoek.assert(this._eventListeners.has(name), `Unknown event ${name}`);
        return !!this._eventListeners.get(name).handlers;
      }
    };
    internals.removeHandler = function(emitter, name, handler2) {
      const event = emitter._eventListeners.get(name);
      const handlers = event.handlers;
      const filtered = handlers.filter((item) => item !== handler2);
      event.handlers = filtered.length ? filtered : null;
    };
    internals.criteria = function(criteria) {
      if (typeof criteria === "string") {
        return { name: criteria };
      }
      return criteria;
    };
    internals.flag = function(name, handler2, event) {
      return (handler2[name] !== void 0 ? handler2[name] : event.flags[name]) || false;
    };
  }
});

// node_modules/@hapi/catbox/lib/pending.js
var require_pending = __commonJS({
  "node_modules/@hapi/catbox/lib/pending.js"(exports, module2) {
    "use strict";
    exports = module2.exports = class {
      id = null;
      timeout = null;
      count = 1;
      rule = null;
      resolve = null;
      reject = null;
      constructor(id, rule) {
        this.id = id;
        this.rule = rule;
        this.promise = new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
        });
      }
      join() {
        ++this.count;
        return this.promise;
      }
      send(err, value, cached, report) {
        clearTimeout(this.timeout);
        if (err && !cached) {
          this.reject(err);
          return;
        }
        if (!this.rule.getDecoratedValue) {
          this.resolve(value);
          return;
        }
        if (err) {
          report.error = err;
        }
        this.resolve({ value, cached, report });
      }
      setTimeout(fn, timeoutMs) {
        clearTimeout(this.timeout);
        this.timeout = setTimeout(fn, timeoutMs);
      }
    };
  }
});

// node_modules/@hapi/catbox/lib/policy.js
var require_policy = __commonJS({
  "node_modules/@hapi/catbox/lib/policy.js"(exports, module2) {
    "use strict";
    var Boom = require_lib5();
    var Hoek = require_lib();
    var Podium = require_lib10();
    var Validate = require_lib3();
    var Pending = require_pending();
    var internals = {
      day: 24 * 60 * 60 * 1e3,
      events: Podium.validate([
        { name: "error", channels: ["generate", "persist"] }
      ])
    };
    internals.schema = Validate.object({
      expiresIn: Validate.number().integer().min(1),
      expiresAt: Validate.string().regex(/^\d\d?\:\d\d$/),
      staleIn: [
        Validate.number().integer().min(1).when("expiresAt", { is: Validate.required(), then: Validate.number().max(864e5 - 1) }),
        Validate.func()
      ],
      staleTimeout: Validate.number().integer().min(1),
      generateFunc: Validate.func(),
      generateTimeout: Validate.number().integer().min(1).allow(false),
      generateOnReadError: Validate.boolean(),
      generateIgnoreWriteError: Validate.boolean(),
      dropOnError: Validate.boolean(),
      pendingGenerateTimeout: Validate.number().integer().min(1),
      getDecoratedValue: Validate.boolean().default(false),
      privacy: Validate.any(),
      cache: Validate.any(),
      segment: Validate.any(),
      shared: Validate.any()
    }).without("expiresIn", "expiresAt").with("staleIn", "generateFunc").with("generateOnReadError", "generateFunc").with("generateIgnoreWriteError", "generateFunc").with("dropOnError", "generateFunc").and("generateFunc", "generateTimeout").and("staleIn", "staleTimeout");
    exports = module2.exports = internals.Policy = class {
      rule = null;
      stats = {
        sets: 0,
        gets: 0,
        hits: 0,
        stales: 0,
        generates: 0,
        errors: 0
      };
      _events = null;
      _cache = null;
      _segment = null;
      _pendings = /* @__PURE__ */ new Map();
      _pendingGenerateCall = /* @__PURE__ */ new Map();
      constructor(options, cache, segment) {
        this._cache = cache;
        this.rules(options);
        if (cache) {
          const nameErr = cache.validateSegmentName(segment);
          Hoek.assert(nameErr === null, "Invalid segment name: " + segment + (nameErr ? " (" + nameErr.message + ")" : ""));
          this._segment = segment;
        }
      }
      get client() {
        return this._cache;
      }
      get events() {
        if (!this._events) {
          this._events = new Podium(internals.events);
        }
        return this._events;
      }
      _error(source, error) {
        if (!this._events) {
          return;
        }
        this._events.emit({ name: "error", channel: source }, { source, error });
      }
      rules(options) {
        this.rule = internals.Policy.compile(options, !!this._cache);
      }
      async get(key) {
        ++this.stats.gets;
        if (!key || typeof key === "string") {
          key = { id: key, string: true };
        }
        let pending = this._pendings.get(key.id);
        if (pending !== void 0) {
          return pending.join();
        }
        pending = new Pending(key.id, this.rule);
        this._pendings.set(key.id, pending);
        try {
          await this._get(pending, key);
        } catch (err) {
          this._send(key, err);
        }
        return pending.promise;
      }
      async _get(pending, key) {
        const report = {};
        const timer = new Hoek.Bench();
        if (this._cache) {
          try {
            var cached = await this._cache.get({ segment: this._segment, id: key.id });
          } catch (err) {
            report.error = err;
            ++this.stats.errors;
            this._error("persist", err);
          }
        }
        report.msec = timer.elapsed();
        if (cached) {
          report.stored = cached.stored;
          report.ttl = cached.ttl;
          const staleIn = typeof this.rule.staleIn === "function" ? this.rule.staleIn(cached.stored, cached.ttl) : this.rule.staleIn;
          cached.isStale = staleIn ? Date.now() - cached.stored >= staleIn : false;
          report.isStale = cached.isStale;
          if (cached.isStale) {
            ++this.stats.stales;
          }
        }
        if (!this.rule.generateFunc || report.error && !this.rule.generateOnReadError) {
          this._send(key, report.error, cached ? cached.item : null, cached, report);
          return;
        }
        if (cached && !cached.isStale) {
          this._send(key, null, cached.item, cached, report);
          return;
        }
        return Promise.race([
          pending.promise,
          this._generate(pending, key, cached, report)
        ]);
      }
      _generate(pending, key, cached, report) {
        if (cached) {
          cached.ttl = cached.ttl - this.rule.staleTimeout;
        }
        if (cached && cached.ttl > 0) {
          pending.setTimeout(() => this._send(key, null, cached.item, cached, report), this.rule.staleTimeout);
        } else if (this.rule.generateTimeout) {
          pending.setTimeout(() => this._send(key, Boom.serverUnavailable(), null, null, report), this.rule.generateTimeout);
        }
        if (this._pendingGenerateCall.has(key.id)) {
          return;
        }
        ++this.stats.generates;
        if (this.rule.pendingGenerateTimeout) {
          const timeout = setTimeout(() => this._pendingGenerateCall.delete(key.id), this.rule.pendingGenerateTimeout);
          this._pendingGenerateCall.set(key.id, timeout);
        }
        return this._callGenerateFunc(key, cached, report);
      }
      async _callGenerateFunc(key, cached, report) {
        const flags = {};
        try {
          var value = await this.rule.generateFunc(key.string ? key.id : key, flags);
        } catch (err) {
          var generateError = err;
          this._error("generate", err);
        }
        const pendingTimeout = this._pendingGenerateCall.get(key.id);
        if (pendingTimeout) {
          clearTimeout(pendingTimeout);
          this._pendingGenerateCall.delete(key.id);
        }
        try {
          if (flags.ttl === 0 || generateError && this.rule.dropOnError) {
            await this.drop(key.id);
          } else if (!generateError) {
            await this.set(key.id, value, flags.ttl);
          }
        } catch (err) {
          var persistError = err;
          this._error("persist", err);
        }
        const error = generateError || (this.rule.generateIgnoreWriteError ? null : persistError);
        if (cached && error && !this.rule.dropOnError) {
          this._send(key, error, cached.item, cached, report);
          return;
        }
        this._send(key, error, value, null, report);
      }
      _send(key, err, value, cached, report) {
        const pending = this._pendings.get(key.id);
        if (!pending) {
          return;
        }
        this._pendings.delete(key.id);
        pending.send(err, value, cached, report);
        if (report && report.isStale !== void 0) {
          this.stats.hits = this.stats.hits + pending.count;
        }
      }
      async set(key, value, ttl) {
        ++this.stats.sets;
        if (!this._cache) {
          return;
        }
        try {
          await this._cache.set({ segment: this._segment, id: internals.id(key) }, value, ttl || internals.Policy.ttl(this.rule));
        } catch (err) {
          ++this.stats.errors;
          throw err;
        }
      }
      async drop(key) {
        if (!this._cache) {
          return;
        }
        try {
          await this._cache.drop({ segment: this._segment, id: internals.id(key) });
          return;
        } catch (err) {
          ++this.stats.errors;
          throw err;
        }
      }
      ttl(created) {
        return internals.Policy.ttl(this.rule, created);
      }
      isReady() {
        if (!this._cache) {
          return false;
        }
        return this._cache.connection.isReady();
      }
      static compile(options, serverSide) {
        const rule = {};
        if (!options || !Object.keys(options).length) {
          return rule;
        }
        options = Validate.attempt(options, internals.schema, "Invalid cache policy configuration");
        const hasExpiresIn = options.expiresIn !== void 0 && options.expiresIn !== null;
        const hasExpiresAt = options.expiresAt !== void 0 && options.expiresAt !== null;
        Hoek.assert(!hasExpiresIn || !options.staleIn || typeof options.staleIn === "function" || options.staleIn < options.expiresIn, "staleIn must be less than expiresIn");
        Hoek.assert(!options.staleIn || serverSide, "Cannot use stale options without server-side caching");
        Hoek.assert(!options.staleTimeout || !hasExpiresIn || options.staleTimeout < options.expiresIn, "staleTimeout must be less than expiresIn");
        Hoek.assert(!options.staleTimeout || !hasExpiresIn || typeof options.staleIn === "function" || options.staleTimeout < options.expiresIn - options.staleIn, "staleTimeout must be less than the delta between expiresIn and staleIn");
        Hoek.assert(!options.staleTimeout || !options.pendingGenerateTimeout || options.staleTimeout < options.pendingGenerateTimeout, "pendingGenerateTimeout must be greater than staleTimeout if specified");
        if (hasExpiresAt) {
          const time = /^(\d\d?):(\d\d)$/.exec(options.expiresAt);
          rule.expiresAt = {
            hours: parseInt(time[1], 10),
            minutes: parseInt(time[2], 10)
          };
        } else {
          rule.expiresIn = options.expiresIn || 0;
        }
        if (options.generateFunc) {
          rule.generateFunc = options.generateFunc;
          rule.generateTimeout = options.generateTimeout;
          if (options.staleIn) {
            rule.staleIn = options.staleIn;
            rule.staleTimeout = options.staleTimeout;
          }
          rule.dropOnError = options.dropOnError !== void 0 ? options.dropOnError : true;
          rule.pendingGenerateTimeout = options.pendingGenerateTimeout !== void 0 ? options.pendingGenerateTimeout : 0;
        }
        rule.generateOnReadError = options.generateOnReadError !== void 0 ? options.generateOnReadError : true;
        rule.generateIgnoreWriteError = options.generateIgnoreWriteError !== void 0 ? options.generateIgnoreWriteError : true;
        rule.getDecoratedValue = options.getDecoratedValue;
        return rule;
      }
      static ttl(rule, created, now) {
        now = now || Date.now();
        created = created || now;
        const age = now - created;
        if (age < 0) {
          return 0;
        }
        if (rule.expiresIn) {
          return Math.max(rule.expiresIn - age, 0);
        }
        if (rule.expiresAt) {
          if (age > internals.day) {
            return 0;
          }
          const expiresAt = new Date(created);
          expiresAt.setHours(rule.expiresAt.hours);
          expiresAt.setMinutes(rule.expiresAt.minutes);
          expiresAt.setSeconds(0);
          expiresAt.setMilliseconds(0);
          let expires = expiresAt.getTime();
          if (expires <= created) {
            expires = expires + internals.day;
          }
          if (now >= expires) {
            return 0;
          }
          return expires - now;
        }
        return 0;
      }
    };
    internals.id = function(key) {
      return key && typeof key === "object" ? key.id : key;
    };
  }
});

// node_modules/@hapi/catbox/lib/index.js
var require_lib11 = __commonJS({
  "node_modules/@hapi/catbox/lib/index.js"(exports) {
    "use strict";
    var Client = require_client();
    var Policy = require_policy();
    exports.Client = Client;
    exports.Policy = exports.policy = Policy;
  }
});

// node_modules/@hapi/catbox-memory/lib/index.js
var require_lib12 = __commonJS({
  "node_modules/@hapi/catbox-memory/lib/index.js"(exports, module2) {
    "use strict";
    var Boom = require_lib5();
    var Hoek = require_lib();
    var internals = {
      maxTimer: 2147483647,
      entrySize: 144
    };
    internals.defaults = {
      maxByteSize: 100 * 1024 * 1024,
      minCleanupIntervalMsec: 1e3,
      cloneBuffersOnGet: false
    };
    exports = module2.exports = internals.Connection = class {
      constructor(options = {}) {
        Hoek.assert(options.maxByteSize === void 0 || options.maxByteSize >= 0, "Invalid cache maxByteSize value");
        Hoek.assert(options.allowMixedContent === void 0, "allowMixedContent no longer supported");
        Hoek.assert(options.minCleanupIntervalMsec === void 0 || options.minCleanupIntervalMsec < internals.maxTimer, "Invalid cache minCleanupIntervalMsec value");
        Hoek.assert(options.cloneBuffersOnGet === void 0 || typeof options.cloneBuffersOnGet === "boolean", "Invalid cloneBuffersOnGet value");
        this.settings = Hoek.applyToDefaults(internals.defaults, options);
        this.cache = null;
        this._timer = null;
        this._timerDue = null;
      }
      start() {
        if (!this.cache) {
          this.cache = /* @__PURE__ */ new Map();
          this.byteSize = 0;
        }
      }
      _scheduleCleanup(msec) {
        const cleanup = () => {
          this._timer = null;
          this._timerDue = null;
          const now2 = Date.now();
          let next = Infinity;
          for (const [, segment] of this.cache) {
            for (const [id, envelope] of segment) {
              const ttl = envelope.stored + envelope.ttl - now2;
              if (ttl <= 0) {
                segment.delete(id);
                this.byteSize -= envelope.byteSize;
              } else {
                next = Math.min(next, ttl);
              }
            }
          }
          if (next !== Infinity) {
            this._scheduleCleanup(next);
          }
        };
        const now = Date.now();
        const timeout = Math.min(Math.max(this.settings.minCleanupIntervalMsec, msec), internals.maxTimer);
        if (this._timer) {
          if (this._timerDue - now < msec) {
            return;
          }
          clearTimeout(this._timer);
        }
        this._timerDue = now + timeout;
        this._timer = setTimeout(cleanup, timeout);
      }
      stop() {
        clearTimeout(this._timer);
        this._timer = null;
        this._timerDue = null;
        this.cache = null;
        this.byteSize = 0;
      }
      isReady() {
        return !!this.cache;
      }
      validateSegmentName(name) {
        if (!name) {
          throw new Boom.Boom("Empty string");
        }
        if (name.indexOf("\0") !== -1) {
          throw new Boom.Boom("Includes null character");
        }
        return null;
      }
      get(key) {
        if (!this.cache) {
          throw new Boom.Boom("Connection not started");
        }
        const segment = this.cache.get(key.segment);
        if (!segment) {
          return null;
        }
        const envelope = segment.get(key.id);
        if (!envelope) {
          return null;
        }
        if (envelope.stored + envelope.ttl < Date.now()) {
          this.drop(key);
          return null;
        }
        let item = null;
        if (Buffer.isBuffer(envelope.item)) {
          item = envelope.item;
          if (this.settings.cloneBuffersOnGet) {
            const copy = Buffer.alloc(item.length);
            item.copy(copy);
            item = copy;
          }
        } else {
          try {
            item = JSON.parse(envelope.item);
          } catch (err) {
            throw new Boom.Boom("Bad value content");
          }
        }
        const result = {
          item,
          stored: envelope.stored,
          ttl: envelope.ttl
        };
        return result;
      }
      set(key, value, ttl) {
        if (!this.cache) {
          throw new Boom.Boom("Connection not started");
        }
        const envelope = new internals.MemoryCacheEntry(key, value, ttl);
        let segment = this.cache.get(key.segment);
        if (!segment) {
          segment = /* @__PURE__ */ new Map();
          this.cache.set(key.segment, segment);
        }
        const cachedItem = segment.get(key.id);
        if (cachedItem) {
          this.byteSize -= cachedItem.byteSize;
        }
        if (this.settings.maxByteSize && this.byteSize + envelope.byteSize > this.settings.maxByteSize) {
          throw new Boom.Boom("Cache size limit reached");
        }
        this._scheduleCleanup(ttl);
        segment.set(key.id, envelope);
        this.byteSize += envelope.byteSize;
      }
      drop(key) {
        if (!this.cache) {
          throw new Boom.Boom("Connection not started");
        }
        const segment = this.cache.get(key.segment);
        if (segment) {
          const item = segment.get(key.id);
          if (item) {
            this.byteSize -= item.byteSize;
            segment.delete(key.id);
          }
        }
      }
    };
    internals.MemoryCacheEntry = class {
      constructor(key, value, ttl) {
        let valueByteSize = 0;
        if (Buffer.isBuffer(value)) {
          this.item = Buffer.alloc(value.length);
          value.copy(this.item);
          valueByteSize = this.item.length;
        } else {
          this.item = JSON.stringify(value);
          valueByteSize = Buffer.byteLength(this.item);
        }
        this.stored = Date.now();
        this.ttl = ttl;
        this.byteSize = internals.entrySize + valueByteSize + Buffer.byteLength(key.segment) + Buffer.byteLength(key.id);
        this.timeoutId = null;
      }
    };
  }
});

// node_modules/@hapi/heavy/lib/index.js
var require_lib13 = __commonJS({
  "node_modules/@hapi/heavy/lib/index.js"(exports, module2) {
    "use strict";
    var Boom = require_lib5();
    var Hoek = require_lib();
    var Validate = require_lib3();
    var internals = {};
    internals.schema = Validate.object({
      sampleInterval: Validate.number().min(0),
      maxHeapUsedBytes: Validate.number().min(0),
      maxEventLoopDelay: Validate.number().min(0),
      maxRssBytes: Validate.number().min(0)
    }).unknown();
    internals.defaults = {
      sampleInterval: 0,
      maxHeapUsedBytes: 0,
      maxRssBytes: 0,
      maxEventLoopDelay: 0
    };
    exports = module2.exports = internals.Heavy = function(options) {
      options = options || {};
      Validate.assert(options, internals.schema, "Invalid load monitoring options");
      this.settings = Hoek.applyToDefaults(internals.defaults, options);
      Hoek.assert(this.settings.sampleInterval || !this.settings.maxEventLoopDelay && !this.settings.maxHeapUsedBytes && !this.settings.maxRssBytes, "Load sample interval must be set to enable load limits");
      this._eventLoopTimer = null;
      this._loadBench = new Hoek.Bench();
      this.load = {
        eventLoopDelay: 0,
        heapUsed: 0,
        rss: 0
      };
    };
    internals.Heavy.prototype.start = function() {
      if (!this.settings.sampleInterval) {
        return;
      }
      const loopSample = () => {
        this._loadBench.reset();
        const measure = () => {
          const mem = process.memoryUsage();
          this.load.eventLoopDelay = this._loadBench.elapsed() - this.settings.sampleInterval;
          this.load.heapUsed = mem.heapUsed;
          this.load.rss = mem.rss;
          loopSample();
        };
        this._eventLoopTimer = setTimeout(measure, this.settings.sampleInterval);
      };
      loopSample();
    };
    internals.Heavy.prototype.stop = function() {
      clearTimeout(this._eventLoopTimer);
      this._eventLoopTimer = null;
    };
    internals.Heavy.prototype.check = function() {
      if (!this.settings.sampleInterval) {
        return;
      }
      Hoek.assert(this._eventLoopTimer, "Cannot check load when sampler is not started");
      const elapsed = this._loadBench.elapsed();
      const load = this.load;
      if (elapsed > this.settings.sampleInterval) {
        load.eventLoopDelay = Math.max(load.eventLoopDelay, elapsed - this.settings.sampleInterval);
      }
      if (this.settings.maxEventLoopDelay && load.eventLoopDelay > this.settings.maxEventLoopDelay) {
        throw Boom.serverUnavailable("Server under heavy load (event loop)", load);
      }
      if (this.settings.maxHeapUsedBytes && load.heapUsed > this.settings.maxHeapUsedBytes) {
        throw Boom.serverUnavailable("Server under heavy load (heap)", load);
      }
      if (this.settings.maxRssBytes && load.rss > this.settings.maxRssBytes) {
        throw Boom.serverUnavailable("Server under heavy load (rss)", load);
      }
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/@hapi/mimos/lib/index.js
var require_lib14 = __commonJS({
  "node_modules/@hapi/mimos/lib/index.js"(exports) {
    "use strict";
    var Path = require("path");
    var Hoek = require_lib();
    var MimeDb = require_db();
    var internals = {
      compressibleRx: /^text\/|\+json$|\+text$|\+xml$/
    };
    exports.MimosEntry = class {
      constructor(type, mime) {
        this.type = type;
        this.source = "mime-db";
        this.extensions = [];
        this.compressible = void 0;
        Object.assign(this, mime);
        if (this.compressible === void 0) {
          this.compressible = internals.compressibleRx.test(type);
        }
      }
    };
    internals.insertEntry = function(type, entry, db) {
      db.byType.set(type, entry);
      for (const ext of entry.extensions) {
        db.byExtension.set(ext, entry);
        if (ext.length > db.maxExtLength) {
          db.maxExtLength = ext.length;
        }
      }
    };
    internals.compile = function(mimedb) {
      const db = {
        byType: /* @__PURE__ */ new Map(),
        byExtension: /* @__PURE__ */ new Map(),
        maxExtLength: 0
      };
      for (const type in mimedb) {
        const entry = new exports.MimosEntry(type, mimedb[type]);
        internals.insertEntry(type, entry, db);
      }
      return db;
    };
    internals.getTypePart = function(fulltype) {
      const splitAt = fulltype.indexOf(";");
      return splitAt === -1 ? fulltype : fulltype.slice(0, splitAt);
    };
    internals.applyPredicate = function(mime) {
      if (mime.predicate) {
        return mime.predicate(Hoek.clone(mime));
      }
      return mime;
    };
    exports.Mimos = class Mimos {
      #db = internals.base;
      constructor(options = {}) {
        if (options.override) {
          Hoek.assert(typeof options.override === "object", "overrides option must be an object");
          this.#db = {
            ...this.#db,
            byType: new Map(this.#db.byType),
            byExtension: new Map(this.#db.byExtension)
          };
          for (const type in options.override) {
            const override = options.override[type];
            Hoek.assert(!override.predicate || typeof override.predicate === "function", "predicate option must be a function");
            const from = this.#db.byType.get(type);
            const baseEntry = from ? Hoek.applyToDefaults(from, override) : override;
            const entry = new exports.MimosEntry(type, baseEntry);
            internals.insertEntry(type, entry, this.#db);
          }
        }
      }
      path(path) {
        const extension = Path.extname(path).slice(1).toLowerCase();
        const mime = this.#db.byExtension.get(extension) || {};
        return internals.applyPredicate(mime);
      }
      type(type) {
        type = internals.getTypePart(type);
        let mime = this.#db.byType.get(type);
        if (!mime) {
          type = type.trim().toLowerCase();
          mime = this.#db.byType.get(type);
        }
        if (!mime) {
          mime = new exports.MimosEntry(type, {
            source: "mimos"
          });
          internals.insertEntry(type, mime, this.#db);
          return mime;
        }
        return internals.applyPredicate(mime);
      }
    };
    internals.base = internals.compile(MimeDb);
  }
});

// node_modules/@hapi/bourne/lib/index.js
var require_lib15 = __commonJS({
  "node_modules/@hapi/bourne/lib/index.js"(exports) {
    "use strict";
    var internals = {
      suspectRx: /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*\:/
    };
    exports.parse = function(text, ...args) {
      const firstOptions = typeof args[0] === "object" && args[0];
      const reviver = args.length > 1 || !firstOptions ? args[0] : void 0;
      const options = args.length > 1 && args[1] || firstOptions || {};
      const obj = JSON.parse(text, reviver);
      if (options.protoAction === "ignore") {
        return obj;
      }
      if (!obj || typeof obj !== "object") {
        return obj;
      }
      if (!text.match(internals.suspectRx)) {
        return obj;
      }
      exports.scan(obj, options);
      return obj;
    };
    exports.scan = function(obj, options = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (options.protoAction !== "remove") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(node[key]);
            }
          }
        }
      }
    };
    exports.safeParse = function(text, reviver) {
      try {
        return exports.parse(text, reviver);
      } catch (ignoreError) {
        return null;
      }
    };
  }
});

// node_modules/@hapi/cryptiles/lib/index.js
var require_lib16 = __commonJS({
  "node_modules/@hapi/cryptiles/lib/index.js"(exports) {
    "use strict";
    var Crypto = require("crypto");
    var Boom = require_lib5();
    var internals = {};
    exports.randomString = function(size) {
      const buffer = exports.randomBits((size + 1) * 6);
      const string = buffer.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
      return string.slice(0, size);
    };
    exports.randomAlphanumString = function(size) {
      let result = "";
      while (result.length < size) {
        const buffer = exports.randomBits((size + 1) * 6);
        result += buffer.toString("base64").replace(/[^a-zA-Z0-9]/g, "");
      }
      return result.slice(0, size);
    };
    exports.randomDigits = function(size) {
      const digits = [];
      let buffer = internals.random(size * 2);
      let pos = 0;
      while (digits.length < size) {
        if (pos >= buffer.length) {
          buffer = internals.random(size * 2);
          pos = 0;
        }
        if (buffer[pos] < 250) {
          digits.push(buffer[pos] % 10);
        }
        ++pos;
      }
      return digits.join("");
    };
    exports.randomBits = function(bits) {
      if (!bits || bits < 0) {
        throw Boom.internal("Invalid random bits count");
      }
      const bytes = Math.ceil(bits / 8);
      return internals.random(bytes);
    };
    exports.fixedTimeComparison = function(a, b) {
      try {
        return Crypto.timingSafeEqual(Buffer.from(a), Buffer.from(b));
      } catch (err) {
        return false;
      }
    };
    internals.random = function(bytes) {
      try {
        return Crypto.randomBytes(bytes);
      } catch (err) {
        throw Boom.internal("Failed generating random bits: " + err.message);
      }
    };
  }
});

// node_modules/@hapi/b64/lib/decoder.js
var require_decoder = __commonJS({
  "node_modules/@hapi/b64/lib/decoder.js"(exports) {
    "use strict";
    var Stream = require("stream");
    var internals = {
      decodeChars: [
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        62,
        -1,
        -1,
        -1,
        63,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        -1,
        -1,
        -1,
        -1,
        -1
      ]
    };
    exports.decode = function(buffer) {
      const decodeChars = internals.decodeChars;
      const len = buffer.length;
      const allocated = Math.ceil(len / 4) * 3;
      const result = Buffer.alloc(allocated);
      let c1;
      let c2;
      let c3;
      let c4;
      let j = 0;
      for (let i = 0; i < len; ) {
        do {
          c1 = decodeChars[buffer[i++] & 255];
        } while (i < len && c1 === -1);
        if (c1 === -1) {
          break;
        }
        do {
          c2 = decodeChars[buffer[i++] & 255];
        } while (i < len && c2 === -1);
        if (c2 === -1) {
          break;
        }
        result[j++] = c1 << 2 | (c2 & 48) >> 4;
        do {
          c3 = buffer[i++] & 255;
          if (c3 === 61) {
            return result.slice(0, j);
          }
          c3 = decodeChars[c3];
        } while (i < len && c3 === -1);
        if (c3 === -1) {
          break;
        }
        result[j++] = (c2 & 15) << 4 | (c3 & 60) >> 2;
        do {
          c4 = buffer[i++] & 255;
          if (c4 === 61) {
            return result.slice(0, j);
          }
          c4 = decodeChars[c4];
        } while (i < len && c4 === -1);
        if (c4 !== -1) {
          result[j++] = (c3 & 3) << 6 | c4;
        }
      }
      return j === allocated ? result : result.slice(0, j);
    };
    exports.Decoder = class Decoder extends Stream.Transform {
      constructor() {
        super();
        this._reminder = null;
      }
      _transform(chunk, encoding, callback) {
        let part = this._reminder ? Buffer.concat([this._reminder, chunk]) : chunk;
        const remaining = part.length % 4;
        if (remaining) {
          this._reminder = part.slice(part.length - remaining);
          part = part.slice(0, part.length - remaining);
        } else {
          this._reminder = null;
        }
        this.push(exports.decode(part));
        return callback();
      }
      _flush(callback) {
        if (this._reminder) {
          this.push(exports.decode(this._reminder));
        }
        return callback();
      }
    };
  }
});

// node_modules/@hapi/b64/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/@hapi/b64/lib/encoder.js"(exports) {
    "use strict";
    var Stream = require("stream");
    exports.encode = function(buffer) {
      return Buffer.from(buffer.toString("base64"));
    };
    exports.Encoder = class Encoder extends Stream.Transform {
      constructor() {
        super();
        this._reminder = null;
      }
      _transform(chunk, encoding, callback) {
        let part = this._reminder ? Buffer.concat([this._reminder, chunk]) : chunk;
        const remaining = part.length % 3;
        if (remaining) {
          this._reminder = part.slice(part.length - remaining);
          part = part.slice(0, part.length - remaining);
        } else {
          this._reminder = null;
        }
        this.push(exports.encode(part));
        return callback();
      }
      _flush(callback) {
        if (this._reminder) {
          this.push(exports.encode(this._reminder));
        }
        return callback();
      }
    };
  }
});

// node_modules/@hapi/b64/lib/index.js
var require_lib17 = __commonJS({
  "node_modules/@hapi/b64/lib/index.js"(exports) {
    "use strict";
    var Hoek = require_lib();
    var Decoder = require_decoder();
    var Encoder = require_encoder();
    exports.decode = Decoder.decode;
    exports.encode = Encoder.encode;
    exports.Decoder = Decoder.Decoder;
    exports.Encoder = Encoder.Encoder;
    exports.base64urlEncode = function(value, encoding) {
      Hoek.assert(typeof value === "string" || Buffer.isBuffer(value), "value must be string or buffer");
      const buf = Buffer.isBuffer(value) ? value : Buffer.from(value, encoding || "binary");
      return buf.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
    };
    exports.base64urlDecode = function(value, encoding) {
      if (typeof value !== "string") {
        throw new Error("Value not a string");
      }
      if (!/^[\w\-]*$/.test(value)) {
        throw new Error("Invalid character");
      }
      const buf = Buffer.from(value, "base64");
      return encoding === "buffer" ? buf : buf.toString(encoding || "binary");
    };
  }
});

// node_modules/@hapi/iron/lib/index.js
var require_lib18 = __commonJS({
  "node_modules/@hapi/iron/lib/index.js"(exports) {
    "use strict";
    var Crypto = require("crypto");
    var B64 = require_lib17();
    var Boom = require_lib5();
    var Bourne = require_lib15();
    var Cryptiles = require_lib16();
    var Hoek = require_lib();
    var internals = {};
    exports.defaults = {
      encryption: {
        saltBits: 256,
        algorithm: "aes-256-cbc",
        iterations: 1,
        minPasswordlength: 32
      },
      integrity: {
        saltBits: 256,
        algorithm: "sha256",
        iterations: 1,
        minPasswordlength: 32
      },
      ttl: 0,
      timestampSkewSec: 60,
      localtimeOffsetMsec: 0
    };
    exports.algorithms = {
      "aes-128-ctr": { keyBits: 128, ivBits: 128 },
      "aes-256-cbc": { keyBits: 256, ivBits: 128 },
      "sha256": { keyBits: 256 }
    };
    exports.macFormatVersion = "2";
    exports.macPrefix = "Fe26." + exports.macFormatVersion;
    exports.generateKey = async function(password, options) {
      if (!password) {
        throw new Boom.Boom("Empty password");
      }
      if (!options || typeof options !== "object") {
        throw new Boom.Boom("Bad options");
      }
      const algorithm = exports.algorithms[options.algorithm];
      if (!algorithm) {
        throw new Boom.Boom("Unknown algorithm: " + options.algorithm);
      }
      const result = {};
      if (Buffer.isBuffer(password)) {
        if (password.length < algorithm.keyBits / 8) {
          throw new Boom.Boom("Key buffer (password) too small");
        }
        result.key = password;
        result.salt = "";
      } else {
        if (password.length < options.minPasswordlength) {
          throw new Boom.Boom("Password string too short (min " + options.minPasswordlength + " characters required)");
        }
        let salt = options.salt;
        if (!salt) {
          if (!options.saltBits) {
            throw new Boom.Boom("Missing salt and saltBits options");
          }
          const randomSalt = Cryptiles.randomBits(options.saltBits);
          salt = randomSalt.toString("hex");
        }
        const derivedKey = await internals.pbkdf2(password, salt, options.iterations, algorithm.keyBits / 8, "sha1");
        result.key = derivedKey;
        result.salt = salt;
      }
      if (options.iv) {
        result.iv = options.iv;
      } else if (algorithm.ivBits) {
        result.iv = Cryptiles.randomBits(algorithm.ivBits);
      }
      return result;
    };
    exports.encrypt = async function(password, options, data) {
      const key = await exports.generateKey(password, options);
      const cipher = Crypto.createCipheriv(options.algorithm, key.key, key.iv);
      const encrypted = Buffer.concat([cipher.update(data, "utf8"), cipher.final()]);
      return { encrypted, key };
    };
    exports.decrypt = async function(password, options, data) {
      const key = await exports.generateKey(password, options);
      const decipher = Crypto.createDecipheriv(options.algorithm, key.key, key.iv);
      let dec = decipher.update(data, null, "utf8");
      dec = dec + decipher.final("utf8");
      return dec;
    };
    exports.hmacWithPassword = async function(password, options, data) {
      const key = await exports.generateKey(password, options);
      const hmac = Crypto.createHmac(options.algorithm, key.key).update(data);
      const digest = hmac.digest("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
      return {
        digest,
        salt: key.salt
      };
    };
    internals.normalizePassword = function(password) {
      if (password && typeof password === "object" && !Buffer.isBuffer(password)) {
        return {
          id: password.id,
          encryption: password.secret || password.encryption,
          integrity: password.secret || password.integrity
        };
      }
      return {
        encryption: password,
        integrity: password
      };
    };
    exports.seal = async function(object, password, options) {
      options = Object.assign({}, options);
      const now = Date.now() + (options.localtimeOffsetMsec || 0);
      const objectString = internals.stringify(object);
      let passwordId = "";
      password = internals.normalizePassword(password);
      if (password.id) {
        if (!/^\w+$/.test(password.id)) {
          throw new Boom.Boom("Invalid password id");
        }
        passwordId = password.id;
      }
      const { encrypted, key } = await exports.encrypt(password.encryption, options.encryption, objectString);
      const encryptedB64 = B64.base64urlEncode(encrypted);
      const iv = B64.base64urlEncode(key.iv);
      const expiration = options.ttl ? now + options.ttl : "";
      const macBaseString = exports.macPrefix + "*" + passwordId + "*" + key.salt + "*" + iv + "*" + encryptedB64 + "*" + expiration;
      const mac = await exports.hmacWithPassword(password.integrity, options.integrity, macBaseString);
      const sealed = macBaseString + "*" + mac.salt + "*" + mac.digest;
      return sealed;
    };
    exports.unseal = async function(sealed, password, options) {
      options = Object.assign({}, options);
      const now = Date.now() + (options.localtimeOffsetMsec || 0);
      const parts = sealed.split("*");
      if (parts.length !== 8) {
        throw new Boom.Boom("Incorrect number of sealed components");
      }
      const macPrefix = parts[0];
      const passwordId = parts[1];
      const encryptionSalt = parts[2];
      const encryptionIv = parts[3];
      const encryptedB64 = parts[4];
      const expiration = parts[5];
      const hmacSalt = parts[6];
      const hmac = parts[7];
      const macBaseString = macPrefix + "*" + passwordId + "*" + encryptionSalt + "*" + encryptionIv + "*" + encryptedB64 + "*" + expiration;
      if (macPrefix !== exports.macPrefix) {
        throw new Boom.Boom("Wrong mac prefix");
      }
      if (expiration) {
        if (!expiration.match(/^\d+$/)) {
          throw new Boom.Boom("Invalid expiration");
        }
        const exp = parseInt(expiration, 10);
        if (exp <= now - options.timestampSkewSec * 1e3) {
          throw new Boom.Boom("Expired seal");
        }
      }
      if (!password) {
        throw new Boom.Boom("Empty password");
      }
      if (typeof password === "object" && !Buffer.isBuffer(password)) {
        password = password[passwordId || "default"];
        if (!password) {
          throw new Boom.Boom("Cannot find password: " + passwordId);
        }
      }
      password = internals.normalizePassword(password);
      const macOptions = Hoek.clone(options.integrity);
      macOptions.salt = hmacSalt;
      const mac = await exports.hmacWithPassword(password.integrity, macOptions, macBaseString);
      if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {
        throw new Boom.Boom("Bad hmac value");
      }
      try {
        var encrypted = B64.base64urlDecode(encryptedB64, "buffer");
      } catch (err) {
        throw Boom.boomify(err);
      }
      const decryptOptions = Hoek.clone(options.encryption);
      decryptOptions.salt = encryptionSalt;
      try {
        decryptOptions.iv = B64.base64urlDecode(encryptionIv, "buffer");
      } catch (err) {
        throw Boom.boomify(err);
      }
      const decrypted = await exports.decrypt(password.encryption, decryptOptions, encrypted);
      try {
        return Bourne.parse(decrypted);
      } catch (err) {
        throw new Boom.Boom("Failed parsing sealed object JSON: " + err.message);
      }
    };
    internals.stringify = function(object) {
      try {
        return JSON.stringify(object);
      } catch (err) {
        throw new Boom.Boom("Failed to stringify object: " + err.message);
      }
    };
    internals.pbkdf2 = function(...args) {
      return new Promise((resolve, reject) => {
        const next = (err, result) => {
          if (err) {
            return reject(Boom.boomify(err));
          }
          resolve(result);
        };
        args.push(next);
        Crypto.pbkdf2(...args);
      });
    };
  }
});

// node_modules/@hapi/statehood/lib/index.js
var require_lib19 = __commonJS({
  "node_modules/@hapi/statehood/lib/index.js"(exports) {
    "use strict";
    var Querystring = require("querystring");
    var Boom = require_lib5();
    var Bounce = require_lib6();
    var Bourne = require_lib15();
    var Cryptiles = require_lib16();
    var Hoek = require_lib();
    var Iron = require_lib18();
    var Validate = require_lib3();
    var internals = {
      macPrefix: "hapi.signed.cookie.1"
    };
    internals.schema = Validate.object({
      strictHeader: Validate.boolean(),
      ignoreErrors: Validate.boolean(),
      isSecure: Validate.boolean(),
      isHttpOnly: Validate.boolean(),
      isSameSite: Validate.valid("Strict", "Lax", "None", false),
      path: Validate.string().allow(null),
      domain: Validate.string().allow(null),
      ttl: Validate.number().allow(null),
      encoding: Validate.string().valid("base64json", "base64", "form", "iron", "none"),
      sign: Validate.object({
        password: [Validate.string(), Validate.binary(), Validate.object()],
        integrity: Validate.object()
      }),
      iron: Validate.object(),
      password: [Validate.string(), Validate.binary(), Validate.object()],
      contextualize: Validate.function(),
      clearInvalid: Validate.boolean(),
      autoValue: Validate.any(),
      passThrough: Validate.boolean()
    });
    internals.defaults = {
      strictHeader: true,
      ignoreErrors: false,
      isSecure: true,
      isHttpOnly: true,
      isSameSite: "Strict",
      path: null,
      domain: null,
      ttl: null,
      encoding: "none"
    };
    internals.validateRx = {
      nameRx: {
        strict: /^[^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+$/,
        loose: /^[^=\s]*$/
      },
      valueRx: {
        strict: /^[^\x00-\x20\"\,\;\\\x7F]*$/,
        loose: /^(?:"([^\"]*)")|(?:[^\;]*)$/
      },
      domainRx: /^\.?[a-z\d]+(?:(?:[a-z\d]*)|(?:[a-z\d\-]*[a-z\d]))(?:\.[a-z\d]+(?:(?:[a-z\d]*)|(?:[a-z\d\-]*[a-z\d])))*$/,
      domainLabelLenRx: /^\.?[a-z\d\-]{1,63}(?:\.[a-z\d\-]{1,63})*$/,
      pathRx: /^\/[^\x00-\x1F\;]*$/
    };
    internals.pairsRx = /\s*([^=\s]*)\s*=\s*([^\;]*)(?:(?:;\s*)|$)/g;
    exports.Definitions = class {
      constructor(options) {
        this.settings = Hoek.applyToDefaults(internals.defaults, options || {});
        Validate.assert(this.settings, internals.schema, "Invalid state definition defaults");
        this.cookies = {};
        this.names = [];
      }
      add(name, options) {
        Hoek.assert(name && typeof name === "string", "Invalid name");
        Hoek.assert(!this.cookies[name], "State already defined:", name);
        const settings = Hoek.applyToDefaults(this.settings, options || {}, { nullOverride: true });
        Validate.assert(settings, internals.schema, "Invalid state definition: " + name);
        this.cookies[name] = settings;
        this.names.push(name);
      }
      async parse(cookies) {
        const state = {};
        const names = [];
        const verify = internals.parsePairs(cookies, (name, value) => {
          if (name === "__proto__") {
            throw Boom.badRequest("Invalid cookie header");
          }
          if (state[name]) {
            if (!Array.isArray(state[name])) {
              state[name] = [state[name]];
            }
            state[name].push(value);
          } else {
            state[name] = value;
            names.push(name);
          }
        });
        const failed = [];
        if (verify !== null) {
          if (!this.settings.ignoreErrors) {
            throw Boom.badRequest("Invalid cookie header");
          }
          failed.push({ settings: this.settings, reason: `Header contains unexpected syntax: ${verify}` });
        }
        const errored = [];
        const record = (reason, name, value, definition) => {
          const details = {
            name,
            value,
            settings: definition,
            reason: typeof reason === "string" ? reason : reason.message
          };
          failed.push(details);
          if (!definition.ignoreErrors) {
            errored.push(details);
          }
        };
        const parsed = {};
        for (const name of names) {
          const value = state[name];
          const definition = this.cookies[name] || this.settings;
          if (definition.strictHeader) {
            const reason = internals.validate(name, state);
            if (reason) {
              record(reason, name, value, definition);
              continue;
            }
          }
          if (definition.encoding === "none") {
            parsed[name] = value;
            continue;
          }
          if (!Array.isArray(value)) {
            try {
              const unsigned = await internals.unsign(name, value, definition);
              const result = await internals.decode(unsigned, definition);
              parsed[name] = result;
            } catch (err) {
              Bounce.rethrow(err, "system");
              record(err, name, value, definition);
            }
            continue;
          }
          const arrayResult = [];
          for (const arrayValue of value) {
            try {
              const unsigned = await internals.unsign(name, arrayValue, definition);
              const result = await internals.decode(unsigned, definition);
              arrayResult.push(result);
            } catch (err) {
              Bounce.rethrow(err, "system");
              record(err, name, value, definition);
            }
          }
          parsed[name] = arrayResult;
        }
        if (errored.length) {
          const error = Boom.badRequest("Invalid cookie value", errored);
          error.states = parsed;
          error.failed = failed;
          throw error;
        }
        return { states: parsed, failed };
      }
      async format(cookies, context) {
        if (!cookies || Array.isArray(cookies) && !cookies.length) {
          return [];
        }
        if (!Array.isArray(cookies)) {
          cookies = [cookies];
        }
        const header = [];
        for (let i = 0; i < cookies.length; ++i) {
          const cookie = cookies[i];
          const base = this.cookies[cookie.name] || this.settings;
          let definition = cookie.options ? Hoek.applyToDefaults(base, cookie.options, { nullOverride: true }) : base;
          if (definition.contextualize) {
            if (definition === base) {
              definition = Hoek.clone(definition);
            }
            await definition.contextualize(definition, context);
          }
          const nameRx = definition.strictHeader ? internals.validateRx.nameRx.strict : internals.validateRx.nameRx.loose;
          if (!nameRx.test(cookie.name)) {
            throw Boom.badImplementation("Invalid cookie name: " + cookie.name);
          }
          const value = await exports.prepareValue(cookie.name, cookie.value, definition);
          const valueRx = definition.strictHeader ? internals.validateRx.valueRx.strict : internals.validateRx.valueRx.loose;
          if (value && (typeof value !== "string" || !value.match(valueRx))) {
            throw Boom.badImplementation("Invalid cookie value: " + cookie.value);
          }
          let segment = cookie.name + "=" + (value || "");
          if (definition.ttl !== null && definition.ttl !== void 0) {
            const expires = new Date(definition.ttl ? Date.now() + definition.ttl : 0);
            segment = segment + "; Max-Age=" + Math.floor(definition.ttl / 1e3) + "; Expires=" + expires.toUTCString();
          }
          if (definition.isSecure) {
            segment = segment + "; Secure";
          }
          if (definition.isHttpOnly) {
            segment = segment + "; HttpOnly";
          }
          if (definition.isSameSite) {
            segment = `${segment}; SameSite=${definition.isSameSite}`;
          }
          if (definition.domain) {
            const domain = definition.domain.toLowerCase();
            if (!domain.match(internals.validateRx.domainLabelLenRx)) {
              throw Boom.badImplementation("Cookie domain too long: " + definition.domain);
            }
            if (!domain.match(internals.validateRx.domainRx)) {
              throw Boom.badImplementation("Invalid cookie domain: " + definition.domain);
            }
            segment = segment + "; Domain=" + domain;
          }
          if (definition.path) {
            if (!definition.path.match(internals.validateRx.pathRx)) {
              throw Boom.badImplementation("Invalid cookie path: " + definition.path);
            }
            segment = segment + "; Path=" + definition.path;
          }
          header.push(segment);
        }
        return header;
      }
      passThrough(header, fallback) {
        if (!this.names.length) {
          return header;
        }
        const exclude = [];
        for (let i = 0; i < this.names.length; ++i) {
          const name = this.names[i];
          const definition = this.cookies[name];
          const passCookie = definition.passThrough !== void 0 ? definition.passThrough : fallback;
          if (!passCookie) {
            exclude.push(name);
          }
        }
        return exports.exclude(header, exclude);
      }
    };
    internals.parsePairs = function(cookies, eachPairFn) {
      let index = 0;
      while (index < cookies.length) {
        const eqIndex = cookies.indexOf("=", index);
        if (eqIndex === -1) {
          return cookies.slice(index);
        }
        const semiIndex = cookies.indexOf(";", eqIndex);
        const endOfValueIndex = semiIndex !== -1 ? semiIndex : cookies.length;
        const name = cookies.slice(index, eqIndex).trim();
        const value = cookies.slice(eqIndex + 1, endOfValueIndex).trim();
        const unquotedValue = value.startsWith('"') && value.endsWith('"') && value !== '"' ? value.slice(1, -1) : value;
        eachPairFn(name, unquotedValue);
        index = endOfValueIndex + 1;
      }
      return null;
    };
    internals.validate = function(name, state) {
      if (!name.match(internals.validateRx.nameRx.strict)) {
        return "Invalid cookie name";
      }
      const values = [].concat(state[name]);
      for (let i = 0; i < values.length; ++i) {
        if (!values[i].match(internals.validateRx.valueRx.strict)) {
          return "Invalid cookie value";
        }
      }
      return null;
    };
    internals.unsign = async function(name, value, definition) {
      if (!definition.sign) {
        return value;
      }
      const pos = value.lastIndexOf(".");
      if (pos === -1) {
        throw Boom.badRequest("Missing signature separator");
      }
      const unsigned = value.slice(0, pos);
      const sig = value.slice(pos + 1);
      if (!sig) {
        throw Boom.badRequest("Missing signature");
      }
      const sigParts = sig.split("*");
      if (sigParts.length !== 2) {
        throw Boom.badRequest("Invalid signature format");
      }
      const hmacSalt = sigParts[0];
      const hmac = sigParts[1];
      const macOptions = Hoek.clone(definition.sign.integrity || Iron.defaults.integrity);
      macOptions.salt = hmacSalt;
      const mac = await Iron.hmacWithPassword(definition.sign.password, macOptions, [internals.macPrefix, name, unsigned].join("\n"));
      if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {
        throw Boom.badRequest("Invalid hmac value");
      }
      return unsigned;
    };
    internals.decode = async function(value, definition) {
      if (!value && definition.encoding === "form") {
        return {};
      }
      Hoek.assert(typeof value === "string", "Invalid string");
      if (definition.encoding === "iron") {
        return await Iron.unseal(value, definition.password, definition.iron || Iron.defaults);
      }
      if (definition.encoding === "base64json") {
        const decoded = Buffer.from(value, "base64").toString("binary");
        try {
          return Bourne.parse(decoded);
        } catch (err) {
          throw Boom.badRequest("Invalid JSON payload");
        }
      }
      if (definition.encoding === "base64") {
        return Buffer.from(value, "base64").toString("binary");
      }
      return Querystring.parse(value);
    };
    exports.prepareValue = async function(name, value, options) {
      Hoek.assert(options && typeof options === "object", "Missing or invalid options");
      try {
        const encoded = await internals.encode(value, options);
        const signed = await internals.sign(name, encoded, options.sign);
        return signed;
      } catch (err) {
        throw Boom.badImplementation("Failed to encode cookie (" + name + ") value: " + err.message);
      }
    };
    internals.encode = function(value, options) {
      if (value === void 0 || options.encoding === "none") {
        return value;
      }
      if (options.encoding === "iron") {
        return Iron.seal(value, options.password, options.iron || Iron.defaults);
      }
      if (options.encoding === "base64") {
        return Buffer.from(value, "binary").toString("base64");
      }
      if (options.encoding === "base64json") {
        const stringified = JSON.stringify(value);
        return Buffer.from(stringified, "binary").toString("base64");
      }
      return Querystring.stringify(value);
    };
    internals.sign = async function(name, value, options) {
      if (value === void 0 || !options) {
        return value;
      }
      const mac = await Iron.hmacWithPassword(options.password, options.integrity || Iron.defaults.integrity, [internals.macPrefix, name, value].join("\n"));
      const signed = value + "." + mac.salt + "*" + mac.digest;
      return signed;
    };
    exports.exclude = function(cookies, excludes) {
      let result = "";
      const verify = cookies.replace(internals.pairsRx, ($0, $1, $2) => {
        if (excludes.indexOf($1) === -1) {
          result = result + (result ? ";" : "") + $1 + "=" + $2;
        }
        return "";
      });
      return verify === "" ? result : Boom.badRequest("Invalid cookie header");
    };
  }
});

// node_modules/@hapi/content/lib/index.js
var require_lib20 = __commonJS({
  "node_modules/@hapi/content/lib/index.js"(exports) {
    "use strict";
    var Boom = require_lib5();
    var internals = {};
    internals.contentTypeRegex = /^([^\/\s]+\/[^\s;]+)(.*)?$/;
    internals.paramsRegex = /;\s*boundary=(?:"([^"]+)"|([^;"\s]+))/i;
    exports.type = function(header) {
      if (!header) {
        throw Boom.badRequest("Invalid content-type header");
      }
      const match = header.match(internals.contentTypeRegex);
      if (!match) {
        throw Boom.badRequest("Invalid content-type header");
      }
      const result = {
        mime: match[1].toLowerCase()
      };
      if (result.mime.indexOf("multipart/") === 0) {
        const params = match[2];
        if (params) {
          const param = params.match(internals.paramsRegex);
          if (param) {
            result.boundary = param[1] || param[2];
          }
        }
        if (!result.boundary) {
          throw Boom.badRequest("Invalid content-type header: multipart missing boundary");
        }
      }
      return result;
    };
    internals.contentDispositionRegex = /^\s*form-data\s*(?:;\s*(.+))?$/i;
    internals.contentDispositionParamRegex = /([^\=\*\s]+)(\*)?\s*\=\s*(?:([^;'"\s]+\'[\w-]*\'[^;\s]+)|(?:\"([^"]*)\")|([^;\s]*))(?:\s*(?:;\s*)|$)/g;
    exports.disposition = function(header) {
      if (!header) {
        throw Boom.badRequest("Missing content-disposition header");
      }
      const match = header.match(internals.contentDispositionRegex);
      if (!match) {
        throw Boom.badRequest("Invalid content-disposition header format");
      }
      const parameters = match[1];
      if (!parameters) {
        throw Boom.badRequest("Invalid content-disposition header missing parameters");
      }
      const result = {};
      parameters.replace(internals.contentDispositionParamRegex, ($0, $1, $2, $3, $4, $5) => {
        if ($1 === "__proto__") {
          throw Boom.badRequest("Invalid content-disposition header format includes invalid parameters");
        }
        let value;
        if ($2) {
          if (!$3) {
            throw Boom.badRequest("Invalid content-disposition header format includes invalid parameters");
          }
          try {
            value = decodeURIComponent($3.split("'")[2]);
          } catch (err) {
            throw Boom.badRequest("Invalid content-disposition header format includes invalid parameters");
          }
        } else {
          value = $4 || $5 || "";
        }
        if ($1 === "name" && value === "__proto__") {
          throw Boom.badRequest("Invalid content-disposition header format includes invalid parameters");
        }
        result[$1] = value;
      });
      if (!result.name) {
        throw Boom.badRequest("Invalid content-disposition header missing name parameter");
      }
      return result;
    };
  }
});

// node_modules/@hapi/file/lib/index.js
var require_lib21 = __commonJS({
  "node_modules/@hapi/file/lib/index.js"(exports) {
    "use strict";
    var Crypto = require("crypto");
    var Path = require("path");
    exports.uniqueFilename = function(path, extension) {
      if (extension) {
        extension = extension[0] !== "." ? "." + extension : extension;
      } else {
        extension = "";
      }
      path = Path.resolve(path);
      const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString("hex")].join("-") + extension;
      return Path.join(path, name);
    };
  }
});

// node_modules/@hapi/vise/lib/index.js
var require_lib22 = __commonJS({
  "node_modules/@hapi/vise/lib/index.js"(exports, module2) {
    "use strict";
    var Hoek = require_lib();
    var internals = {};
    exports = module2.exports = internals.Vise = function(chunks) {
      this.length = 0;
      this._chunks = [];
      this._offset = 0;
      if (chunks) {
        chunks = [].concat(chunks);
        for (let i = 0; i < chunks.length; ++i) {
          this.push(chunks[i]);
        }
      }
    };
    internals.Vise.prototype.push = function(chunk) {
      Hoek.assert(Buffer.isBuffer(chunk), "Chunk must be a buffer");
      const item = {
        data: chunk,
        length: chunk.length,
        offset: this.length + this._offset,
        index: this._chunks.length
      };
      this._chunks.push(item);
      this.length += chunk.length;
    };
    internals.Vise.prototype.shift = function(length) {
      if (!length) {
        return [];
      }
      const prevOffset = this._offset;
      const item = this._chunkAt(length);
      let dropTo = this._chunks.length;
      this._offset = 0;
      if (item) {
        dropTo = item.chunk.index;
        this._offset = item.offset;
      }
      const chunks = [];
      for (let i = 0; i < dropTo; ++i) {
        const chunk = this._chunks.shift();
        if (i === 0 && prevOffset) {
          chunks.push(chunk.data.slice(prevOffset));
        } else {
          chunks.push(chunk.data);
        }
      }
      if (this._offset) {
        chunks.push(item.chunk.data.slice(dropTo ? 0 : prevOffset, this._offset));
      }
      this.length = 0;
      for (let i = 0; i < this._chunks.length; ++i) {
        const chunk = this._chunks[i];
        chunk.offset = this.length, chunk.index = i;
        this.length += chunk.length;
      }
      this.length -= this._offset;
      return chunks;
    };
    internals.Vise.prototype.at = internals.Vise.prototype.readUInt8 = function(pos) {
      const item = this._chunkAt(pos);
      return item ? item.chunk.data[item.offset] : void 0;
    };
    internals.Vise.prototype._chunkAt = function(pos) {
      if (pos < 0) {
        return null;
      }
      pos = pos + this._offset;
      for (let i = 0; i < this._chunks.length; ++i) {
        const chunk = this._chunks[i];
        const offset = pos - chunk.offset;
        if (offset < chunk.length) {
          return { chunk, offset };
        }
      }
      return null;
    };
    internals.Vise.prototype.chunks = function() {
      const chunks = [];
      for (let i = 0; i < this._chunks.length; ++i) {
        const chunk = this._chunks[i];
        if (i === 0 && this._offset) {
          chunks.push(chunk.data.slice(this._offset));
        } else {
          chunks.push(chunk.data);
        }
      }
      return chunks;
    };
    internals.Vise.prototype.startsWith = function(value, pos, length) {
      pos = pos || 0;
      length = length ? Math.min(value.length, length) : value.length;
      if (pos + length > this.length) {
        return false;
      }
      const start = this._chunkAt(pos);
      if (!start) {
        return false;
      }
      let j = start.chunk.index;
      for (let i = 0; j < this._chunks.length && i < length; ++j) {
        const chunk = this._chunks[j];
        let k = j === start.chunk.index ? start.offset : 0;
        for (; k < chunk.length && i < length; ++k, ++i) {
          if (chunk.data[k] !== value[i]) {
            return false;
          }
        }
      }
      return true;
    };
  }
});

// node_modules/@hapi/nigel/lib/index.js
var require_lib23 = __commonJS({
  "node_modules/@hapi/nigel/lib/index.js"(exports) {
    "use strict";
    var Stream = require("stream");
    var Hoek = require_lib();
    var Vise = require_lib22();
    var internals = {};
    exports.compile = function(needle) {
      Hoek.assert(needle && needle.length, "Missing needle");
      Hoek.assert(Buffer.isBuffer(needle), "Needle must be a buffer");
      const profile = {
        value: needle,
        lastPos: needle.length - 1,
        last: needle[needle.length - 1],
        length: needle.length,
        badCharShift: Buffer.alloc(256)
      };
      for (let i = 0; i < 256; ++i) {
        profile.badCharShift[i] = profile.length;
      }
      const last = profile.length - 1;
      for (let i = 0; i < last; ++i) {
        profile.badCharShift[profile.value[i]] = last - i;
      }
      return profile;
    };
    exports.horspool = function(haystack, needle, start) {
      Hoek.assert(haystack, "Missing haystack");
      needle = needle.badCharShift ? needle : exports.compile(needle);
      start = start || 0;
      for (let i = start; i <= haystack.length - needle.length; ) {
        const lastChar = haystack.readUInt8(i + needle.lastPos);
        if (lastChar === needle.last && internals.startsWith(haystack, needle, i)) {
          return i;
        }
        i += needle.badCharShift[lastChar];
      }
      return -1;
    };
    internals.startsWith = function(haystack, needle, pos) {
      if (haystack.startsWith) {
        return haystack.startsWith(needle.value, pos, needle.lastPos);
      }
      for (let i = 0; i < needle.lastPos; ++i) {
        if (needle.value[i] !== haystack.readUInt8(pos + i)) {
          return false;
        }
      }
      return true;
    };
    exports.all = function(haystack, needle, start) {
      needle = exports.compile(needle);
      start = start || 0;
      const matches = [];
      for (let i = start; i !== -1 && i < haystack.length; ) {
        i = exports.horspool(haystack, needle, i);
        if (i !== -1) {
          matches.push(i);
          i += needle.length;
        }
      }
      return matches;
    };
    internals._indexOf = function(haystack, needle) {
      Hoek.assert(haystack, "Missing haystack");
      for (let i = 0; i <= haystack.length - needle.length; ++i) {
        if (haystack.startsWith(needle.value, i)) {
          return i;
        }
      }
      return -1;
    };
    exports.Stream = internals.Stream = class extends Stream.Writable {
      constructor(needle) {
        super({ autoDestroy: true });
        this.needle(needle);
        this._haystack = new Vise();
        this._indexOf = this._needle.length > 2 ? exports.horspool : internals._indexOf;
        this.on("finish", () => {
          const chunks = this._haystack.chunks();
          for (let i = 0; i < chunks.length; ++i) {
            this.emit("haystack", chunks[i]);
          }
        });
      }
      needle(needle) {
        this._needle = exports.compile(needle);
      }
      _write(chunk, encoding, next) {
        this._haystack.push(chunk);
        let match = this._indexOf(this._haystack, this._needle);
        if (match === -1 && chunk.length >= this._needle.length) {
          this._flush(this._haystack.length - chunk.length);
        }
        while (match !== -1) {
          this._flush(match);
          this._haystack.shift(this._needle.length);
          this.emit("needle");
          match = this._indexOf(this._haystack, this._needle);
        }
        if (this._haystack.length) {
          const notChecked = this._haystack.length - this._needle.length + 1;
          let i = notChecked;
          for (; i < this._haystack.length; ++i) {
            if (this._haystack.startsWith(this._needle.value, i, this._haystack.length - i)) {
              break;
            }
          }
          this._flush(i);
        }
        return next();
      }
      _flush(pos) {
        const chunks = this._haystack.shift(pos);
        for (let i = 0; i < chunks.length; ++i) {
          this.emit("haystack", chunks[i]);
        }
      }
      flush() {
        const chunks = this._haystack.shift(this._haystack.length);
        for (let i = 0; i < chunks.length; ++i) {
          this.emit("haystack", chunks[i]);
        }
      }
    };
  }
});

// node_modules/@hapi/pez/lib/index.js
var require_lib24 = __commonJS({
  "node_modules/@hapi/pez/lib/index.js"(exports) {
    "use strict";
    var Stream = require("stream");
    var B64 = require_lib17();
    var Boom = require_lib5();
    var Content = require_lib20();
    var Hoek = require_lib();
    var Nigel = require_lib23();
    var internals = {};
    internals.state = {
      preamble: 0,
      boundary: 1,
      header: 2,
      payload: 3,
      epilogue: 4
    };
    internals.defaults = {
      maxBytes: Infinity
    };
    exports.Dispenser = internals.Dispenser = class extends Stream.Writable {
      constructor(options) {
        super({ autoDestroy: false });
        Hoek.assert(options !== null && typeof options === "object", "options must be an object");
        const settings = Hoek.applyToDefaults(internals.defaults, options);
        this._boundary = settings.boundary;
        this._state = internals.state.preamble;
        this._held = "";
        this._stream = null;
        this._headers = {};
        this._name = "";
        this._pendingHeader = "";
        this._error = null;
        this._bytes = 0;
        this._maxBytes = settings.maxBytes;
        this._parts = new Nigel.Stream(Buffer.from("--" + settings.boundary));
        this._lines = new Nigel.Stream(Buffer.from("\r\n"));
        this._parts.on("needle", () => this._onPartEnd());
        this._parts.on("haystack", (chunk) => this._onPart(chunk));
        this._lines.on("needle", () => this._onLineEnd());
        this._lines.on("haystack", (chunk) => this._onLine(chunk));
        this.once("finish", () => this._parts.end());
        this._parts.once("close", () => this._lines.end());
        let piper = null;
        let finish = (err) => {
          if (piper) {
            piper.removeListener("data", onReqData);
            piper.removeListener("error", finish);
            piper.removeListener("aborted", onReqAborted);
          }
          if (err) {
            return this._abort(err);
          }
          this._emit("close");
        };
        finish = Hoek.once(finish);
        this._lines.once("close", () => {
          if (this._state === internals.state.epilogue) {
            if (this._held) {
              this._emit("epilogue", this._held);
              this._held = "";
            }
          } else if (this._state === internals.state.boundary) {
            if (!this._held) {
              this._abort(Boom.badRequest("Missing end boundary"));
            } else if (this._held !== "--") {
              this._abort(Boom.badRequest("Only white space allowed after boundary at end"));
            }
          } else {
            this._abort(Boom.badRequest("Incomplete multipart payload"));
          }
          setImmediate(finish);
        });
        const onReqAborted = () => {
          finish(Boom.badRequest("Client request aborted"));
        };
        const onReqData = (data) => {
          this._bytes += Buffer.byteLength(data);
          if (this._bytes > this._maxBytes) {
            finish(Boom.entityTooLarge("Maximum size exceeded"));
          }
        };
        this.once("pipe", (req) => {
          piper = req;
          req.on("data", onReqData);
          req.once("error", finish);
          req.once("aborted", onReqAborted);
        });
      }
      _write(buffer, encoding, next) {
        if (this._error) {
          return next();
        }
        this._parts.write(buffer);
        return next();
      }
      _emit(...args) {
        if (this._error) {
          return;
        }
        this.emit(...args);
      }
      _abort(err) {
        this._emit("error", err);
        this._error = err;
      }
      _onPartEnd() {
        this._lines.flush();
        if (this._state === internals.state.preamble) {
          if (this._held) {
            const last = this._held.length - 1;
            if (this._held[last] !== "\n" || this._held[last - 1] !== "\r") {
              return this._abort(Boom.badRequest("Preamble missing CRLF terminator"));
            }
            this._emit("preamble", this._held.slice(0, -2));
            this._held = "";
          }
          this._parts.needle(Buffer.from("\r\n--" + this._boundary));
        }
        this._state = internals.state.boundary;
        if (this._stream) {
          this._stream.end();
          this._stream = null;
        } else if (this._name) {
          this._emit("field", this._name, this._held);
          this._name = "";
          this._held = "";
        }
      }
      _onPart(chunk) {
        if (this._state === internals.state.preamble) {
          this._held = this._held + chunk.toString();
        } else if (this._state === internals.state.payload) {
          if (this._stream) {
            this._stream.write(chunk);
          } else {
            this._held = this._held + chunk.toString();
          }
        } else {
          this._lines.write(chunk);
        }
      }
      _onLineEnd() {
        if (this._state === internals.state.boundary) {
          if (this._held) {
            this._held = this._held.replace(/[\t ]/g, "");
            if (this._held) {
              if (this._held === "--") {
                this._state = internals.state.epilogue;
                this._held = "";
                return;
              }
              return this._abort(Boom.badRequest("Only white space allowed after boundary"));
            }
          }
          this._state = internals.state.header;
          return;
        }
        if (this._state === internals.state.header) {
          if (this._held) {
            if (this._held[0] === " " || this._held[0] === "	") {
              if (!this._pendingHeader) {
                return this._abort(Boom.badRequest("Invalid header continuation without valid declaration on previous line"));
              }
              this._pendingHeader = this._pendingHeader + " " + this._held.slice(1);
              this._held = "";
              return;
            }
            this._flushHeader();
            this._pendingHeader = this._held;
            this._held = "";
            return;
          }
          this._flushHeader();
          this._state = internals.state.payload;
          let disposition;
          try {
            disposition = Content.disposition(this._headers["content-disposition"]);
          } catch (err) {
            return this._abort(err);
          }
          if (disposition.filename !== void 0) {
            const stream = new Stream.PassThrough();
            const transferEncoding = this._headers["content-transfer-encoding"];
            if (transferEncoding && transferEncoding.toLowerCase() === "base64") {
              this._stream = new B64.Decoder();
              this._stream.pipe(stream);
            } else {
              this._stream = stream;
            }
            stream.name = disposition.name;
            stream.filename = disposition.filename;
            stream.headers = this._headers;
            this._headers = {};
            this._emit("part", stream);
          } else {
            this._name = disposition.name;
          }
          this._lines.flush();
          return;
        }
        this._held = this._held + "\r\n";
      }
      _onLine(chunk) {
        if (this._stream) {
          this._stream.write(chunk);
        } else {
          this._held = this._held + chunk.toString();
        }
      }
      _flushHeader() {
        if (!this._pendingHeader) {
          return;
        }
        const sep = this._pendingHeader.indexOf(":");
        if (sep === -1) {
          return this._abort(Boom.badRequest("Invalid header missing colon separator"));
        }
        if (!sep) {
          return this._abort(Boom.badRequest("Invalid header missing field name"));
        }
        const name = this._pendingHeader.slice(0, sep).toLowerCase();
        if (name === "__proto__") {
          return this._abort(Boom.badRequest("Invalid header"));
        }
        this._headers[name] = this._pendingHeader.slice(sep + 1).trim();
        this._pendingHeader = "";
      }
    };
  }
});

// node_modules/@hapi/wreck/lib/payload.js
var require_payload = __commonJS({
  "node_modules/@hapi/wreck/lib/payload.js"(exports, module2) {
    "use strict";
    var Stream = require("stream");
    var internals = {};
    module2.exports = internals.Payload = class extends Stream.Readable {
      constructor(payload, encoding) {
        super();
        const data = [].concat(payload || "");
        let size = 0;
        for (let i = 0; i < data.length; ++i) {
          const chunk = data[i];
          size = size + chunk.length;
          data[i] = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
        }
        this._data = Buffer.concat(data, size);
        this._position = 0;
        this._encoding = encoding || "utf8";
      }
      _read(size) {
        const chunk = this._data.slice(this._position, this._position + size);
        this.push(chunk, this._encoding);
        this._position = this._position + chunk.length;
        if (this._position >= this._data.length) {
          this.push(null);
        }
      }
    };
  }
});

// node_modules/@hapi/wreck/lib/recorder.js
var require_recorder = __commonJS({
  "node_modules/@hapi/wreck/lib/recorder.js"(exports, module2) {
    "use strict";
    var Stream = require("stream");
    var Boom = require_lib5();
    var internals = {};
    module2.exports = internals.Recorder = class extends Stream.Writable {
      constructor(options) {
        super();
        this.settings = options;
        this.buffers = [];
        this.length = 0;
      }
      _write(chunk, encoding, next) {
        if (this.settings.maxBytes && this.length + chunk.length > this.settings.maxBytes) {
          return this.emit("error", Boom.entityTooLarge("Payload content length greater than maximum allowed: " + this.settings.maxBytes));
        }
        this.length = this.length + chunk.length;
        this.buffers.push(chunk);
        next();
      }
      collect() {
        const buffer = this.buffers.length === 0 ? Buffer.alloc(0) : this.buffers.length === 1 ? this.buffers[0] : Buffer.concat(this.buffers, this.length);
        return buffer;
      }
    };
  }
});

// node_modules/@hapi/wreck/lib/tap.js
var require_tap = __commonJS({
  "node_modules/@hapi/wreck/lib/tap.js"(exports, module2) {
    "use strict";
    var Stream = require("stream");
    var Payload = require_payload();
    var internals = {};
    module2.exports = internals.Tap = class extends Stream.Transform {
      constructor() {
        super();
        this.buffers = [];
      }
      _transform(chunk, encoding, next) {
        this.buffers.push(chunk);
        next(null, chunk);
      }
      collect() {
        return new Payload(this.buffers);
      }
    };
  }
});

// node_modules/@hapi/wreck/lib/index.js
var require_lib25 = __commonJS({
  "node_modules/@hapi/wreck/lib/index.js"(exports, module2) {
    "use strict";
    var Events = require("events");
    var Http = require("http");
    var Https = require("https");
    var Stream = require("stream");
    var Url = require("url");
    var Zlib = require("zlib");
    var Boom = require_lib5();
    var Bourne = require_lib15();
    var Hoek = require_lib();
    var Payload = require_payload();
    var Recorder = require_recorder();
    var Tap = require_tap();
    var internals = {
      jsonRegex: /^application\/([a-z0-9.]*[+-]json|json)$/,
      shallowOptions: ["agent", "agents", "beforeRedirect", "payload", "redirected"]
    };
    internals.Client = class {
      constructor(options = {}) {
        Hoek.assert(!options.agents || options.agents.https && options.agents.http && options.agents.httpsAllowUnauthorized, 'Option agents must include "http", "https", and "httpsAllowUnauthorized"');
        this._defaults = Hoek.clone(options, { shallow: internals.shallowOptions });
        this.agents = this._defaults.agents || {
          https: new Https.Agent({ maxSockets: Infinity }),
          http: new Http.Agent({ maxSockets: Infinity }),
          httpsAllowUnauthorized: new Https.Agent({ maxSockets: Infinity, rejectUnauthorized: false })
        };
        if (this._defaults.events) {
          this.events = new Events.EventEmitter();
        }
      }
      defaults(options) {
        Hoek.assert(options && typeof options === "object", "options must be provided to defaults");
        options = Hoek.applyToDefaults(this._defaults, options, { shallow: internals.shallowOptions });
        return new internals.Client(options);
      }
      request(method, url, options = {}) {
        try {
          options = Hoek.applyToDefaults(this._defaults, options, { shallow: internals.shallowOptions });
          Hoek.assert(options.payload === void 0 || typeof options.payload === "string" || typeof options.payload === "object", "options.payload must be a string, a Buffer, a Stream, or an Object");
          Hoek.assert(internals.isNullOrUndefined(options.agent) || typeof options.rejectUnauthorized !== "boolean", "options.agent cannot be set to an Agent at the same time as options.rejectUnauthorized is set");
          Hoek.assert(internals.isNullOrUndefined(options.beforeRedirect) || typeof options.beforeRedirect === "function", "options.beforeRedirect must be a function");
          Hoek.assert(internals.isNullOrUndefined(options.redirected) || typeof options.redirected === "function", "options.redirected must be a function");
          Hoek.assert(options.gunzip === void 0 || typeof options.gunzip === "boolean" || options.gunzip === "force", 'options.gunzip must be a boolean or "force"');
        } catch (err) {
          return Promise.reject(err);
        }
        if (options.baseUrl) {
          url = internals.resolveUrl(options.baseUrl, url);
          delete options.baseUrl;
        }
        const relay = {};
        const req = this._request(method, url, options, relay);
        const promise = new Promise((resolve, reject) => {
          relay.callback = (err, res) => {
            if (err) {
              reject(err);
              return;
            }
            resolve(res);
            return;
          };
        });
        promise.req = req;
        return promise;
      }
      _request(method, url, options, relay, _trace) {
        const uri = {};
        if (options.socketPath) {
          uri.socketPath = options.socketPath;
          const parsedUri = new Url.URL(url, `unix://${options.socketPath}`);
          internals.applyUrlToOptions(uri, {
            host: "",
            protocol: "http:",
            hash: parsedUri.hash,
            search: parsedUri.search,
            searchParams: parsedUri.searchParams,
            pathname: parsedUri.pathname,
            href: parsedUri.href
          });
        } else {
          uri.setHost = false;
          const parsedUri = new Url.URL(url);
          internals.applyUrlToOptions(uri, parsedUri);
        }
        uri.method = method.toUpperCase();
        uri.headers = Object.assign({}, options.headers);
        const hostHeader = internals.findHeader("host", uri.headers);
        if (!hostHeader) {
          uri.headers.host = uri.host;
        }
        const hasContentLength = internals.findHeader("content-length", uri.headers) !== void 0;
        if (options.payload && typeof options.payload === "object" && !(options.payload instanceof Stream) && !Buffer.isBuffer(options.payload)) {
          options.payload = JSON.stringify(options.payload);
          if (!internals.findHeader("content-type", uri.headers)) {
            uri.headers["content-type"] = "application/json";
          }
        }
        if (options.gunzip && internals.findHeader("accept-encoding", uri.headers) === void 0) {
          uri.headers["accept-encoding"] = "gzip";
        }
        const payloadSupported = uri.method !== "GET" && uri.method !== "HEAD" && !internals.isNullOrUndefined(options.payload);
        if (payloadSupported && (typeof options.payload === "string" || Buffer.isBuffer(options.payload)) && !hasContentLength) {
          uri.headers["content-length"] = Buffer.isBuffer(options.payload) ? options.payload.length : Buffer.byteLength(options.payload);
        }
        let redirects = options.hasOwnProperty("redirects") ? options.redirects : false;
        _trace = _trace || [];
        _trace.push({ method: uri.method, url });
        const client = uri.protocol === "https:" ? Https : Http;
        if (options.rejectUnauthorized !== void 0 && uri.protocol === "https:") {
          uri.agent = options.rejectUnauthorized ? this.agents.https : this.agents.httpsAllowUnauthorized;
        } else if (options.agent || options.agent === false) {
          uri.agent = options.agent;
        } else {
          uri.agent = uri.protocol === "https:" ? this.agents.https : this.agents.http;
        }
        if (options.secureProtocol !== void 0) {
          uri.secureProtocol = options.secureProtocol;
        }
        if (options.ciphers !== void 0) {
          uri.ciphers = options.ciphers;
        }
        this._emit("preRequest", uri, options);
        const start = Date.now();
        const req = client.request(uri);
        this._emit("request", req);
        let shadow = null;
        let timeoutId;
        const onError = (err) => {
          err.trace = _trace;
          return finishOnce(Boom.badGateway("Client request error", err));
        };
        const onAbort = () => {
          if (!req.socket) {
            const error = new Error("socket hang up");
            error.code = "ECONNRESET";
            finishOnce(error);
          }
        };
        req.once("error", onError);
        const onResponse = (res) => {
          const statusCode = res.statusCode;
          const redirectMethod = internals.redirectMethod(statusCode, uri.method, options);
          if (redirects === false || !redirectMethod) {
            return finishOnce(null, res);
          }
          res.destroy();
          if (redirects === 0) {
            return finishOnce(Boom.badGateway("Maximum redirections reached", _trace));
          }
          let location = res.headers.location;
          if (!location) {
            return finishOnce(Boom.badGateway("Received redirection without location", _trace));
          }
          if (!/^https?:/i.test(location)) {
            location = Url.resolve(uri.href, location);
          }
          const redirectOptions = Hoek.clone(options, { shallow: internals.shallowOptions });
          redirectOptions.payload = shadow || options.payload;
          redirectOptions.redirects = --redirects;
          if (timeoutId) {
            clearTimeout(timeoutId);
            const elapsed = Date.now() - start;
            redirectOptions.timeout = (redirectOptions.timeout - elapsed).toString();
          }
          if (redirectOptions.headers) {
            const parsedLocation = new URL(location);
            if (uri.hostname !== parsedLocation.hostname) {
              for (const header of Object.keys(redirectOptions.headers)) {
                const lowerHeader = header.toLowerCase();
                if (lowerHeader === "authorization" || lowerHeader === "cookie") {
                  delete redirectOptions.headers[header];
                }
              }
            }
          }
          const followRedirect = (err) => {
            if (err) {
              err.trace = _trace;
              return finishOnce(Boom.badGateway("Invalid redirect", err));
            }
            const redirectReq = this._request(redirectMethod, location, redirectOptions, { callback: finishOnce }, _trace);
            if (options.redirected) {
              options.redirected(statusCode, location, redirectReq);
            }
          };
          if (!options.beforeRedirect) {
            return followRedirect();
          }
          return options.beforeRedirect(redirectMethod, statusCode, location, res.headers, redirectOptions, followRedirect);
        };
        const finish = (err, res) => {
          if (err) {
            req.abort();
          }
          req.removeListener("response", onResponse);
          req.removeListener("error", onError);
          req.removeListener("abort", onAbort);
          req.on("error", Hoek.ignore);
          clearTimeout(timeoutId);
          this._emit("response", err, { req, res, start, uri });
          return relay.callback(err, res);
        };
        const finishOnce = Hoek.once(finish);
        req.once("response", onResponse);
        if (options.timeout) {
          timeoutId = setTimeout(() => finishOnce(Boom.gatewayTimeout("Client request timeout")), options.timeout);
        }
        req.on("abort", onAbort);
        if (payloadSupported) {
          if (options.payload instanceof Stream) {
            let stream = options.payload;
            if (redirects) {
              const collector = new Tap();
              collector.once("finish", () => {
                shadow = collector.collect();
              });
              stream = options.payload.pipe(collector);
            }
            internals.deferPipeUntilSocketConnects(req, stream);
            return req;
          }
          req.write(options.payload);
        }
        req.end();
        return req;
      }
      _emit(...args) {
        if (this.events) {
          this.events.emit(...args);
        }
      }
      read(res, options = {}) {
        return new Promise((resolve, reject) => {
          this._read(res, options, (err, payload) => {
            if (err) {
              reject(err);
              return;
            }
            resolve(payload);
            return;
          });
        });
      }
      _read(res, options, callback) {
        options = Hoek.applyToDefaults(this._defaults, options, { shallow: internals.shallowOptions });
        let clientTimeoutId = null;
        const finish = (err, buffer) => {
          clearTimeout(clientTimeoutId);
          reader.removeListener("error", onReaderError);
          reader.removeListener("finish", onReaderFinish);
          res.removeListener("error", onResError);
          res.removeListener("close", onResAborted);
          res.removeListener("aborted", onResAborted);
          res.on("error", Hoek.ignore);
          if (err) {
            return callback(err);
          }
          if (!options.json) {
            return callback(null, buffer);
          }
          if (options.json === "force") {
            return internals.tryParseBuffer(buffer, callback);
          }
          const contentType = res.headers && internals.findHeader("content-type", res.headers) || "";
          const mime = contentType.split(";")[0].trim().toLowerCase();
          if (!internals.jsonRegex.test(mime)) {
            if (options.json === "strict") {
              return callback(Boom.notAcceptable("The content-type is not JSON compatible"));
            }
            return callback(null, buffer);
          }
          return internals.tryParseBuffer(buffer, callback);
        };
        const finishOnce = Hoek.once(finish);
        const clientTimeout = options.timeout;
        if (clientTimeout && clientTimeout > 0) {
          clientTimeoutId = setTimeout(() => finishOnce(Boom.clientTimeout()), clientTimeout);
        }
        const onResError = (err) => {
          return finishOnce(err.isBoom ? err : Boom.internal("Payload stream error", err));
        };
        const onResAborted = () => {
          if (!res.complete) {
            finishOnce(Boom.internal("Payload stream closed prematurely"));
          }
        };
        res.once("error", onResError);
        res.once("close", onResAborted);
        res.once("aborted", onResAborted);
        const reader = new Recorder({ maxBytes: options.maxBytes });
        const onReaderError = (err) => {
          if (res.destroy) {
            res.destroy();
          }
          return finishOnce(err);
        };
        reader.once("error", onReaderError);
        const onReaderFinish = () => {
          return finishOnce(null, reader.collect());
        };
        reader.once("finish", onReaderFinish);
        if (options.gunzip) {
          const contentEncoding = options.gunzip === "force" ? "gzip" : res.headers && internals.findHeader("content-encoding", res.headers) || "";
          if (/^(x-)?gzip(\s*,\s*identity)?$/.test(contentEncoding)) {
            const gunzip = Zlib.createGunzip();
            gunzip.once("error", onReaderError);
            res.pipe(gunzip).pipe(reader);
            return;
          }
        }
        res.pipe(reader);
      }
      toReadableStream(payload, encoding) {
        return new Payload(payload, encoding);
      }
      parseCacheControl(field) {
        const regex = /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g;
        const header = {};
        const error = field.replace(regex, ($0, $1, $2, $3) => {
          const value = $2 || $3;
          header[$1] = value ? value.toLowerCase() : true;
          return "";
        });
        if (header["max-age"]) {
          try {
            const maxAge = parseInt(header["max-age"], 10);
            if (isNaN(maxAge)) {
              return null;
            }
            header["max-age"] = maxAge;
          } catch (err) {
          }
        }
        return error ? null : header;
      }
      get(uri, options) {
        return this._shortcut("GET", uri, options);
      }
      post(uri, options) {
        return this._shortcut("POST", uri, options);
      }
      patch(uri, options) {
        return this._shortcut("PATCH", uri, options);
      }
      put(uri, options) {
        return this._shortcut("PUT", uri, options);
      }
      delete(uri, options) {
        return this._shortcut("DELETE", uri, options);
      }
      async _shortcut(method, uri, options = {}) {
        const res = await this.request(method, uri, options);
        let payload;
        try {
          payload = await this.read(res, options);
        } catch (err) {
          err.data = err.data || {};
          err.data.res = res;
          throw err;
        }
        if (res.statusCode < 400) {
          return { res, payload };
        }
        const data = {
          isResponseError: true,
          headers: res.headers,
          res,
          payload
        };
        throw new Boom.Boom(`Response Error: ${res.statusCode} ${res.statusMessage}`, { statusCode: res.statusCode, data });
      }
    };
    internals.resolveUrl = function(baseUrl, path) {
      if (!path) {
        return baseUrl;
      }
      const url = new Url.URL(path, baseUrl);
      return Url.format(url);
    };
    internals.deferPipeUntilSocketConnects = function(req, stream) {
      const onSocket = (socket) => {
        if (!socket.connecting) {
          return onSocketConnect();
        }
        socket.once("connect", onSocketConnect);
      };
      const onSocketConnect = () => {
        stream.pipe(req);
        stream.removeListener("error", onStreamError);
      };
      const onStreamError = (err) => {
        req.emit("error", err);
      };
      req.once("socket", onSocket);
      stream.on("error", onStreamError);
    };
    internals.redirectMethod = function(code, method, options) {
      switch (code) {
        case 301:
        case 302:
          return options.redirectMethod || method;
        case 303:
          if (options.redirect303) {
            return "GET";
          }
          break;
        case 307:
        case 308:
          return method;
      }
      return null;
    };
    internals.tryParseBuffer = function(buffer, next) {
      if (buffer.length === 0) {
        return next(null, null);
      }
      let payload;
      try {
        payload = Bourne.parse(buffer.toString());
      } catch (err) {
        return next(Boom.badGateway(err.message, { payload: buffer }));
      }
      return next(null, payload);
    };
    internals.findHeader = function(headerName, headers) {
      const normalizedName = headerName.toLowerCase();
      for (const key of Object.keys(headers)) {
        if (key.toLowerCase() === normalizedName) {
          return headers[key];
        }
      }
    };
    internals.applyUrlToOptions = (options, url) => {
      options.host = url.host;
      options.origin = url.origin;
      options.searchParams = url.searchParams;
      options.protocol = url.protocol;
      options.hostname = typeof url.hostname === "string" && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname;
      options.hash = url.hash;
      options.search = url.search;
      options.pathname = url.pathname;
      options.path = `${url.pathname}${url.search || ""}`;
      options.href = url.href;
      if (url.port !== "") {
        options.port = Number(url.port);
      }
      if (url.username || url.password) {
        options.auth = `${url.username}:${url.password}`;
        options.username = url.username;
        options.password = url.password;
      }
      return options;
    };
    internals.isNullOrUndefined = (val) => [null, void 0].includes(val);
    module2.exports = new internals.Client();
  }
});

// node_modules/@hapi/subtext/lib/index.js
var require_lib26 = __commonJS({
  "node_modules/@hapi/subtext/lib/index.js"(exports) {
    "use strict";
    var Fs = require("fs");
    var Os = require("os");
    var Querystring = require("querystring");
    var Stream = require("stream");
    var Zlib = require("zlib");
    var Boom = require_lib5();
    var Bourne = require_lib15();
    var Content = require_lib20();
    var File = require_lib21();
    var Hoek = require_lib();
    var Pez = require_lib24();
    var Wreck = require_lib25();
    var internals = {
      decoders: {
        gzip: (options) => Zlib.createGunzip(options),
        deflate: (options) => Zlib.createInflate(options)
      }
    };
    exports.parse = async function(req, tap, options) {
      Hoek.assert(options, "Missing options");
      Hoek.assert(options.parse !== void 0, "Missing parse option setting");
      Hoek.assert(options.output !== void 0, "Missing output option setting");
      const contentLength = req.headers["content-length"];
      if (options.maxBytes !== void 0 && contentLength && parseInt(contentLength, 10) > options.maxBytes) {
        throw Boom.entityTooLarge("Payload content length greater than maximum allowed: " + options.maxBytes);
      }
      const contentType = Content.type(options.override || req.headers["content-type"] || options.defaultContentType || "application/octet-stream");
      try {
        if (options.allow && options.allow.indexOf(contentType.mime) === -1) {
          throw Boom.unsupportedMediaType();
        }
        const parsed = { mime: contentType.mime };
        if (options.parse === true) {
          parsed.payload = await internals.parse(req, tap, options, contentType);
          return parsed;
        }
        parsed.payload = await internals.raw(req, tap, options);
        return parsed;
      } catch (err) {
        err.mime = contentType.mime;
        throw err;
      }
    };
    internals.parse = async function(req, tap, options, contentType) {
      const output = options.output;
      let source = internals.decoder(req, options);
      if (tap) {
        [source] = internals.pipe(source, tap);
      }
      if (contentType.mime === "multipart/form-data") {
        if (options.multipart === false) {
          throw Boom.unsupportedMediaType();
        }
        return await internals.multipart(req, options, source, contentType);
      }
      if (output === "stream") {
        return source;
      }
      if (output === "file") {
        const file = await internals.writeFile(req, options, source);
        return file.item;
      }
      const payload = await Wreck.read(source, { timeout: options.timeout, maxBytes: options.maxBytes });
      return internals.object(options, payload, contentType.mime);
    };
    internals.decoder = function(source, options) {
      const contentEncoding = source.headers["content-encoding"];
      const decoders = options.decoders || internals.decoders;
      if (!decoders.hasOwnProperty(contentEncoding)) {
        return source;
      }
      const decoderOptions = options.compression && options.compression[contentEncoding] || null;
      const stream = decoders[contentEncoding](decoderOptions);
      const orig = stream.emit;
      stream.emit = (event, ...args) => {
        if (event === "error") {
          args = [Boom.badRequest("Invalid compressed payload", args[0])];
        }
        return orig.call(stream, event, ...args);
      };
      [source] = internals.pipe(source, stream);
      return source;
    };
    internals.raw = async function(req, tap, options) {
      const output = options.output;
      let source = req;
      if (options.parse === "gunzip") {
        source = internals.decoder(source, options);
      }
      if (tap) {
        [source] = internals.pipe(source, tap);
      }
      if (output === "stream") {
        return source;
      }
      if (output === "file") {
        const file = await internals.writeFile(req, options, source);
        return file.item;
      }
      return await Wreck.read(source, { timeout: options.timeout, maxBytes: options.maxBytes });
    };
    internals.object = function(options, payload, mime) {
      if (mime === "application/octet-stream") {
        return payload.length ? payload : null;
      }
      if (mime.match(/^text\/.+$/)) {
        return payload.toString("utf8");
      }
      if (/^application\/(?:.+\+)?json$/.test(mime)) {
        if (!payload.length) {
          return null;
        }
        try {
          return Bourne.parse(payload.toString("utf8"), { protoAction: options.protoAction });
        } catch (err) {
          const error2 = Boom.badRequest("Invalid request payload JSON format", err);
          error2.raw = payload;
          throw error2;
        }
      }
      if (mime === "application/x-www-form-urlencoded") {
        const parse = options.querystring || Querystring.parse;
        return payload.length ? parse(payload.toString("utf8")) : {};
      }
      const error = Boom.unsupportedMediaType();
      error.raw = payload;
      throw error;
    };
    internals.multipart = function(req, options, source, contentType) {
      return new Promise((resolve, reject) => {
        const clientTimeout = options.timeout;
        const clientTimeoutId = clientTimeout ? setTimeout(() => reject(Boom.clientTimeout()), clientTimeout) : null;
        const dispenserOptions = Hoek.applyToDefaults(contentType, { maxBytes: options.maxBytes });
        const dispenser = new Pez.Dispenser(dispenserOptions);
        const onError = (err) => reject(Boom.badRequest("Invalid multipart payload format", err));
        dispenser.once("error", onError);
        const data = {};
        const pendingFiles = [];
        const set = (name, value) => {
          if (!data.hasOwnProperty(name)) {
            data[name] = value;
          } else if (Array.isArray(data[name])) {
            data[name].push(value);
          } else {
            data[name] = [data[name], value];
          }
        };
        const finalize = async () => {
          clearTimeout(clientTimeoutId);
          dispenser.removeListener("error", onError);
          dispenser.removeListener("part", onPart);
          dispenser.removeListener("field", onField);
          dispenser.removeListener("close", onClose);
          try {
            const files = await Promise.all(pendingFiles);
            for (const { item, name } of files) {
              set(name, item);
            }
          } catch (err) {
            reject(err);
            return;
          }
          resolve(data);
        };
        const output = typeof options.multipart === "object" ? options.multipart.output : options.output;
        const onPart = (part) => {
          if (output === "file") {
            pendingFiles.push(internals.writeFile(req, options, part));
          } else {
            internals.part(part, output, set, options);
          }
        };
        dispenser.on("part", onPart);
        const onField = (name, value) => set(name, value);
        dispenser.on("field", onField);
        const onClose = () => finalize();
        dispenser.once("close", onClose);
        source.pipe(dispenser);
      });
    };
    internals.writeFile = function(req, options, stream) {
      const promise = new Promise((resolve, reject) => {
        const path = File.uniqueFilename(options.uploads || Os.tmpdir());
        const file = Fs.createWriteStream(path, { flags: "wx" });
        const counter = new internals.Counter(options);
        const finalize = (err) => {
          req.removeListener("aborted", onAbort);
          file.removeListener("close", finalize);
          file.removeListener("error", finalize);
          if (err) {
            unpipeStreamToCounter();
            unpipeCounterToFile();
            file.destroy();
            Fs.unlink(path, () => reject(err));
            return;
          }
          const result = {
            item: {
              path,
              bytes: counter.bytes
            }
          };
          if (stream.name) {
            result.name = stream.name;
            result.item.filename = stream.filename;
            result.item.headers = stream.headers;
          }
          resolve(result);
        };
        file.once("close", finalize);
        file.once("error", finalize);
        const onAbort = () => finalize(Boom.badRequest("Client connection aborted"));
        req.once("aborted", onAbort);
        const [, unpipeStreamToCounter] = internals.pipe(stream, counter);
        const [, unpipeCounterToFile] = internals.pipe(counter, file);
      });
      promise.catch(Hoek.ignore);
      return promise;
    };
    internals.part = async function(part, output, set, options) {
      const payload = await Wreck.read(part);
      if (output === "stream") {
        const item = Wreck.toReadableStream(payload);
        item.hapi = {
          filename: part.filename,
          headers: part.headers
        };
        return set(part.name, item);
      }
      const ct = part.headers["content-type"] || "";
      const mime = ct.split(";")[0].trim().toLowerCase();
      const annotate = (value) => set(part.name, output === "annotated" ? { filename: part.filename, headers: part.headers, payload: value } : value);
      if (!mime) {
        return annotate(payload);
      }
      if (!payload.length) {
        return annotate({});
      }
      try {
        const object = internals.object(options, payload, mime);
        annotate(object);
      } catch (err) {
        annotate(payload);
      }
    };
    internals.pipe = function(from, to) {
      const forwardError = (err) => {
        unpipe();
        to.emit("error", err);
      };
      const unpipe = () => {
        from.removeListener("error", forwardError);
        return from.unpipe(to);
      };
      from.once("error", forwardError);
      return [from.pipe(to), unpipe];
    };
    internals.Counter = class extends Stream.Transform {
      constructor(options) {
        super();
        this.bytes = 0;
        this._maxBytes = options.maxBytes;
      }
      _transform(chunk, encoding, next) {
        this.bytes = this.bytes + chunk.length;
        if (this._maxBytes !== void 0 && this.bytes > this._maxBytes) {
          return next(Boom.entityTooLarge("Payload content length greater than maximum allowed: " + this._maxBytes));
        }
        return next(null, chunk);
      }
    };
  }
});

// node_modules/@hapi/hapi/lib/ext.js
var require_ext = __commonJS({
  "node_modules/@hapi/hapi/lib/ext.js"(exports, module2) {
    "use strict";
    var Hoek = require_lib();
    var Topo = require_lib2();
    var internals = {};
    exports = module2.exports = internals.Ext = class {
      type = null;
      nodes = null;
      #core = null;
      #routes = [];
      #topo = new Topo.Sorter();
      constructor(type, core) {
        this.#core = core;
        this.type = type;
      }
      add(event) {
        const methods = [].concat(event.method);
        for (const method of methods) {
          const settings = {
            before: event.options.before,
            after: event.options.after,
            group: event.realm.plugin,
            sort: this.#core.extensionsSeq++
          };
          const node = {
            func: method,
            bind: event.options.bind,
            server: event.server,
            realm: event.realm,
            timeout: event.options.timeout
          };
          this.#topo.add(node, settings);
        }
        this.nodes = this.#topo.nodes;
        for (const route of this.#routes) {
          route.rebuild(event);
        }
      }
      merge(others) {
        const merge = [];
        for (const other of others) {
          merge.push(other.#topo);
        }
        this.#topo.merge(merge);
        this.nodes = this.#topo.nodes.length ? this.#topo.nodes : null;
      }
      subscribe(route) {
        this.#routes.push(route);
      }
      static combine(route, type) {
        const ext = new internals.Ext(type, route._core);
        const events = route.settings.ext[type];
        if (events) {
          for (let event of events) {
            event = Object.assign({}, event);
            Hoek.assert(!event.options.sandbox, "Cannot specify sandbox option for route extension");
            event.realm = route.realm;
            ext.add(event);
          }
        }
        const server3 = route._core.extensions.route[type];
        const realm = route.realm._extensions[type];
        ext.merge([server3, realm]);
        server3.subscribe(route);
        realm.subscribe(route);
        return ext;
      }
    };
  }
});

// node_modules/@hapi/hapi/lib/handler.js
var require_handler = __commonJS({
  "node_modules/@hapi/hapi/lib/handler.js"(exports) {
    "use strict";
    var Hoek = require_lib();
    var internals = {};
    exports.execute = async function(request) {
      if (request._route._prerequisites) {
        for (const set of request._route._prerequisites) {
          const pres = [];
          for (const item of set) {
            pres.push(internals.handler(request, item.method, item));
          }
          const responses = await Promise.all(pres);
          for (const response of responses) {
            if (response !== void 0) {
              return response;
            }
          }
        }
      }
      const result = await internals.handler(request, request.route.settings.handler);
      if (result._takeover || typeof result === "symbol") {
        return result;
      }
      request._setResponse(result);
    };
    internals.handler = async function(request, method, pre) {
      const bind = request.route.settings.bind;
      const realm = request.route.realm;
      let response = await request._core.toolkit.execute(method, request, { bind, realm, continue: "null" });
      if (!pre) {
        if (response.isBoom) {
          request._log(["handler", "error"], response);
          throw response;
        }
        return response;
      }
      if (response.isBoom) {
        response.assign = pre.assign;
        response = await request._core.toolkit.failAction(request, pre.failAction, response, { tags: ["pre", "error"], retain: true });
      }
      if (typeof response === "symbol") {
        return response;
      }
      if (pre.assign) {
        request.pre[pre.assign] = response.isBoom ? response : response.source;
        request.preResponses[pre.assign] = response;
      }
      if (response._takeover) {
        return response;
      }
    };
    exports.defaults = function(method, handler2, core) {
      let defaults = null;
      if (typeof handler2 === "object") {
        const type = Object.keys(handler2)[0];
        const serverHandler = core.decorations.handler.get(type);
        Hoek.assert(serverHandler, "Unknown handler:", type);
        if (serverHandler.defaults) {
          defaults = typeof serverHandler.defaults === "function" ? serverHandler.defaults(method) : serverHandler.defaults;
        }
      }
      return defaults || {};
    };
    exports.configure = function(handler2, route) {
      if (typeof handler2 === "object") {
        const type = Object.keys(handler2)[0];
        const serverHandler = route._core.decorations.handler.get(type);
        Hoek.assert(serverHandler, "Unknown handler:", type);
        return serverHandler(route.public, handler2[type]);
      }
      return handler2;
    };
    exports.prerequisitesConfig = function(config) {
      if (!config) {
        return null;
      }
      const prerequisites = [];
      for (let pres of config) {
        pres = [].concat(pres);
        const set = [];
        for (let pre of pres) {
          if (typeof pre !== "object") {
            pre = { method: pre };
          }
          const item = {
            method: pre.method,
            assign: pre.assign,
            failAction: pre.failAction || "error"
          };
          set.push(item);
        }
        prerequisites.push(set);
      }
      return prerequisites.length ? prerequisites : null;
    };
  }
});

// node_modules/@hapi/hapi/lib/headers.js
var require_headers = __commonJS({
  "node_modules/@hapi/hapi/lib/headers.js"(exports) {
    "use strict";
    var Stream = require("stream");
    var Boom = require_lib5();
    var internals = {};
    exports.cache = function(response) {
      const request = response.request;
      if (response.headers["cache-control"]) {
        return;
      }
      const settings = request.route.settings.cache;
      const policy = settings && request._route._cache && (settings._statuses.has(response.statusCode) || response.statusCode === 304 && settings._statuses.has(200));
      if (policy || response.settings.ttl) {
        const ttl = response.settings.ttl !== null ? response.settings.ttl : request._route._cache.ttl();
        const privacy = request.auth.isAuthenticated || response.headers["set-cookie"] ? "private" : settings.privacy || "default";
        response._header("cache-control", "max-age=" + Math.floor(ttl / 1e3) + ", must-revalidate" + (privacy !== "default" ? ", " + privacy : ""));
      } else if (settings) {
        response._header("cache-control", settings.otherwise);
      }
    };
    exports.content = async function(response) {
      const request = response.request;
      if (response._isPayloadSupported() || request.method === "head") {
        await response._marshal();
        if (request.jsonp && response._payload.jsonp) {
          response._header("content-type", "text/javascript" + (response.settings.charset ? "; charset=" + response.settings.charset : ""));
          response._header("x-content-type-options", "nosniff");
          response._payload.jsonp(request.jsonp);
        }
        if (response._payload.size && typeof response._payload.size === "function") {
          response._header("content-length", response._payload.size(), { override: false });
        }
        if (!response._isPayloadSupported()) {
          response._close();
          response._payload = new internals.Empty();
        }
        exports.type(response);
      } else {
        response._close();
        response._payload = new internals.Empty();
        delete response.headers["content-length"];
      }
    };
    exports.state = async function(response) {
      const request = response.request;
      const states = [];
      for (const stateName in request._states) {
        states.push(request._states[stateName]);
      }
      try {
        for (const name in request._core.states.cookies) {
          const autoValue = request._core.states.cookies[name].autoValue;
          if (!autoValue || name in request._states || name in request.state) {
            continue;
          }
          if (typeof autoValue !== "function") {
            states.push({ name, value: autoValue });
            continue;
          }
          const value = await autoValue(request);
          states.push({ name, value });
        }
        if (!states.length) {
          return;
        }
        let header = await request._core.states.format(states, request);
        const existing = response.headers["set-cookie"];
        if (existing) {
          header = (Array.isArray(existing) ? existing : [existing]).concat(header);
        }
        response._header("set-cookie", header);
      } catch (err) {
        const error = Boom.boomify(err);
        request._log(["state", "response", "error"], error);
        request._states = {};
        throw error;
      }
    };
    exports.type = function(response) {
      const type = response.contentType;
      if (type !== null && type !== response.headers["content-type"]) {
        response.type(type);
      }
    };
    exports.entity = function(response) {
      const request = response.request;
      if (!request._entity) {
        return;
      }
      if (request._entity.etag && !response.headers.etag) {
        response.etag(request._entity.etag, { vary: request._entity.vary });
      }
      if (request._entity.modified && !response.headers["last-modified"]) {
        response.header("last-modified", request._entity.modified);
      }
    };
    exports.unmodified = function(response) {
      const request = response.request;
      if (response.statusCode === 304) {
        return;
      }
      const entity = {
        etag: response.headers.etag,
        vary: response.settings.varyEtag,
        modified: response.headers["last-modified"]
      };
      const etag = request._core.Response.unmodified(request, entity);
      if (etag) {
        response.code(304);
        if (etag !== true) {
          response.headers.etag = etag;
        }
      }
    };
    internals.Empty = class extends Stream.Readable {
      _read() {
        this.push(null);
      }
      writeToStream(stream) {
        stream.end();
      }
    };
  }
});

// node_modules/@hapi/hapi/lib/security.js
var require_security = __commonJS({
  "node_modules/@hapi/hapi/lib/security.js"(exports) {
    "use strict";
    exports.route = function(settings) {
      if (!settings) {
        return null;
      }
      const security = settings;
      if (security.hsts) {
        if (security.hsts === true) {
          security._hsts = "max-age=15768000";
        } else if (typeof security.hsts === "number") {
          security._hsts = "max-age=" + security.hsts;
        } else {
          security._hsts = "max-age=" + (security.hsts.maxAge || 15768e3);
          if (security.hsts.includeSubdomains || security.hsts.includeSubDomains) {
            security._hsts = security._hsts + "; includeSubDomains";
          }
          if (security.hsts.preload) {
            security._hsts = security._hsts + "; preload";
          }
        }
      }
      if (security.xframe) {
        if (security.xframe === true) {
          security._xframe = "DENY";
        } else if (typeof security.xframe === "string") {
          security._xframe = security.xframe.toUpperCase();
        } else if (security.xframe.rule === "allow-from") {
          if (!security.xframe.source) {
            security._xframe = "SAMEORIGIN";
          } else {
            security._xframe = "ALLOW-FROM " + security.xframe.source;
          }
        } else {
          security._xframe = security.xframe.rule.toUpperCase();
        }
      }
      return security;
    };
    exports.headers = function(response) {
      const security = response.request.route.settings.security;
      if (security._hsts) {
        response._header("strict-transport-security", security._hsts, { override: false });
      }
      if (security._xframe) {
        response._header("x-frame-options", security._xframe, { override: false });
      }
      if (security.xss) {
        response._header("x-xss-protection", "1; mode=block", { override: false });
      }
      if (security.noOpen) {
        response._header("x-download-options", "noopen", { override: false });
      }
      if (security.noSniff) {
        response._header("x-content-type-options", "nosniff", { override: false });
      }
      if (security.referrer !== false) {
        response._header("referrer-policy", security.referrer, { override: false });
      }
    };
  }
});

// node_modules/@hapi/hapi/lib/streams.js
var require_streams = __commonJS({
  "node_modules/@hapi/hapi/lib/streams.js"(exports) {
    "use strict";
    var Boom = require_lib5();
    var Teamwork = require_lib8();
    var internals = {
      team: Symbol("team")
    };
    exports.isStream = function(stream) {
      if (!stream || typeof stream !== "object" || typeof stream.pipe !== "function") {
        return false;
      }
      if (typeof stream._read !== "function") {
        throw Boom.badImplementation("Stream must have a readable interface");
      }
      if (stream._readableState.objectMode) {
        throw Boom.badImplementation("Cannot reply with stream in object mode");
      }
      return true;
    };
    exports.drain = function(stream) {
      const team = new Teamwork.Team();
      stream[internals.team] = team;
      stream.on("readable", internals.read);
      stream.on("error", internals.end);
      stream.on("end", internals.end);
      stream.on("close", internals.end);
      return team.work;
    };
    internals.read = function() {
      while (this.read()) {
      }
    };
    internals.end = function() {
      this.removeListener("readable", internals.read);
      this.removeListener("error", internals.end);
      this.removeListener("end", internals.end);
      this.removeListener("close", internals.end);
      this[internals.team].attend();
    };
  }
});

// node_modules/@hapi/hapi/lib/validation.js
var require_validation = __commonJS({
  "node_modules/@hapi/hapi/lib/validation.js"(exports) {
    "use strict";
    var Boom = require_lib5();
    var Hoek = require_lib();
    var Validate = require_lib3();
    var internals = {};
    exports.validator = function(validator) {
      Hoek.assert(validator, "Missing validator");
      Hoek.assert(typeof validator.compile === "function", "Invalid validator compile method");
      return validator;
    };
    exports.compile = function(rule, validator, realm, core) {
      validator = validator || internals.validator(realm, core);
      if (rule === false) {
        return Validate.object({}).allow(null);
      }
      if (typeof rule === "function") {
        return rule;
      }
      if (!rule || rule === true) {
        return null;
      }
      if (typeof rule.validate === "function") {
        return rule;
      }
      Hoek.assert(validator, "Cannot set uncompiled validation rules without configuring a validator");
      return validator.compile(rule);
    };
    internals.validator = function(realm, core) {
      while (realm) {
        if (realm.validator) {
          return realm.validator;
        }
        realm = realm.parent;
      }
      return core.validator;
    };
    exports.headers = function(request) {
      return internals.input("headers", request);
    };
    exports.params = function(request) {
      return internals.input("params", request);
    };
    exports.payload = function(request) {
      if (request.method === "get" || request.method === "head") {
        return;
      }
      return internals.input("payload", request);
    };
    exports.query = function(request) {
      return internals.input("query", request);
    };
    exports.state = function(request) {
      return internals.input("state", request);
    };
    internals.input = async function(source, request) {
      const localOptions = {
        context: {
          headers: request.headers,
          params: request.params,
          query: request.query,
          payload: request.payload,
          state: request.state,
          auth: request.auth,
          app: {
            route: request.route.settings.app,
            request: request.app
          }
        }
      };
      delete localOptions.context[source];
      Hoek.merge(localOptions, request.route.settings.validate.options);
      try {
        const schema = request.route.settings.validate[source];
        const bind = request.route.settings.bind;
        var value = await (typeof schema !== "function" ? internals.validate(request[source], schema, localOptions) : schema.call(bind, request[source], localOptions));
        return;
      } catch (err) {
        var validationError = err;
      } finally {
        request.orig[source] = request[source];
        if (value !== void 0) {
          request[source] = value;
        }
      }
      if (request.route.settings.validate.failAction === "ignore") {
        return;
      }
      const defaultError = validationError.isBoom ? validationError : Boom.badRequest(`Invalid request ${source} input`);
      const detailedError = Boom.boomify(validationError, { statusCode: 400, override: false });
      detailedError.output.payload.validation = { source, keys: [] };
      if (validationError.details) {
        for (const details of validationError.details) {
          const path = details.path;
          detailedError.output.payload.validation.keys.push(Hoek.escapeHtml(path.join(".")));
        }
      }
      if (request.route.settings.validate.errorFields) {
        for (const field in request.route.settings.validate.errorFields) {
          detailedError.output.payload[field] = request.route.settings.validate.errorFields[field];
        }
      }
      return request._core.toolkit.failAction(request, request.route.settings.validate.failAction, defaultError, { details: detailedError, tags: ["validation", "error", source] });
    };
    exports.response = async function(request) {
      if (request.route.settings.response.sample) {
        const currentSample = Math.ceil(Math.random() * 100);
        if (currentSample > request.route.settings.response.sample) {
          return;
        }
      }
      const response = request.response;
      const statusCode = response.isBoom ? response.output.statusCode : response.statusCode;
      const statusSchema = request.route.settings.response.status[statusCode];
      if (statusCode >= 400 && !statusSchema) {
        return;
      }
      const schema = statusSchema !== void 0 ? statusSchema : request.route.settings.response.schema;
      if (schema === null) {
        return;
      }
      if (!response.isBoom && request.response.variety !== "plain") {
        throw Boom.badImplementation("Cannot validate non-object response");
      }
      const localOptions = {
        context: {
          headers: request.headers,
          params: request.params,
          query: request.query,
          payload: request.payload,
          state: request.state,
          auth: request.auth,
          app: {
            route: request.route.settings.app,
            request: request.app
          }
        }
      };
      const source = response.isBoom ? response.output.payload : response.source;
      Hoek.merge(localOptions, request.route.settings.response.options);
      try {
        let value;
        if (typeof schema !== "function") {
          value = await internals.validate(source, schema, localOptions);
        } else {
          value = await schema(source, localOptions);
        }
        if (value !== void 0 && request.route.settings.response.modify) {
          if (response.isBoom) {
            response.output.payload = value;
          } else {
            response.source = value;
          }
        }
      } catch (err) {
        return request._core.toolkit.failAction(request, request.route.settings.response.failAction, err, { tags: ["validation", "response", "error"] });
      }
    };
    internals.validate = function(value, schema, options) {
      if (typeof schema.validateAsync === "function") {
        return schema.validateAsync(value, options);
      }
      return schema.validate(value, options);
    };
  }
});

// node_modules/@hapi/hapi/lib/route.js
var require_route = __commonJS({
  "node_modules/@hapi/hapi/lib/route.js"(exports, module2) {
    "use strict";
    var Assert = require("assert");
    var Boom = require_lib5();
    var Bounce = require_lib6();
    var Catbox = require_lib11();
    var Hoek = require_lib();
    var Subtext = require_lib26();
    var Validate = require_lib3();
    var Auth = require_auth();
    var Config = require_config();
    var Cors = require_cors();
    var Ext = require_ext();
    var Handler = require_handler();
    var Headers = require_headers();
    var Security = require_security();
    var Streams = require_streams();
    var Validation = require_validation();
    var internals = {};
    exports = module2.exports = internals.Route = class {
      constructor(route, server3, options = {}) {
        const core = server3._core;
        const realm = server3.realm;
        Config.apply("route", route, route.method, route.path);
        const method = route.method.toLowerCase();
        Hoek.assert(method !== "head", "Cannot set HEAD route:", route.path);
        const path = realm.modifiers.route.prefix ? realm.modifiers.route.prefix + (route.path !== "/" ? route.path : "") : route.path;
        Hoek.assert(path === "/" || path[path.length - 1] !== "/" || !core.settings.router.stripTrailingSlash, "Path cannot end with a trailing slash when configured to strip:", route.method, route.path);
        const vhost = realm.modifiers.route.vhost || route.vhost;
        this.method = method;
        this.path = path;
        let config = route.options || route.config || {};
        if (typeof config === "function") {
          config = config.call(realm.settings.bind, server3);
        }
        config = Config.enable(config);
        this._assert(method !== "get" || !config.payload, "Cannot set payload settings on HEAD or GET request");
        this._assert(method !== "get" || !config.validate || !config.validate.payload, "Cannot validate HEAD or GET request payload");
        this._assert(!route.rules || !config.rules, "Route rules can only appear once");
        const rules = route.rules || config.rules;
        const rulesConfig = internals.rules(rules, { method, path, vhost }, server3);
        delete config.rules;
        this._assert(route.handler || config.handler, "Missing or undefined handler");
        this._assert(!!route.handler ^ !!config.handler, "Handler must only appear once");
        const handler2 = Config.apply("handler", route.handler || config.handler);
        delete config.handler;
        const handlerDefaults = Handler.defaults(method, handler2, core);
        const settings = internals.config([core.settings.routes, handlerDefaults, realm.settings, rulesConfig, config]);
        this.settings = Config.apply("routeConfig", settings, method, path);
        this._core = core;
        this.realm = realm;
        this.settings.vhost = vhost;
        this.settings.plugins = this.settings.plugins || {};
        this.settings.app = this.settings.app || {};
        this._special = !!options.special;
        this._analysis = this._core.router.analyze(this.path);
        this.params = this._analysis.params;
        this.fingerprint = this._analysis.fingerprint;
        this.public = {
          method: this.method,
          path: this.path,
          vhost,
          realm,
          settings: this.settings,
          fingerprint: this.fingerprint,
          auth: {
            access: (request) => Auth.testAccess(request, this.public)
          }
        };
        this._setupValidation();
        if (this.method === "get") {
          this.settings.payload = null;
        } else {
          this.settings.payload.decoders = this._core.compression.decoders;
        }
        this._assert(!this.settings.validate.payload || this.settings.payload.parse, "Route payload must be set to 'parse' when payload validation enabled");
        this._assert(!this.settings.validate.state || this.settings.state.parse, "Route state must be set to 'parse' when state validation enabled");
        this._assert(!this.settings.jsonp || typeof this.settings.jsonp === "string", "Bad route JSONP parameter name");
        this.settings.auth = this._special ? false : this._core.auth._setupRoute(this.settings.auth, path);
        if (this.method === "get" && typeof this.settings.cache === "object" && (this.settings.cache.expiresIn || this.settings.cache.expiresAt)) {
          this.settings.cache._statuses = new Set(this.settings.cache.statuses);
          this._cache = new Catbox.Policy({ expiresIn: this.settings.cache.expiresIn, expiresAt: this.settings.cache.expiresAt });
        }
        this.settings.cors = Cors.route(this.settings.cors);
        this.settings.security = Security.route(this.settings.security);
        this.settings.handler = Handler.configure(handler2, this);
        this._prerequisites = Handler.prerequisitesConfig(this.settings.pre);
        this._extensions = {
          onPreResponse: Ext.combine(this, "onPreResponse"),
          onPostResponse: Ext.combine(this, "onPostResponse")
        };
        if (this._special) {
          this._cycle = [internals.drain, Handler.execute];
          this.rebuild();
          return;
        }
        this._extensions.onPreAuth = Ext.combine(this, "onPreAuth");
        this._extensions.onCredentials = Ext.combine(this, "onCredentials");
        this._extensions.onPostAuth = Ext.combine(this, "onPostAuth");
        this._extensions.onPreHandler = Ext.combine(this, "onPreHandler");
        this._extensions.onPostHandler = Ext.combine(this, "onPostHandler");
        this.rebuild();
      }
      _setupValidation() {
        const validation = this.settings.validate;
        if (this.method === "get") {
          validation.payload = null;
        }
        this._assert(!validation.params || this.params.length, "Cannot set path parameters validations without path parameters");
        for (const type of ["headers", "params", "query", "payload", "state"]) {
          validation[type] = Validation.compile(validation[type], this.settings.validate.validator, this.realm, this._core);
        }
        if (this.settings.response.schema !== void 0 || this.settings.response.status) {
          this.settings.response._validate = true;
          const rule = this.settings.response.schema;
          this.settings.response.status = this.settings.response.status || {};
          const statuses = Object.keys(this.settings.response.status);
          if (rule === true && !statuses.length) {
            this.settings.response._validate = false;
          } else {
            this.settings.response.schema = Validation.compile(rule, this.settings.validate.validator, this.realm, this._core);
            for (const code of statuses) {
              this.settings.response.status[code] = Validation.compile(this.settings.response.status[code], this.settings.validate.validator, this.realm, this._core);
            }
          }
        }
      }
      rebuild(event) {
        if (event) {
          this._extensions[event.type].add(event);
        }
        if (this._special) {
          this._postCycle = this._extensions.onPreResponse.nodes ? [this._extensions.onPreResponse] : [];
          this._buildMarshalCycle();
          return;
        }
        this._cycle = [];
        if (this.settings.jsonp) {
          this._cycle.push(internals.parseJSONP);
        }
        if (this.settings.state.parse) {
          this._cycle.push(internals.state);
        }
        if (this._extensions.onPreAuth.nodes) {
          this._cycle.push(this._extensions.onPreAuth);
        }
        if (this._core.auth._enabled(this, "authenticate")) {
          this._cycle.push(Auth.authenticate);
        }
        if (this.method !== "get") {
          this._cycle.push(internals.payload);
          if (this._core.auth._enabled(this, "payload")) {
            this._cycle.push(Auth.payload);
          }
        }
        if (this._core.auth._enabled(this, "authenticate") && this._extensions.onCredentials.nodes) {
          this._cycle.push(this._extensions.onCredentials);
        }
        if (this._core.auth._enabled(this, "access")) {
          this._cycle.push(Auth.access);
        }
        if (this._extensions.onPostAuth.nodes) {
          this._cycle.push(this._extensions.onPostAuth);
        }
        if (this.settings.validate.headers) {
          this._cycle.push(Validation.headers);
        }
        if (this.settings.validate.params) {
          this._cycle.push(Validation.params);
        }
        if (this.settings.jsonp) {
          this._cycle.push(internals.cleanupJSONP);
        }
        if (this.settings.validate.query) {
          this._cycle.push(Validation.query);
        }
        if (this.settings.validate.payload) {
          this._cycle.push(Validation.payload);
        }
        if (this.settings.validate.state) {
          this._cycle.push(Validation.state);
        }
        if (this._extensions.onPreHandler.nodes) {
          this._cycle.push(this._extensions.onPreHandler);
        }
        this._cycle.push(Handler.execute);
        if (this._extensions.onPostHandler.nodes) {
          this._cycle.push(this._extensions.onPostHandler);
        }
        this._postCycle = [];
        if (this.settings.response._validate && this.settings.response.sample !== 0) {
          this._postCycle.push(Validation.response);
        }
        if (this._extensions.onPreResponse.nodes) {
          this._postCycle.push(this._extensions.onPreResponse);
        }
        this._buildMarshalCycle();
      }
      _buildMarshalCycle() {
        this._marshalCycle = [Headers.type];
        if (this.settings.cors) {
          this._marshalCycle.push(Cors.headers);
        }
        if (this.settings.security) {
          this._marshalCycle.push(Security.headers);
        }
        this._marshalCycle.push(Headers.entity);
        if (this.method === "get" || this.method === "*") {
          this._marshalCycle.push(Headers.unmodified);
        }
        this._marshalCycle.push(Headers.cache);
        this._marshalCycle.push(Headers.state);
        this._marshalCycle.push(Headers.content);
        if (this._core.auth._enabled(this, "response")) {
          this._marshalCycle.push(Auth.response);
        }
      }
      _assert(condition, message) {
        if (condition) {
          return;
        }
        if (this.method[0] !== "_") {
          message = `${message}: ${this.method.toUpperCase()} ${this.path}`;
        }
        throw new Assert.AssertionError({
          message,
          actual: false,
          expected: true,
          operator: "==",
          stackStartFunction: this._assert
        });
      }
    };
    internals.state = async function(request) {
      request.state = {};
      const req = request.raw.req;
      const cookies = req.headers.cookie;
      if (!cookies) {
        return;
      }
      try {
        var result = await request._core.states.parse(cookies);
      } catch (err) {
        Bounce.rethrow(err, "system");
        var parseError = err;
      }
      const { states, failed = [] } = result || parseError;
      request.state = states || {};
      for (const item of failed) {
        if (item.settings.clearInvalid) {
          request._clearState(item.name);
        }
      }
      if (!parseError) {
        return;
      }
      parseError.header = cookies;
      return request._core.toolkit.failAction(request, request.route.settings.state.failAction, parseError, { tags: ["state", "error"] });
    };
    internals.payload = async function(request) {
      if (request.method === "get" || request.method === "head") {
        return;
      }
      if (request._expectContinue) {
        request.raw.res.writeContinue();
      }
      if (request.payload !== void 0) {
        return internals.drain(request);
      }
      try {
        const { payload, mime } = await Subtext.parse(request.raw.req, request._tap(), request.route.settings.payload);
        request._isPayloadPending = !!(payload && payload._readableState);
        request.mime = mime;
        request.payload = payload;
      } catch (err) {
        Bounce.rethrow(err, "system");
        if (request._isPayloadPending) {
          await internals.drain(request);
        }
        request.mime = err.mime;
        request.payload = null;
        return request._core.toolkit.failAction(request, request.route.settings.payload.failAction, err, { tags: ["payload", "error"] });
      }
    };
    internals.drain = async function(request) {
      await Streams.drain(request.raw.req);
      request._isPayloadPending = false;
    };
    internals.jsonpRegex = /^[\w\$\[\]\.]+$/;
    internals.parseJSONP = function(request) {
      const jsonp = request.query[request.route.settings.jsonp];
      if (jsonp) {
        if (internals.jsonpRegex.test(jsonp) === false) {
          throw Boom.badRequest("Invalid JSONP parameter value");
        }
        request.jsonp = jsonp;
      }
    };
    internals.cleanupJSONP = function(request) {
      if (request.jsonp) {
        delete request.query[request.route.settings.jsonp];
      }
    };
    internals.config = function(chain) {
      if (!chain.length) {
        return {};
      }
      let config = chain[0];
      for (const item of chain) {
        config = Hoek.applyToDefaults(config, item, { shallow: ["bind", "validate.headers", "validate.payload", "validate.params", "validate.query", "validate.state"] });
      }
      return config;
    };
    internals.rules = function(rules, info, server3) {
      const configs = [];
      let realm = server3.realm;
      while (realm) {
        if (realm._rules) {
          const source = !realm._rules.settings.validate ? rules : Validate.attempt(rules, realm._rules.settings.validate.schema, realm._rules.settings.validate.options);
          const config = realm._rules.processor(source, info);
          if (config) {
            configs.unshift(config);
          }
        }
        realm = realm.parent;
      }
      return internals.config(configs);
    };
  }
});

// node_modules/@hapi/hapi/lib/cors.js
var require_cors = __commonJS({
  "node_modules/@hapi/hapi/lib/cors.js"(exports) {
    "use strict";
    var Boom = require_lib5();
    var Hoek = require_lib();
    var Route = null;
    var internals = {};
    exports.route = function(options) {
      if (!options) {
        return false;
      }
      const settings = Hoek.clone(options);
      settings._headers = settings.headers.concat(settings.additionalHeaders);
      settings._headersString = settings._headers.join(",");
      for (let i = 0; i < settings._headers.length; ++i) {
        settings._headers[i] = settings._headers[i].toLowerCase();
      }
      if (settings._headers.indexOf("origin") === -1) {
        settings._headers.push("origin");
      }
      settings._exposedHeaders = settings.exposedHeaders.concat(settings.additionalExposedHeaders).join(",");
      if (settings.origin === "ignore") {
        settings._origin = false;
      } else if (settings.origin.indexOf("*") !== -1) {
        Hoek.assert(settings.origin.length === 1, "Cannot specify cors.origin * together with other values");
        settings._origin = true;
      } else {
        settings._origin = {
          qualified: [],
          wildcards: []
        };
        for (const origin of settings.origin) {
          if (origin.indexOf("*") !== -1) {
            settings._origin.wildcards.push(new RegExp("^" + Hoek.escapeRegex(origin).replace(/\\\*/g, ".*").replace(/\\\?/g, ".") + "$"));
          } else {
            settings._origin.qualified.push(origin);
          }
        }
      }
      return settings;
    };
    exports.options = function(route, server3) {
      if (route.method === "options" || !route.settings.cors) {
        return;
      }
      exports.handler(server3);
    };
    exports.handler = function(server3) {
      Route = Route || require_route();
      if (server3._core.router.specials.options) {
        return;
      }
      const definition = {
        method: "_special",
        path: "/{p*}",
        handler: internals.handler,
        options: {
          cors: false
        }
      };
      const route = new Route(definition, server3, { special: true });
      server3._core.router.special("options", route);
    };
    internals.handler = function(request, h) {
      const method = request.headers["access-control-request-method"];
      if (!method) {
        throw Boom.notFound("CORS error: Missing Access-Control-Request-Method header");
      }
      const route = request.server.match(method, request.path, request.info.hostname);
      if (!route) {
        throw Boom.notFound();
      }
      const settings = route.settings.cors;
      if (!settings) {
        return { message: "CORS is disabled for this route" };
      }
      const origin = request.headers.origin;
      if (!origin && settings._origin !== false) {
        throw Boom.notFound("CORS error: Missing Origin header");
      }
      if (!exports.matchOrigin(origin, settings)) {
        return { message: "CORS error: Origin not allowed" };
      }
      let headers = request.headers["access-control-request-headers"];
      if (headers) {
        headers = headers.toLowerCase().split(/\s*,\s*/);
        if (Hoek.intersect(headers, settings._headers).length !== headers.length) {
          return { message: "CORS error: Some headers are not allowed" };
        }
      }
      const response = h.response();
      response._header("access-control-allow-origin", settings._origin ? origin : "*");
      response._header("access-control-allow-methods", method);
      response._header("access-control-allow-headers", settings._headersString);
      response._header("access-control-max-age", settings.maxAge);
      if (settings.credentials) {
        response._header("access-control-allow-credentials", "true");
      }
      if (settings._exposedHeaders) {
        response._header("access-control-expose-headers", settings._exposedHeaders);
      }
      return response;
    };
    exports.headers = function(response) {
      const request = response.request;
      const settings = request.route.settings.cors;
      if (settings._origin !== false) {
        response.vary("origin");
      }
      if (request.info.cors && !request.info.cors.isOriginMatch || !exports.matchOrigin(request.headers.origin, request.route.settings.cors)) {
        return;
      }
      response._header("access-control-allow-origin", settings._origin ? request.headers.origin : "*");
      if (settings.credentials) {
        response._header("access-control-allow-credentials", "true");
      }
      if (settings._exposedHeaders) {
        response._header("access-control-expose-headers", settings._exposedHeaders, { append: true });
      }
    };
    exports.matchOrigin = function(origin, settings) {
      if (settings._origin === true || settings._origin === false) {
        return true;
      }
      if (!origin) {
        return false;
      }
      if (settings._origin.qualified.indexOf(origin) !== -1) {
        return true;
      }
      for (const wildcard of settings._origin.wildcards) {
        if (origin.match(wildcard)) {
          return true;
        }
      }
      return false;
    };
  }
});

// node_modules/@hapi/hapi/lib/toolkit.js
var require_toolkit = __commonJS({
  "node_modules/@hapi/hapi/lib/toolkit.js"(exports) {
    "use strict";
    var Boom = require_lib5();
    var Bounce = require_lib6();
    var Hoek = require_lib();
    var internals = {};
    exports.reserved = [
      "abandon",
      "authenticated",
      "close",
      "context",
      "continue",
      "entity",
      "redirect",
      "realm",
      "request",
      "response",
      "state",
      "unauthenticated",
      "unstate"
    ];
    exports.symbols = {
      abandon: Symbol("abandon"),
      close: Symbol("close"),
      continue: Symbol("continue")
    };
    exports.Manager = class {
      constructor() {
        this._toolkit = internals.toolkit();
      }
      async execute(method, request, options) {
        const h = new this._toolkit(request, options);
        const bind = options.bind || null;
        try {
          let operation;
          if (bind) {
            operation = method.call(bind, request, h);
          } else if (options.args) {
            operation = method(request, h, ...options.args);
          } else {
            operation = method(request, h);
          }
          var response = await exports.timed(operation, options);
        } catch (err) {
          if (Bounce.isSystem(err)) {
            response = Boom.badImplementation(err);
          } else if (!Bounce.isError(err)) {
            response = Boom.badImplementation("Cannot throw non-error object", err);
          } else {
            response = Boom.boomify(err);
          }
        }
        if (options.ignoreResponse) {
          return response;
        }
        if (response === void 0) {
          response = Boom.badImplementation(`${method.name} method did not return a value, a promise, or throw an error`);
        }
        if (options.continue && response === exports.symbols.continue) {
          if (options.continue === "undefined") {
            return;
          }
          response = null;
        }
        if (options.auth && response instanceof internals.Auth) {
          return response;
        }
        if (typeof response !== "symbol") {
          response = request._core.Response.wrap(response, request);
          if (!response.isBoom && response._state === "init") {
            response = await response._prepare();
          }
        }
        return response;
      }
      decorate(name, method) {
        this._toolkit.prototype[name] = method;
      }
      failAction(request, failAction, err, options) {
        const retain = options.retain ? err : void 0;
        if (failAction === "ignore") {
          return retain;
        }
        if (failAction === "log") {
          request._log(options.tags, err);
          return retain;
        }
        if (failAction === "error") {
          throw err;
        }
        return this.execute(failAction, request, { realm: request.route.realm, args: [options.details || err] });
      }
    };
    exports.timed = function(method, options) {
      if (!options.timeout) {
        return method;
      }
      const timer = new Promise((resolve, reject) => {
        const handler2 = () => {
          reject(Boom.internal(`${options.name} timed out`));
        };
        setTimeout(handler2, options.timeout);
      });
      return Promise.race([timer, method]);
    };
    internals.toolkit = function() {
      const Toolkit = class {
        constructor(request, options) {
          this.context = options.bind;
          this.realm = options.realm;
          this.request = request;
          this._auth = options.auth;
        }
        response(result) {
          Hoek.assert(!result || typeof result !== "object" || typeof result.then !== "function", "Cannot wrap a promise");
          Hoek.assert(result instanceof Error === false, "Cannot wrap an error");
          Hoek.assert(typeof result !== "symbol", "Cannot wrap a symbol");
          return this.request._core.Response.wrap(result, this.request);
        }
        redirect(location) {
          return this.response("").redirect(location);
        }
        entity(options) {
          Hoek.assert(options, "Entity method missing required options");
          Hoek.assert(options.etag || options.modified, "Entity methods missing required options key");
          this.request._entity = options;
          const entity = this.request._core.Response.entity(options.etag, options);
          if (this.request._core.Response.unmodified(this.request, entity)) {
            return this.response().code(304).takeover();
          }
        }
        state(name, value, options) {
          this.request._setState(name, value, options);
        }
        unstate(name, options) {
          this.request._clearState(name, options);
        }
        authenticated(data) {
          Hoek.assert(this._auth, "Method not supported outside of authentication");
          Hoek.assert(data && data.credentials, "Authentication data missing credentials information");
          return new internals.Auth(null, data);
        }
        unauthenticated(error, data) {
          Hoek.assert(this._auth, "Method not supported outside of authentication");
          Hoek.assert(!data || data.credentials, "Authentication data missing credentials information");
          return new internals.Auth(error, data);
        }
      };
      Toolkit.prototype.abandon = exports.symbols.abandon;
      Toolkit.prototype.close = exports.symbols.close;
      Toolkit.prototype.continue = exports.symbols.continue;
      return Toolkit;
    };
    internals.Auth = class {
      constructor(error, data) {
        this.isAuth = true;
        this.error = error;
        this.data = data;
      }
    };
  }
});

// node_modules/@hapi/ammo/lib/index.js
var require_lib27 = __commonJS({
  "node_modules/@hapi/ammo/lib/index.js"(exports) {
    "use strict";
    var Stream = require("stream");
    var Hoek = require_lib();
    var internals = {};
    internals.headerRx = /^bytes=[\s,]*((?:(?:\d+\-\d*)|(?:\-\d+))(?:\s*,\s*(?:(?:\d+\-\d*)|(?:\-\d+)))*)$/i;
    exports.header = function(header, length) {
      const parts = internals.headerRx.exec(header);
      if (!parts) {
        return null;
      }
      const lastPos = length - 1;
      const result = [];
      const ranges = parts[1].match(/\d*\-\d*/g);
      for (let range of ranges) {
        let from;
        let to;
        range = range.split("-");
        if (range[0]) {
          from = parseInt(range[0], 10);
        }
        if (range[1]) {
          to = parseInt(range[1], 10);
          if (from !== void 0) {
            if (to > lastPos) {
              to = lastPos;
            }
          } else {
            from = length - to;
            to = lastPos;
          }
        } else {
          to = lastPos;
        }
        if (from > to) {
          return null;
        }
        result.push(new internals.Range(from, to));
      }
      if (result.length === 1) {
        return result;
      }
      result.sort((a, b) => a.from - b.from);
      const consolidated = [];
      for (let i = result.length - 1; i > 0; --i) {
        const current = result[i];
        const before = result[i - 1];
        if (current.from <= before.to + 1) {
          before.to = current.to;
        } else {
          consolidated.unshift(current);
        }
      }
      consolidated.unshift(result[0]);
      return consolidated;
    };
    internals.Range = class {
      constructor(from, to) {
        this.from = from;
        this.to = to;
      }
    };
    exports.Clip = class extends Stream.Transform {
      constructor(range) {
        if (!(range instanceof internals.Range)) {
          Hoek.assert(typeof range === "object", 'Expected "range" object');
          const from = range.from || 0;
          Hoek.assert(typeof from === "number", '"range.from" must be falsy, or a number');
          Hoek.assert(from === parseInt(from, 10) && from >= 0, '"range.from" must be a positive integer');
          const to = range.to || 0;
          Hoek.assert(typeof to === "number", '"range.to" must be falsy, or a number');
          Hoek.assert(to === parseInt(to, 10) && to >= 0, '"range.to" must be a positive integer');
          Hoek.assert(to >= from, '"range.to" must be greater than or equal to "range.from"');
          range = new internals.Range(from, to);
        }
        super();
        this._range = range;
        this._next = 0;
        this._pipes = /* @__PURE__ */ new Set();
        this.on("pipe", (pipe) => this._pipes.add(pipe));
        this.on("unpipe", (pipe) => this._pipes.delete(pipe));
      }
      _transform(chunk, encoding, done) {
        try {
          internals.processChunk(this, chunk);
        } catch (err) {
          return done(err);
        }
        return done();
      }
      _flush(done) {
        this._pipes.clear();
        done();
      }
    };
    internals.processChunk = function(stream, chunk) {
      const pos = stream._next;
      stream._next = stream._next + chunk.length;
      if (stream._next <= stream._range.from) {
        return;
      }
      if (pos > stream._range.to) {
        for (const pipe of stream._pipes) {
          pipe.unpipe(stream);
        }
        stream._pipes.clear();
        stream.end();
        return;
      }
      const from = Math.max(0, stream._range.from - pos);
      const to = Math.min(chunk.length, stream._range.to - pos + 1);
      stream.push(chunk.slice(from, to));
    };
  }
});

// node_modules/@hapi/hapi/lib/transmit.js
var require_transmit = __commonJS({
  "node_modules/@hapi/hapi/lib/transmit.js"(exports) {
    "use strict";
    var Http = require("http");
    var Ammo = require_lib27();
    var Boom = require_lib5();
    var Bounce = require_lib6();
    var Hoek = require_lib();
    var Teamwork = require_lib8();
    var Config = require_config();
    var internals = {};
    exports.send = async function(request) {
      const response = request.response;
      try {
        if (response.isBoom) {
          await internals.fail(request, response);
          return;
        }
        await internals.marshal(response);
        await internals.transmit(response);
      } catch (err) {
        Bounce.rethrow(err, "system");
        request._setResponse(err);
        return internals.fail(request, err);
      }
    };
    internals.marshal = async function(response) {
      for (const func of response.request._route._marshalCycle) {
        await func(response);
      }
    };
    internals.fail = async function(request, boom) {
      const response = internals.error(request, boom);
      request.response = response;
      try {
        await internals.marshal(response);
      } catch (err) {
        Bounce.rethrow(err, "system");
        const minimal = {
          statusCode: response.statusCode,
          error: Http.STATUS_CODES[response.statusCode],
          message: boom.message
        };
        response._payload = new request._core.Response.Payload(JSON.stringify(minimal), {});
      }
      return internals.transmit(response);
    };
    internals.error = function(request, boom) {
      const error = boom.output;
      const response = new request._core.Response(error.payload, request, { error: boom });
      response.code(error.statusCode);
      response.headers = Hoek.clone(error.headers);
      return response;
    };
    internals.transmit = function(response) {
      const request = response.request;
      const length = internals.length(response);
      const encoding = request._core.compression.encoding(response, length);
      const ranger = encoding ? null : internals.range(response, length);
      const compressor = internals.encoding(response, encoding);
      const isInjection = request.isInjected;
      if (!(isInjection || request._core.started) || request._isPayloadPending && !request.raw.req._readableState.ended) {
        response._header("connection", "close");
      }
      internals.writeHead(response);
      if (isInjection) {
        request.raw.res[Config.symbol] = { request };
        if (response.variety === "plain") {
          request.raw.res[Config.symbol].result = response._isPayloadSupported() ? response.source : null;
        }
      }
      const stream = internals.chain([response._payload, response._tap(), compressor, ranger]);
      return internals.pipe(request, stream);
    };
    internals.length = function(response) {
      const request = response.request;
      const header = response.headers["content-length"];
      if (header === void 0) {
        return null;
      }
      let length = header;
      if (typeof length === "string") {
        length = parseInt(header, 10);
        if (!isFinite(length)) {
          delete response.headers["content-length"];
          return null;
        }
      }
      if (length === 0 && !response._statusCode && response.statusCode === 200 && request.route.settings.response.emptyStatusCode !== 200) {
        response.code(204);
        delete response.headers["content-length"];
      }
      return length;
    };
    internals.range = function(response, length) {
      const request = response.request;
      if (!length || !request.route.settings.response.ranges || request.method !== "get" || response.statusCode !== 200) {
        return null;
      }
      response._header("accept-ranges", "bytes");
      if (!request.headers.range) {
        return null;
      }
      if (request.headers["if-range"] && request.headers["if-range"] !== response.headers.etag) {
        return null;
      }
      const ranges = Ammo.header(request.headers.range, length);
      if (!ranges) {
        const error = Boom.rangeNotSatisfiable();
        error.output.headers["content-range"] = "bytes */" + length;
        throw error;
      }
      if (ranges.length !== 1) {
        return null;
      }
      const range = ranges[0];
      response.code(206);
      response.bytes(range.to - range.from + 1);
      response._header("content-range", "bytes " + range.from + "-" + range.to + "/" + length);
      return new Ammo.Clip(range);
    };
    internals.encoding = function(response, encoding) {
      const request = response.request;
      const header = response.headers["content-encoding"] || encoding;
      if (header && response.headers.etag && response.settings.varyEtag) {
        response.headers.etag = response.headers.etag.slice(0, -1) + "-" + header + '"';
      }
      if (!encoding || response.statusCode === 206 || !response._isPayloadSupported()) {
        return null;
      }
      delete response.headers["content-length"];
      response._header("content-encoding", encoding);
      const compressor = request._core.compression.encoder(request, encoding);
      if (response.variety === "stream" && typeof response._payload.setCompressor === "function") {
        response._payload.setCompressor(compressor);
      }
      return compressor;
    };
    internals.pipe = function(request, stream) {
      const team = new Teamwork.Team();
      const env = { stream, request, team };
      if (request._closed) {
        internals.end(env, "aborted");
        return team.work;
      }
      const aborted = internals.end.bind(null, env, "aborted");
      const close = internals.end.bind(null, env, "close");
      const end = internals.end.bind(null, env, null);
      request.raw.req.on("aborted", aborted);
      request.raw.res.on("close", close);
      request.raw.res.on("error", end);
      request.raw.res.on("finish", end);
      if (stream.writeToStream) {
        stream.writeToStream(request.raw.res);
      } else {
        stream.on("error", end);
        stream.pipe(request.raw.res);
      }
      return team.work;
    };
    internals.end = function(env, event, err) {
      const { request, stream, team } = env;
      if (!team) {
        return;
      }
      env.team = null;
      if (request.raw.res.finished) {
        if (!event) {
          request.info.responded = Date.now();
        }
        team.attend();
        return;
      }
      if (err) {
        request.raw.res.destroy();
        request._core.Response.drain(stream);
      }
      const origResponse = request.response;
      const error = err ? Boom.boomify(err) : new Boom.Boom(`Request ${event}`, { statusCode: request.route.settings.response.disconnectStatusCode, data: origResponse });
      request._setResponse(error);
      if (request.raw.res[Config.symbol]) {
        request.raw.res[Config.symbol].error = event ? error : new Boom.Boom(`Response error`, { statusCode: request.route.settings.response.disconnectStatusCode, data: origResponse });
      }
      if (event) {
        request._log(["response", "error", event]);
      } else {
        request._log(["response", "error"], err);
      }
      request.raw.res.end();
      team.attend();
    };
    internals.writeHead = function(response) {
      const res = response.request.raw.res;
      const headers = Object.keys(response.headers);
      let i = 0;
      try {
        for (; i < headers.length; ++i) {
          const header = headers[i];
          const value = response.headers[header];
          if (value !== void 0) {
            res.setHeader(header, value);
          }
        }
      } catch (err) {
        for (--i; i >= 0; --i) {
          res.removeHeader(headers[i]);
        }
        throw Boom.boomify(err);
      }
      if (response.settings.message) {
        res.statusMessage = response.settings.message;
      }
      try {
        res.writeHead(response.statusCode);
      } catch (err) {
        throw Boom.boomify(err);
      }
    };
    internals.chain = function(sources) {
      let from = sources[0];
      for (let i = 1; i < sources.length; ++i) {
        const to = sources[i];
        if (to) {
          from.on("error", internals.errorPipe.bind(from, to));
          from = from.pipe(to);
        }
      }
      return from;
    };
    internals.errorPipe = function(to, err) {
      to.emit("error", err);
    };
  }
});

// node_modules/@hapi/hapi/lib/request.js
var require_request2 = __commonJS({
  "node_modules/@hapi/hapi/lib/request.js"(exports, module2) {
    "use strict";
    var Querystring = require("querystring");
    var Url = require("url");
    var Boom = require_lib5();
    var Bounce = require_lib6();
    var Hoek = require_lib();
    var Podium = require_lib10();
    var Cors = require_cors();
    var Toolkit = require_toolkit();
    var Transmit = require_transmit();
    var internals = {
      events: Podium.validate(["finish", { name: "peek", spread: true }, "disconnect"]),
      reserved: ["server", "url", "query", "path", "method", "mime", "setUrl", "setMethod", "headers", "id", "app", "plugins", "route", "auth", "pre", "preResponses", "info", "isInjected", "orig", "params", "paramsArray", "payload", "state", "jsonp", "response", "raw", "domain", "log", "logs", "generateResponse"]
    };
    exports = module2.exports = internals.Request = class {
      constructor(server3, req, res, options) {
        this._allowInternals = !!options.allowInternals;
        this._closed = false;
        this._core = server3._core;
        this._entity = null;
        this._eventContext = { request: this };
        this._events = null;
        this._expectContinue = !!options.expectContinue;
        this._isInjected = !!options.isInjected;
        this._isPayloadPending = !!(req.headers["content-length"] || req.headers["transfer-encoding"]);
        this._isReplied = false;
        this._route = this._core.router.specials.notFound.route;
        this._serverTimeoutId = null;
        this._states = {};
        this._url = null;
        this._urlError = null;
        this.app = options.app ? Object.assign({}, options.app) : {};
        this.headers = req.headers;
        this.jsonp = null;
        this.logs = [];
        this.method = req.method.toLowerCase();
        this.mime = null;
        this.orig = {};
        this.params = null;
        this.paramsArray = null;
        this.path = null;
        this.payload = void 0;
        this.plugins = options.plugins ? Object.assign({}, options.plugins) : {};
        this.pre = {};
        this.preResponses = {};
        this.raw = { req, res };
        this.response = null;
        this.route = this._route.public;
        this.query = null;
        this.server = server3;
        this.state = null;
        this.info = new internals.Info(this);
        this.auth = {
          isAuthenticated: false,
          isAuthorized: false,
          isInjected: options.auth ? true : false,
          [internals.Request.symbols.authPayload]: options.auth && options.auth.payload !== void 0 ? options.auth.payload : true,
          credentials: options.auth ? options.auth.credentials : null,
          artifacts: options.auth && options.auth.artifacts || null,
          strategy: options.auth ? options.auth.strategy : null,
          mode: null,
          error: null
        };
        this._initializeUrl();
      }
      static generate(server3, req, res, options) {
        const request = new server3._core.Request(server3, req, res, options);
        if (server3._core.decorations.requestApply) {
          for (const [property, assignment] of server3._core.decorations.requestApply.entries()) {
            request[property] = assignment(request);
          }
        }
        request._listen();
        return request;
      }
      get events() {
        if (!this._events) {
          this._events = new Podium(internals.events);
        }
        return this._events;
      }
      get isInjected() {
        return this._isInjected;
      }
      get url() {
        if (this._urlError) {
          return null;
        }
        if (this._url) {
          return this._url;
        }
        return this._parseUrl(this.raw.req.url, this._core.settings.router);
      }
      _initializeUrl() {
        try {
          this._setUrl(this.raw.req.url, this._core.settings.router.stripTrailingSlash, { fast: true });
        } catch (err) {
          this.path = this.raw.req.url;
          this.query = {};
          this._urlError = Boom.boomify(err, { statusCode: 400, override: false });
        }
      }
      setUrl(url, stripTrailingSlash) {
        Hoek.assert(this.params === null, "Cannot change request URL after routing");
        if (url instanceof Url.URL) {
          url = url.href;
        }
        Hoek.assert(typeof url === "string", "Url must be a string or URL object");
        this._setUrl(url, stripTrailingSlash, { fast: false });
      }
      _setUrl(source, stripTrailingSlash, { fast }) {
        const url = this._parseUrl(source, { stripTrailingSlash, _fast: fast });
        this.query = this._parseQuery(url.searchParams);
        this.path = url.pathname;
      }
      _parseUrl(source, options) {
        if (source[0] === "/") {
          if (options._fast) {
            const url = {
              pathname: source,
              searchParams: ""
            };
            const q = source.indexOf("?");
            const h = source.indexOf("#");
            if (q !== -1 && (h === -1 || q < h)) {
              url.pathname = source.slice(0, q);
              const query = h === -1 ? source.slice(q + 1) : source.slice(q + 1, h);
              url.searchParams = Querystring.parse(query);
            } else {
              url.pathname = h === -1 ? source : source.slice(0, h);
            }
            this._normalizePath(url, options);
            return url;
          }
          this._url = new Url.URL(`${this._core.info.protocol}://${this.info.host || `${this._core.info.host}:${this._core.info.port}`}${source}`);
        } else {
          this._url = new Url.URL(source);
          this.info.hostname = this._url.hostname;
          this.info.host = this._url.host;
        }
        this._normalizePath(this._url, options);
        this._urlError = null;
        return this._url;
      }
      _normalizePath(url, options) {
        let path = this._core.router.normalize(url.pathname);
        if (options.stripTrailingSlash && path.length > 1 && path[path.length - 1] === "/") {
          path = path.slice(0, -1);
        }
        url.pathname = path;
      }
      _parseQuery(searchParams) {
        let query = /* @__PURE__ */ Object.create(null);
        if (searchParams instanceof Url.URLSearchParams) {
          for (let [key, value] of searchParams) {
            const entry = query[key];
            if (entry !== void 0) {
              value = [].concat(entry, value);
            }
            query[key] = value;
          }
        } else {
          query = Object.assign(query, searchParams);
        }
        const parser = this._core.settings.query.parser;
        if (parser) {
          query = parser(query);
          if (!query || typeof query !== "object") {
            throw Boom.badImplementation("Parsed query must be an object");
          }
        }
        return query;
      }
      setMethod(method) {
        Hoek.assert(this.params === null, "Cannot change request method after routing");
        Hoek.assert(method && typeof method === "string", "Missing method");
        this.method = method.toLowerCase();
      }
      active() {
        return !!this._eventContext.request;
      }
      async _execute() {
        this.info.acceptEncoding = this._core.compression.accept(this);
        try {
          await this._onRequest();
        } catch (err) {
          Bounce.rethrow(err, "system");
          return this._reply(err);
        }
        this._lookup();
        this._setTimeouts();
        await this._lifecycle();
        this._reply();
      }
      async _onRequest() {
        if (this._core.extensions.route.onRequest.nodes) {
          const response = await this._invoke(this._core.extensions.route.onRequest);
          if (response) {
            if (!internals.skip(response)) {
              throw Boom.badImplementation("onRequest extension methods must return an error, a takeover response, or a continue signal");
            }
            throw response;
          }
        }
        if (this._urlError) {
          throw this._urlError;
        }
      }
      _listen() {
        if (this._isPayloadPending) {
          this.raw.req.on("end", internals.event.bind(this.raw.req, this._eventContext, "end"));
        }
        this.raw.res.on("close", internals.event.bind(this.raw.res, this._eventContext, "close"));
        this.raw.req.on("error", internals.event.bind(this.raw.req, this._eventContext, "error"));
        this.raw.req.on("aborted", internals.event.bind(this.raw.req, this._eventContext, "abort"));
        this.raw.res.once("close", internals.closed.bind(this.raw.res, this));
      }
      _lookup() {
        const match = this._core.router.route(this.method, this.path, this.info.hostname);
        if (!match.route.settings.isInternal || this._allowInternals) {
          this._route = match.route;
          this.route = this._route.public;
        }
        this.params = match.params || {};
        this.paramsArray = match.paramsArray || [];
        if (this.route.settings.cors) {
          this.info.cors = {
            isOriginMatch: Cors.matchOrigin(this.headers.origin, this.route.settings.cors)
          };
        }
      }
      _setTimeouts() {
        if (this.raw.req.socket && this.route.settings.timeout.socket !== void 0) {
          this.raw.req.socket.setTimeout(this.route.settings.timeout.socket || 0);
        }
        let serverTimeout = this.route.settings.timeout.server;
        if (!serverTimeout) {
          return;
        }
        const elapsed = Date.now() - this.info.received;
        serverTimeout = Math.floor(serverTimeout - elapsed);
        if (serverTimeout <= 0) {
          internals.timeoutReply(this, serverTimeout);
          return;
        }
        this._serverTimeoutId = setTimeout(internals.timeoutReply, serverTimeout, this, serverTimeout);
      }
      async _lifecycle() {
        for (const func of this._route._cycle) {
          if (this._isReplied) {
            return;
          }
          try {
            var response = await (typeof func === "function" ? func(this) : this._invoke(func));
          } catch (err) {
            Bounce.rethrow(err, "system");
            response = this._core.Response.wrap(err, this);
          }
          if (!response || response === Toolkit.symbols.continue) {
            continue;
          }
          if (!internals.skip(response)) {
            response = Boom.badImplementation("Lifecycle methods called before the handler can only return an error, a takeover response, or a continue signal");
          }
          this._setResponse(response);
          return;
        }
      }
      async _invoke(event, options = {}) {
        for (const ext of event.nodes) {
          const realm = ext.realm;
          const bind = ext.bind || realm.settings.bind;
          const response = await this._core.toolkit.execute(ext.func, this, { bind, realm, timeout: ext.timeout, name: event.type, ignoreResponse: options.ignoreResponse });
          if (options.ignoreResponse) {
            if (Boom.isBoom(response)) {
              this._log(["ext", "error"], response);
            }
            continue;
          }
          if (response === Toolkit.symbols.continue) {
            continue;
          }
          if (internals.skip(response) || this.response === null) {
            return response;
          }
          this._setResponse(response);
        }
      }
      async _reply(exit) {
        if (this._isReplied) {
          return;
        }
        this._isReplied = true;
        if (this._serverTimeoutId) {
          clearTimeout(this._serverTimeoutId);
        }
        if (exit) {
          this._setResponse(this._core.Response.wrap(exit, this));
        }
        if (!this._eventContext.request) {
          this._finalize();
          return;
        }
        if (typeof this.response === "symbol") {
          this._abort();
          return;
        }
        await this._postCycle();
        if (!this._eventContext.request || typeof this.response === "symbol") {
          this._abort();
          return;
        }
        await Transmit.send(this);
        this._finalize();
      }
      async _postCycle() {
        for (const func of this._route._postCycle) {
          if (!this._eventContext.request) {
            return;
          }
          try {
            var response = await (typeof func === "function" ? func(this) : this._invoke(func));
          } catch (err) {
            Bounce.rethrow(err, "system");
            response = this._core.Response.wrap(err, this);
          }
          if (response && response !== Toolkit.symbols.continue) {
            this._setResponse(response);
          }
        }
      }
      _abort() {
        if (this.response === Toolkit.symbols.close) {
          this.raw.res.end();
        }
        this._finalize();
      }
      _finalize() {
        this._eventContext.request = null;
        if (!Boom.isBoom(this.response)) {
          if (this.response.statusCode === 500 && this.response._error) {
            const tags = this.response._error.isDeveloperError ? ["internal", "implementation", "error"] : ["internal", "error"];
            this._log(tags, this.response._error, "error");
          }
          if (this.response._close) {
            this.response._close();
          }
        }
        this.info.completed = Date.now();
        this._core.events.emit("response", this);
        if (this._route._extensions.onPostResponse.nodes) {
          this._invoke(this._route._extensions.onPostResponse, { ignoreResponse: true });
        }
      }
      _setResponse(response) {
        if (this.response && !this.response.isBoom && this.response !== response && this.response.source !== response.source) {
          this.response._close();
        }
        if (this.info.completed) {
          if (response._close) {
            response._close();
          }
          return;
        }
        this.response = response;
      }
      _setState(name, value, options) {
        const state = { name, value };
        if (options) {
          Hoek.assert(!options.autoValue, "Cannot set autoValue directly in a response");
          state.options = Hoek.clone(options);
        }
        this._states[name] = state;
      }
      _clearState(name, options = {}) {
        const state = { name };
        state.options = Hoek.clone(options);
        state.options.ttl = 0;
        this._states[name] = state;
      }
      _tap() {
        if (!this._events) {
          return null;
        }
        if (this._events.hasListeners("peek") || this._events.hasListeners("finish")) {
          return new this._core.Response.Peek(this._events);
        }
        return null;
      }
      log(tags, data) {
        return this._log(tags, data, "app");
      }
      _log(tags, data, channel = "internal") {
        if (!this._core.events.hasListeners("request") && !this.route.settings.log.collect) {
          return;
        }
        if (!Array.isArray(tags)) {
          tags = [tags];
        }
        const timestamp = Date.now();
        const field = data instanceof Error ? "error" : "data";
        let event = [this, { request: this.info.id, timestamp, tags, [field]: data, channel }];
        if (typeof data === "function") {
          event = () => [this, { request: this.info.id, timestamp, tags, data: data(), channel }];
        }
        if (this.route.settings.log.collect) {
          if (typeof data === "function") {
            event = event();
          }
          this.logs.push(event[1]);
        }
        this._core.events.emit({ name: "request", channel, tags }, event);
      }
      generateResponse(source, options) {
        return new this._core.Response(source, this, options);
      }
    };
    internals.Request.reserved = internals.reserved;
    internals.Request.symbols = {
      authPayload: Symbol("auth.payload")
    };
    internals.Info = class {
      constructor(request) {
        this._request = request;
        const req = request.raw.req;
        const host = req.headers.host ? req.headers.host.trim() : "";
        const received = Date.now();
        this.received = received;
        this.referrer = req.headers.referrer || req.headers.referer || "";
        this.host = host;
        this.hostname = host.split(":")[0];
        this.id = `${received}:${request._core.info.id}:${request._core._counter()}`;
        this._remoteAddress = null;
        this._remotePort = null;
        this.acceptEncoding = null;
        this.cors = null;
        this.responded = 0;
        this.completed = 0;
        if (request._core.settings.info.remote) {
          this.remoteAddress;
          this.remotePort;
        }
      }
      get remoteAddress() {
        if (!this._remoteAddress) {
          this._remoteAddress = this._request.raw.req.connection.remoteAddress;
        }
        return this._remoteAddress;
      }
      get remotePort() {
        if (this._remotePort === null) {
          this._remotePort = this._request.raw.req.connection.remotePort || "";
        }
        return this._remotePort;
      }
      toJSON() {
        return {
          acceptEncoding: this.acceptEncoding,
          completed: this.completed,
          cors: this.cors,
          host: this.host,
          hostname: this.hostname,
          id: this.id,
          received: this.received,
          referrer: this.referrer,
          remoteAddress: this.remoteAddress,
          remotePort: this.remotePort,
          responded: this.responded
        };
      }
    };
    internals.closed = function(request) {
      request._closed = true;
    };
    internals.event = function({ request }, event, err) {
      if (!request) {
        return;
      }
      request._isPayloadPending = false;
      if (event === "close" && request.raw.res.finished) {
        return;
      }
      if (event === "end") {
        return;
      }
      request._log(err ? ["request", "error"] : ["request", "error", event], err);
      if (event === "error") {
        return;
      }
      request._eventContext.request = null;
      if (event === "abort") {
        request._reply(new Boom.Boom("Request aborted", { statusCode: request.route.settings.response.disconnectStatusCode, data: request.response }));
        if (request._events) {
          request._events.emit("disconnect");
        }
      }
    };
    internals.timeoutReply = function(request, timeout) {
      const elapsed = Date.now() - request.info.received;
      request._log(["request", "server", "timeout", "error"], { timeout, elapsed });
      request._reply(Boom.serverUnavailable());
    };
    internals.skip = function(response) {
      return response.isBoom || response._takeover || typeof response === "symbol";
    };
  }
});

// node_modules/@hapi/hapi/lib/auth.js
var require_auth = __commonJS({
  "node_modules/@hapi/hapi/lib/auth.js"(exports, module2) {
    "use strict";
    var Boom = require_lib5();
    var Bounce = require_lib6();
    var Hoek = require_lib();
    var Config = require_config();
    var Request = require_request2();
    var internals = {
      missing: Symbol("missing")
    };
    exports = module2.exports = internals.Auth = class {
      #core = null;
      #schemes = {};
      #strategies = {};
      api = {};
      settings = {
        default: null
      };
      constructor(core) {
        this.#core = core;
      }
      public(server3) {
        return {
          api: this.api,
          settings: this.settings,
          scheme: this.scheme.bind(this),
          strategy: this._strategy.bind(this, server3),
          default: this.default.bind(this),
          test: this.test.bind(this),
          verify: this.verify.bind(this),
          lookup: this.lookup.bind(this)
        };
      }
      scheme(name, scheme) {
        Hoek.assert(name, "Authentication scheme must have a name");
        Hoek.assert(!this.#schemes[name], "Authentication scheme name already exists:", name);
        Hoek.assert(typeof scheme === "function", "scheme must be a function:", name);
        this.#schemes[name] = scheme;
      }
      _strategy(server3, name, scheme, options = {}) {
        Hoek.assert(name, "Authentication strategy must have a name");
        Hoek.assert(typeof options === "object", "options must be an object");
        Hoek.assert(!this.#strategies[name], "Authentication strategy name already exists");
        Hoek.assert(scheme, "Authentication strategy", name, "missing scheme");
        Hoek.assert(this.#schemes[scheme], "Authentication strategy", name, "uses unknown scheme:", scheme);
        server3 = server3._clone();
        const strategy = this.#schemes[scheme](server3, options);
        Hoek.assert(strategy.authenticate, "Invalid scheme:", name, "missing authenticate() method");
        Hoek.assert(typeof strategy.authenticate === "function", "Invalid scheme:", name, "invalid authenticate() method");
        Hoek.assert(!strategy.payload || typeof strategy.payload === "function", "Invalid scheme:", name, "invalid payload() method");
        Hoek.assert(!strategy.response || typeof strategy.response === "function", "Invalid scheme:", name, "invalid response() method");
        strategy.options = strategy.options || {};
        Hoek.assert(strategy.payload || !strategy.options.payload, "Cannot require payload validation without a payload method");
        this.#strategies[name] = {
          methods: strategy,
          realm: server3.realm
        };
        if (strategy.api) {
          this.api[name] = strategy.api;
        }
      }
      default(options) {
        Hoek.assert(!this.settings.default, "Cannot set default strategy more than once");
        options = Config.apply("auth", options, "default strategy");
        this.settings.default = this._setupRoute(Hoek.clone(options));
        const routes2 = this.#core.router.table();
        for (const route of routes2) {
          route.rebuild();
        }
      }
      async test(name, request) {
        Hoek.assert(name, "Missing authentication strategy name");
        const strategy = this.#strategies[name];
        Hoek.assert(strategy, "Unknown authentication strategy:", name);
        const bind = strategy.methods;
        const realm = strategy.realm;
        const response = await request._core.toolkit.execute(strategy.methods.authenticate, request, { bind, realm, auth: true });
        if (!response.isAuth) {
          throw response;
        }
        if (response.error) {
          throw response.error;
        }
        return response.data;
      }
      async verify(request) {
        const auth = request.auth;
        if (auth.error) {
          throw auth.error;
        }
        if (!auth.isAuthenticated) {
          return;
        }
        const strategy = this.#strategies[auth.strategy];
        Hoek.assert(strategy, "Unknown authentication strategy:", auth.strategy);
        if (!strategy.methods.verify) {
          return;
        }
        const bind = strategy.methods;
        await strategy.methods.verify.call(bind, auth);
      }
      static testAccess(request, route) {
        const auth = request._core.auth;
        try {
          return auth._access(request, route);
        } catch (err) {
          Bounce.rethrow(err, "system");
          return false;
        }
      }
      _setupRoute(options, path) {
        if (!options) {
          return options;
        }
        if (typeof options === "string") {
          options = { strategies: [options] };
        } else if (options.strategy) {
          options.strategies = [options.strategy];
          delete options.strategy;
        }
        if (path && !options.strategies) {
          Hoek.assert(this.settings.default, "Route missing authentication strategy and no default defined:", path);
          options = Hoek.applyToDefaults(this.settings.default, options);
        }
        path = path || "default strategy";
        Hoek.assert(options.strategies && options.strategies.length, "Missing authentication strategy:", path);
        options.mode = options.mode || "required";
        if (options.entity !== void 0 || options.scope !== void 0) {
          options.access = [{ entity: options.entity, scope: options.scope }];
          delete options.entity;
          delete options.scope;
        }
        if (options.access) {
          for (const access of options.access) {
            access.scope = internals.setupScope(access);
          }
        }
        if (options.payload === true) {
          options.payload = "required";
        }
        let hasAuthenticatePayload = false;
        for (const name of options.strategies) {
          const strategy = this.#strategies[name];
          Hoek.assert(strategy, "Unknown authentication strategy", name, "in", path);
          Hoek.assert(strategy.methods.payload || options.payload !== "required", "Payload validation can only be required when all strategies support it in", path);
          hasAuthenticatePayload = hasAuthenticatePayload || strategy.methods.payload;
          Hoek.assert(!strategy.methods.options.payload || options.payload === void 0 || options.payload === "required", "Cannot set authentication payload to", options.payload, "when a strategy requires payload validation in", path);
        }
        Hoek.assert(!options.payload || hasAuthenticatePayload, "Payload authentication requires at least one strategy with payload support in", path);
        return options;
      }
      lookup(route) {
        if (route.settings.auth === false) {
          return false;
        }
        return route.settings.auth || this.settings.default;
      }
      _enabled(route, type) {
        const config = this.lookup(route);
        if (!config) {
          return false;
        }
        if (type === "authenticate") {
          return true;
        }
        if (type === "access") {
          return !!config.access;
        }
        for (const name of config.strategies) {
          const strategy = this.#strategies[name];
          if (strategy.methods[type]) {
            return true;
          }
        }
        return false;
      }
      static authenticate(request) {
        const auth = request._core.auth;
        return auth._authenticate(request);
      }
      async _authenticate(request) {
        const config = this.lookup(request.route);
        const errors = [];
        request.auth.mode = config.mode;
        if (request.auth.credentials) {
          internals.validate(null, { credentials: request.auth.credentials, artifacts: request.auth.artifacts }, request.auth.strategy, config, request, errors);
          return;
        }
        for (const name of config.strategies) {
          const strategy = this.#strategies[name];
          const bind = strategy.methods;
          const realm = strategy.realm;
          const response = await request._core.toolkit.execute(strategy.methods.authenticate, request, { bind, realm, auth: true });
          const message = response.isAuth ? internals.validate(response.error, response.data, name, config, request, errors) : internals.validate(response, null, name, config, request, errors);
          if (!message) {
            return;
          }
          if (message !== internals.missing) {
            return message;
          }
        }
        const err = Boom.unauthorized("Missing authentication", errors);
        if (config.mode === "required") {
          throw err;
        }
        request.auth.isAuthenticated = false;
        request.auth.credentials = null;
        request.auth.error = err;
        request._log(["auth", "unauthenticated"]);
      }
      static access(request) {
        const auth = request._core.auth;
        request.auth.isAuthorized = auth._access(request);
      }
      _access(request, route) {
        const config = this.lookup(route || request.route);
        if (!config || !config.access) {
          return true;
        }
        const credentials = request.auth.credentials;
        if (!credentials) {
          if (config.mode !== "required") {
            return false;
          }
          throw Boom.forbidden("Request is unauthenticated");
        }
        const requestEntity = credentials.user ? "user" : "app";
        const scopeErrors = [];
        for (const access of config.access) {
          const entity = access.entity;
          if (entity && entity !== "any" && entity !== requestEntity) {
            continue;
          }
          let scope = access.scope;
          if (scope) {
            if (!credentials.scope) {
              scopeErrors.push(scope);
              continue;
            }
            scope = internals.expandScope(request, scope);
            if (!internals.validateScope(credentials, scope, "required") || !internals.validateScope(credentials, scope, "selection") || !internals.validateScope(credentials, scope, "forbidden")) {
              scopeErrors.push(scope);
              continue;
            }
          }
          return true;
        }
        if (scopeErrors.length) {
          request._log(["auth", "scope", "error"]);
          throw Boom.forbidden("Insufficient scope", { got: credentials.scope, need: scopeErrors });
        }
        if (requestEntity === "app") {
          request._log(["auth", "entity", "user", "error"]);
          throw Boom.forbidden("Application credentials cannot be used on a user endpoint");
        }
        request._log(["auth", "entity", "app", "error"]);
        throw Boom.forbidden("User credentials cannot be used on an application endpoint");
      }
      static async payload(request) {
        if (!request.auth.isAuthenticated || !request.auth[Request.symbols.authPayload]) {
          return;
        }
        const auth = request._core.auth;
        const strategy = auth.#strategies[request.auth.strategy];
        Hoek.assert(strategy, "Unknown authentication strategy:", request.auth.strategy);
        if (!strategy.methods.payload) {
          return;
        }
        const config = auth.lookup(request.route);
        const setting = config.payload || (strategy.methods.options.payload ? "required" : false);
        if (!setting) {
          return;
        }
        const bind = strategy.methods;
        const realm = strategy.realm;
        const response = await request._core.toolkit.execute(strategy.methods.payload, request, { bind, realm });
        if (response.isBoom && response.isMissing) {
          return setting === "optional" ? void 0 : Boom.unauthorized("Missing payload authentication");
        }
        return response;
      }
      static async response(response) {
        const request = response.request;
        const auth = request._core.auth;
        if (!request.auth.isAuthenticated) {
          return;
        }
        const strategy = auth.#strategies[request.auth.strategy];
        Hoek.assert(strategy, "Unknown authentication strategy:", request.auth.strategy);
        if (!strategy.methods.response) {
          return;
        }
        const bind = strategy.methods;
        const realm = strategy.realm;
        const error = await request._core.toolkit.execute(strategy.methods.response, request, { bind, realm, continue: "undefined" });
        if (error) {
          throw error;
        }
      }
    };
    internals.setupScope = function(access) {
      if (!access.scope) {
        return false;
      }
      if (!Array.isArray(access.scope)) {
        return access.scope;
      }
      const scope = {};
      for (const value of access.scope) {
        const prefix = value[0];
        const type = prefix === "+" ? "required" : prefix === "!" ? "forbidden" : "selection";
        const clean = type === "selection" ? value : value.slice(1);
        scope[type] = scope[type] || [];
        scope[type].push(clean);
        if ((!scope._hasParameters || !scope._hasParameters[type]) && /{([^}]+)}/.test(clean)) {
          scope._hasParameters = scope._hasParameters || {};
          scope._hasParameters[type] = true;
        }
      }
      return scope;
    };
    internals.validate = function(err, result, name, config, request, errors) {
      result = result || {};
      request.auth.isAuthenticated = !err;
      if (err) {
        if (err instanceof Error === false) {
          request._log(["auth", "unauthenticated", "response", name], { statusCode: err.statusCode });
          return err;
        }
        if (err.isMissing) {
          request._log(["auth", "unauthenticated", "missing", name], err);
          errors.push(err.output.headers["WWW-Authenticate"]);
          return internals.missing;
        }
      }
      request.auth.strategy = name;
      request.auth.credentials = result.credentials;
      request.auth.artifacts = result.artifacts;
      if (!err) {
        return;
      }
      request.auth.error = err;
      if (config.mode === "try") {
        request._log(["auth", "unauthenticated", "try", name], err);
        return;
      }
      request._log(["auth", "unauthenticated", "error", name], err);
      throw err;
    };
    internals.expandScope = function(request, scope) {
      if (!scope._hasParameters) {
        return scope;
      }
      const expanded = {
        required: internals.expandScopeType(request, scope, "required"),
        selection: internals.expandScopeType(request, scope, "selection"),
        forbidden: internals.expandScopeType(request, scope, "forbidden")
      };
      return expanded;
    };
    internals.expandScopeType = function(request, scope, type) {
      if (!scope._hasParameters[type]) {
        return scope[type];
      }
      const expanded = [];
      const context = {
        params: request.params,
        query: request.query,
        payload: request.payload,
        credentials: request.auth.credentials
      };
      for (const template of scope[type]) {
        expanded.push(Hoek.reachTemplate(context, template));
      }
      return expanded;
    };
    internals.validateScope = function(credentials, scope, type) {
      if (!scope[type]) {
        return true;
      }
      const count = typeof credentials.scope === "string" ? scope[type].indexOf(credentials.scope) !== -1 ? 1 : 0 : Hoek.intersect(scope[type], credentials.scope).length;
      if (type === "forbidden") {
        return count === 0;
      }
      if (type === "required") {
        return count === scope.required.length;
      }
      return !!count;
    };
  }
});

// node_modules/@hapi/accept/lib/header.js
var require_header = __commonJS({
  "node_modules/@hapi/accept/lib/header.js"(exports) {
    "use strict";
    var Hoek = require_lib();
    var Boom = require_lib5();
    var internals = {};
    exports.selection = function(header, preferences, options) {
      const selections = exports.selections(header, preferences, options);
      return selections.length ? selections[0] : "";
    };
    exports.selections = function(header, preferences, options) {
      Hoek.assert(!preferences || Array.isArray(preferences), "Preferences must be an array");
      return internals.parse(header || "", preferences, options);
    };
    internals.parse = function(raw, preferences, options) {
      const header = raw.replace(/[ \t]/g, "");
      const lowers = /* @__PURE__ */ new Map();
      if (preferences) {
        let pos = 0;
        for (const preference of preferences) {
          const lower = preference.toLowerCase();
          lowers.set(lower, { orig: preference, pos: pos++ });
          if (options.prefixMatch) {
            const parts2 = lower.split("-");
            while (parts2.pop(), parts2.length > 0) {
              const joined = parts2.join("-");
              if (!lowers.has(joined)) {
                lowers.set(joined, { orig: preference, pos: pos++ });
              }
            }
          }
        }
      }
      const parts = header.split(",");
      const selections = [];
      const map = /* @__PURE__ */ new Set();
      for (let i = 0; i < parts.length; ++i) {
        const part = parts[i];
        if (!part) {
          continue;
        }
        const params = part.split(";");
        if (params.length > 2) {
          throw Boom.badRequest(`Invalid ${options.type} header`);
        }
        let token = params[0].toLowerCase();
        if (!token) {
          throw Boom.badRequest(`Invalid ${options.type} header`);
        }
        if (options.equivalents && options.equivalents.has(token)) {
          token = options.equivalents.get(token);
        }
        const selection = {
          token,
          pos: i,
          q: 1
        };
        if (preferences && lowers.has(token)) {
          selection.pref = lowers.get(token).pos;
        }
        map.add(selection.token);
        if (params.length === 2) {
          const q = params[1];
          const [key, value] = q.split("=");
          if (!value || key !== "q" && key !== "Q") {
            throw Boom.badRequest(`Invalid ${options.type} header`);
          }
          const score = parseFloat(value);
          if (score === 0) {
            continue;
          }
          if (Number.isFinite(score) && score <= 1 && score >= 1e-3) {
            selection.q = score;
          }
        }
        selections.push(selection);
      }
      selections.sort(internals.sort);
      const values = selections.map((selection) => selection.token);
      if (options.default && !map.has(options.default)) {
        values.push(options.default);
      }
      if (!preferences || !preferences.length) {
        return values;
      }
      const preferred = [];
      for (const selection of values) {
        if (selection === "*") {
          for (const [preference, value] of lowers) {
            if (!map.has(preference)) {
              preferred.push(value.orig);
            }
          }
        } else {
          const lower = selection.toLowerCase();
          if (lowers.has(lower)) {
            preferred.push(lowers.get(lower).orig);
          }
        }
      }
      return preferred;
    };
    internals.sort = function(a, b) {
      const aFirst = -1;
      const bFirst = 1;
      if (b.q !== a.q) {
        return b.q - a.q;
      }
      if (b.pref !== a.pref) {
        if (a.pref === void 0) {
          return bFirst;
        }
        if (b.pref === void 0) {
          return aFirst;
        }
        return a.pref - b.pref;
      }
      return a.pos - b.pos;
    };
  }
});

// node_modules/@hapi/accept/lib/media.js
var require_media = __commonJS({
  "node_modules/@hapi/accept/lib/media.js"(exports) {
    "use strict";
    var Hoek = require_lib();
    var Boom = require_lib5();
    var internals = {};
    exports.selection = function(header, preferences) {
      const selections = exports.selections(header, preferences);
      return selections.length ? selections[0] : "";
    };
    exports.selections = function(header, preferences) {
      Hoek.assert(!preferences || Array.isArray(preferences), "Preferences must be an array");
      return internals.parse(header, preferences);
    };
    internals.validMediaRx = /^(?:\*\/\*)|(?:[\w\!#\$%&'\*\+\-\.\^`\|~]+\/\*)|(?:[\w\!#\$%&'\*\+\-\.\^`\|~]+\/[\w\!#\$%&'\*\+\-\.\^`\|~]+)$/;
    internals.parse = function(raw, preferences) {
      const { header, quoted } = internals.normalize(raw);
      const parts = header.split(",");
      const selections = [];
      const map = {};
      for (let i = 0; i < parts.length; ++i) {
        const part = parts[i];
        if (!part) {
          continue;
        }
        const pairs = part.split(";");
        const token = pairs.shift().toLowerCase();
        if (!internals.validMediaRx.test(token)) {
          continue;
        }
        const selection = {
          token,
          params: {},
          exts: {},
          pos: i
        };
        let target = "params";
        for (const pair of pairs) {
          const kv = pair.split("=");
          if (kv.length !== 2 || !kv[1]) {
            throw Boom.badRequest(`Invalid accept header`);
          }
          const key = kv[0];
          let value = kv[1];
          if (key === "q" || key === "Q") {
            target = "exts";
            value = parseFloat(value);
            if (!Number.isFinite(value) || value > 1 || value < 1e-3 && value !== 0) {
              value = 1;
            }
            selection.q = value;
          } else {
            if (value[0] === '"') {
              value = `"${quoted[value]}"`;
            }
            selection[target][kv[0]] = value;
          }
        }
        const params = Object.keys(selection.params);
        selection.original = [""].concat(params.map((key) => `${key}=${selection.params[key]}`)).join(";");
        selection.specificity = params.length;
        if (selection.q === void 0) {
          selection.q = 1;
        }
        const tparts = selection.token.split("/");
        selection.type = tparts[0];
        selection.subtype = tparts[1];
        map[selection.token] = selection;
        if (selection.q) {
          selections.push(selection);
        }
      }
      selections.sort(internals.sort);
      return internals.preferences(map, selections, preferences);
    };
    internals.normalize = function(raw) {
      raw = raw || "*/*";
      const normalized = {
        header: raw,
        quoted: {}
      };
      if (raw.includes('"')) {
        let i = 0;
        normalized.header = raw.replace(/="([^"]*)"/g, ($0, $1) => {
          const key = '"' + ++i;
          normalized.quoted[key] = $1;
          return "=" + key;
        });
      }
      normalized.header = normalized.header.replace(/[ \t]/g, "");
      return normalized;
    };
    internals.sort = function(a, b) {
      if (b.q !== a.q) {
        return b.q - a.q;
      }
      if (a.type !== b.type) {
        return internals.innerSort(a, b, "type");
      }
      if (a.subtype !== b.subtype) {
        return internals.innerSort(a, b, "subtype");
      }
      if (a.specificity !== b.specificity) {
        return b.specificity - a.specificity;
      }
      return a.pos - b.pos;
    };
    internals.innerSort = function(a, b, key) {
      const aFirst = -1;
      const bFirst = 1;
      if (a[key] === "*") {
        return bFirst;
      }
      if (b[key] === "*") {
        return aFirst;
      }
      return a[key] < b[key] ? aFirst : bFirst;
    };
    internals.preferences = function(map, selections, preferences) {
      if (!preferences || !preferences.length) {
        return selections.map((selection) => selection.token + selection.original);
      }
      const lowers = /* @__PURE__ */ Object.create(null);
      const flat = /* @__PURE__ */ Object.create(null);
      let any = false;
      for (const preference of preferences) {
        const lower = preference.toLowerCase();
        flat[lower] = preference;
        const parts = lower.split("/");
        const type = parts[0];
        const subtype = parts[1];
        if (type === "*") {
          Hoek.assert(subtype === "*", "Invalid media type preference contains wildcard type with a subtype");
          any = true;
          continue;
        }
        lowers[type] = lowers[type] || /* @__PURE__ */ Object.create(null);
        lowers[type][subtype] = preference;
      }
      const preferred = [];
      for (const selection of selections) {
        const token = selection.token;
        const { type, subtype } = map[token];
        const subtypes = lowers[type];
        if (type === "*") {
          for (const preference of Object.keys(flat)) {
            if (!map[preference]) {
              preferred.push(flat[preference]);
            }
          }
          if (any) {
            preferred.push("*/*");
          }
          continue;
        }
        if (any) {
          preferred.push((flat[token] || token) + selection.original);
          continue;
        }
        if (subtype !== "*") {
          const pref = flat[token];
          if (pref || subtypes && subtypes["*"]) {
            preferred.push((pref || token) + selection.original);
          }
          continue;
        }
        if (subtypes) {
          for (const psub of Object.keys(subtypes)) {
            if (!map[`${type}/${psub}`]) {
              preferred.push(subtypes[psub]);
            }
          }
        }
      }
      return preferred;
    };
  }
});

// node_modules/@hapi/accept/lib/index.js
var require_lib28 = __commonJS({
  "node_modules/@hapi/accept/lib/index.js"(exports) {
    "use strict";
    var Header = require_header();
    var Media = require_media();
    var internals = {
      options: {
        charset: {
          type: "accept-charset"
        },
        encoding: {
          type: "accept-encoding",
          default: "identity",
          equivalents: /* @__PURE__ */ new Map([
            ["x-compress", "compress"],
            ["x-gzip", "gzip"]
          ])
        },
        language: {
          type: "accept-language",
          prefixMatch: true
        }
      }
    };
    for (const type in internals.options) {
      exports[type] = (header, preferences) => Header.selection(header, preferences, internals.options[type]);
      exports[`${type}s`] = (header, preferences) => Header.selections(header, preferences, internals.options[type]);
    }
    exports.mediaType = (header, preferences) => Media.selection(header, preferences);
    exports.mediaTypes = (header, preferences) => Media.selections(header, preferences);
    exports.parseAll = function(requestHeaders) {
      return {
        charsets: exports.charsets(requestHeaders["accept-charset"]),
        encodings: exports.encodings(requestHeaders["accept-encoding"]),
        languages: exports.languages(requestHeaders["accept-language"]),
        mediaTypes: exports.mediaTypes(requestHeaders.accept)
      };
    };
  }
});

// node_modules/@hapi/hapi/lib/compression.js
var require_compression = __commonJS({
  "node_modules/@hapi/hapi/lib/compression.js"(exports, module2) {
    "use strict";
    var Zlib = require("zlib");
    var Accept = require_lib28();
    var Bounce = require_lib6();
    var Hoek = require_lib();
    var internals = {
      common: ["gzip, deflate", "deflate, gzip", "gzip", "deflate", "gzip, deflate, br"]
    };
    exports = module2.exports = internals.Compression = class {
      decoders = {
        gzip: (options) => Zlib.createGunzip(options),
        deflate: (options) => Zlib.createInflate(options)
      };
      encodings = ["identity", "gzip", "deflate"];
      encoders = {
        identity: null,
        gzip: (options) => Zlib.createGzip(options),
        deflate: (options) => Zlib.createDeflate(options)
      };
      #common = null;
      constructor() {
        this._updateCommons();
      }
      _updateCommons() {
        this.#common = /* @__PURE__ */ new Map();
        for (const header of internals.common) {
          this.#common.set(header, Accept.encoding(header, this.encodings));
        }
      }
      addEncoder(encoding, encoder) {
        Hoek.assert(this.encoders[encoding] === void 0, `Cannot override existing encoder for ${encoding}`);
        Hoek.assert(typeof encoder === "function", `Invalid encoder function for ${encoding}`);
        this.encoders[encoding] = encoder;
        this.encodings.unshift(encoding);
        this._updateCommons();
      }
      addDecoder(encoding, decoder) {
        Hoek.assert(this.decoders[encoding] === void 0, `Cannot override existing decoder for ${encoding}`);
        Hoek.assert(typeof decoder === "function", `Invalid decoder function for ${encoding}`);
        this.decoders[encoding] = decoder;
      }
      accept(request) {
        const header = request.headers["accept-encoding"];
        if (!header) {
          return "identity";
        }
        const common = this.#common.get(header);
        if (common) {
          return common;
        }
        try {
          return Accept.encoding(header, this.encodings);
        } catch (err) {
          Bounce.rethrow(err, "system");
          err.header = header;
          request._log(["accept-encoding", "error"], err);
          return "identity";
        }
      }
      encoding(response, length) {
        if (response.settings.compressed) {
          response.headers["content-encoding"] = response.settings.compressed;
          return null;
        }
        const request = response.request;
        if (!request._core.settings.compression || length !== null && length < request._core.settings.compression.minBytes) {
          return null;
        }
        const mime = request._core.mime.type(response.headers["content-type"] || "application/octet-stream");
        if (!mime.compressible) {
          return null;
        }
        response.vary("accept-encoding");
        if (response.headers["content-encoding"]) {
          return null;
        }
        return request.info.acceptEncoding === "identity" ? null : request.info.acceptEncoding;
      }
      encoder(request, encoding) {
        const encoder = this.encoders[encoding];
        Hoek.assert(encoder !== void 0, `Unknown encoding ${encoding}`);
        return encoder(request.route.settings.compression[encoding]);
      }
    };
  }
});

// node_modules/@hapi/hapi/lib/methods.js
var require_methods = __commonJS({
  "node_modules/@hapi/hapi/lib/methods.js"(exports, module2) {
    "use strict";
    var Boom = require_lib5();
    var Hoek = require_lib();
    var Config = require_config();
    var internals = {
      methodNameRx: /^[_$a-zA-Z][$\w]*(?:\.[_$a-zA-Z][$\w]*)*$/
    };
    exports = module2.exports = internals.Methods = class {
      methods = {};
      #core = null;
      constructor(core) {
        this.#core = core;
      }
      add(name, method, options, realm) {
        if (typeof name !== "object") {
          return this._add(name, method, options, realm);
        }
        const items = [].concat(name);
        for (let item of items) {
          item = Config.apply("methodObject", item);
          this._add(item.name, item.method, item.options || {}, realm);
        }
      }
      _add(name, method, options, realm) {
        Hoek.assert(typeof method === "function", "method must be a function");
        Hoek.assert(typeof name === "string", "name must be a string");
        Hoek.assert(name.match(internals.methodNameRx), "Invalid name:", name);
        Hoek.assert(!Hoek.reach(this.methods, name, { functions: false }), "Server method function name already exists:", name);
        options = Config.apply("method", options, name);
        const settings = Hoek.clone(options, { shallow: ["bind"] });
        settings.generateKey = settings.generateKey || internals.generateKey;
        const bind = settings.bind || realm.settings.bind || null;
        const bound = !bind ? method : (...args) => method.apply(bind, args);
        if (!settings.cache) {
          return this._assign(name, bound);
        }
        Hoek.assert(!settings.cache.generateFunc, "Cannot set generateFunc with method caching:", name);
        Hoek.assert(settings.cache.generateTimeout !== void 0, "Method caching requires a timeout value in generateTimeout:", name);
        settings.cache.generateFunc = (id, flags) => bound(...id.args, flags);
        const cache = this.#core._cachePolicy(settings.cache, "#" + name);
        const func = function(...args) {
          const key = settings.generateKey.apply(bind, args);
          if (typeof key !== "string") {
            return Promise.reject(Boom.badImplementation("Invalid method key when invoking: " + name, { name, args }));
          }
          return cache.get({ id: key, args });
        };
        func.cache = {
          drop: function(...args) {
            const key = settings.generateKey.apply(bind, args);
            if (typeof key !== "string") {
              return Promise.reject(Boom.badImplementation("Invalid method key when invoking: " + name, { name, args }));
            }
            return cache.drop(key);
          },
          stats: cache.stats
        };
        this._assign(name, func, func);
      }
      _assign(name, method) {
        const path = name.split(".");
        let ref = this.methods;
        for (let i = 0; i < path.length; ++i) {
          if (!ref[path[i]]) {
            ref[path[i]] = i + 1 === path.length ? method : {};
          }
          ref = ref[path[i]];
        }
      }
    };
    internals.supportedArgs = ["string", "number", "boolean"];
    internals.generateKey = function(...args) {
      let key = "";
      for (let i = 0; i < args.length; ++i) {
        const arg = args[i];
        if (!internals.supportedArgs.includes(typeof arg)) {
          return null;
        }
        key = key + (i ? ":" : "") + encodeURIComponent(arg.toString());
      }
      return key;
    };
  }
});

// node_modules/@hapi/hapi/lib/response.js
var require_response2 = __commonJS({
  "node_modules/@hapi/hapi/lib/response.js"(exports, module2) {
    "use strict";
    var Stream = require("stream");
    var Boom = require_lib5();
    var Bounce = require_lib6();
    var Hoek = require_lib();
    var Podium = require_lib10();
    var Streams = require_streams();
    var internals = {
      events: Podium.validate(["finish", { name: "peek", spread: true }]),
      hopByHop: {
        connection: true,
        "keep-alive": true,
        "proxy-authenticate": true,
        "proxy-authorization": true,
        "te": true,
        "trailer": true,
        "transfer-encoding": true,
        "upgrade": true
      },
      reserved: [
        "app",
        "headers",
        "plugins",
        "request",
        "source",
        "statusCode",
        "variety",
        "settings",
        "events",
        "code",
        "message",
        "header",
        "vary",
        "etag",
        "type",
        "contentType",
        "bytes",
        "location",
        "created",
        "compressed",
        "replacer",
        "space",
        "suffix",
        "escape",
        "passThrough",
        "redirect",
        "temporary",
        "permanent",
        "rewritable",
        "encoding",
        "charset",
        "ttl",
        "state",
        "unstate",
        "takeover"
      ]
    };
    exports = module2.exports = internals.Response = class {
      constructor(source, request, options = {}) {
        this.app = {};
        this.headers = {};
        this.plugins = {};
        this.request = request;
        this.source = null;
        this.statusCode = null;
        this.variety = null;
        this.settings = {
          charset: "utf-8",
          compressed: null,
          encoding: "utf8",
          message: null,
          passThrough: true,
          stringify: null,
          ttl: null,
          varyEtag: false
        };
        this._events = null;
        this._payload = null;
        this._error = options.error || null;
        this._contentType = null;
        this._takeover = false;
        this._statusCode = false;
        this._state = this._error ? "prepare" : "init";
        this._processors = {
          marshal: options.marshal,
          prepare: options.prepare,
          close: options.close
        };
        this._setSource(source, options.variety);
      }
      static wrap(result, request) {
        if (result instanceof request._core.Response || typeof result === "symbol") {
          return result;
        }
        if (result instanceof Error) {
          return Boom.boomify(result);
        }
        return new request._core.Response(result, request);
      }
      _setSource(source, variety) {
        this.variety = variety || "plain";
        if (source === null || source === void 0) {
          source = null;
        } else if (Buffer.isBuffer(source)) {
          this.variety = "buffer";
          this._contentType = "application/octet-stream";
        } else if (Streams.isStream(source)) {
          this.variety = "stream";
          this._contentType = "application/octet-stream";
        }
        this.source = source;
        if (this.variety === "plain" && this.source !== null) {
          this._contentType = typeof this.source === "string" ? "text/html" : "application/json";
        }
      }
      get events() {
        if (!this._events) {
          this._events = new Podium(internals.events);
        }
        return this._events;
      }
      code(statusCode) {
        Hoek.assert(Number.isSafeInteger(statusCode), "Status code must be an integer");
        this.statusCode = statusCode;
        this._statusCode = true;
        return this;
      }
      message(httpMessage) {
        this.settings.message = httpMessage;
        return this;
      }
      header(key, value, options) {
        key = key.toLowerCase();
        if (key === "vary") {
          return this.vary(value);
        }
        return this._header(key, value, options);
      }
      _header(key, value, options = {}) {
        const append = options.append || false;
        const separator = options.separator || ",";
        const override = options.override !== false;
        const duplicate = options.duplicate !== false;
        if (!append && override || !this.headers[key]) {
          this.headers[key] = value;
        } else if (override) {
          if (key === "set-cookie") {
            this.headers[key] = [].concat(this.headers[key], value);
          } else {
            const existing = this.headers[key];
            if (!duplicate) {
              const values = existing.split(separator);
              for (const v of values) {
                if (v === value) {
                  return this;
                }
              }
            }
            this.headers[key] = existing + separator + value;
          }
        }
        return this;
      }
      vary(value) {
        if (value === "*") {
          this.headers.vary = "*";
        } else if (!this.headers.vary) {
          this.headers.vary = value;
        } else if (this.headers.vary !== "*") {
          this._header("vary", value, { append: true, duplicate: false });
        }
        return this;
      }
      etag(tag, options) {
        const entity = this.request._core.Response.entity(tag, options);
        this._header("etag", entity.etag);
        this.settings.varyEtag = entity.vary;
        return this;
      }
      static entity(tag, options = {}) {
        Hoek.assert(tag !== "*", "ETag cannot be *");
        return {
          etag: (options.weak ? "W/" : "") + '"' + tag + '"',
          vary: options.vary !== false && !options.weak,
          modified: options.modified
        };
      }
      static unmodified(request, entity) {
        if (request.method !== "get" && request.method !== "head") {
          return false;
        }
        if (entity.etag && request.headers["if-none-match"]) {
          const ifNoneMatch = request.headers["if-none-match"].split(/\s*,\s*/);
          for (const etag of ifNoneMatch) {
            if (etag === entity.etag) {
              return true;
            }
            if (!entity.vary) {
              continue;
            }
            if (etag === `W/${entity.etag}`) {
              return etag;
            }
            const etagBase = entity.etag.slice(0, -1);
            const encoders = request._core.compression.encodings;
            for (const encoder of encoders) {
              if (etag === etagBase + `-${encoder}"`) {
                return true;
              }
            }
          }
          return false;
        }
        if (!entity.modified) {
          return false;
        }
        const ifModifiedSinceHeader = request.headers["if-modified-since"];
        if (!ifModifiedSinceHeader) {
          return false;
        }
        const ifModifiedSince = internals.parseDate(ifModifiedSinceHeader);
        if (!ifModifiedSince) {
          return false;
        }
        const lastModified = internals.parseDate(entity.modified);
        if (!lastModified) {
          return false;
        }
        return ifModifiedSince >= lastModified;
      }
      type(type) {
        this._header("content-type", type);
        return this;
      }
      get contentType() {
        let type = this.headers["content-type"];
        if (type) {
          type = type.trim();
          if (this.settings.charset && type.match(/^(?:text\/)|(?:application\/(?:json)|(?:javascript))/) && !type.match(/; *charset=/)) {
            const semi = type[type.length - 1] === ";";
            return type + (semi ? " " : "; ") + "charset=" + this.settings.charset;
          }
          return type;
        }
        if (this._contentType) {
          const charset = this.settings.charset && this._contentType !== "application/octet-stream" ? "; charset=" + this.settings.charset : "";
          return this._contentType + charset;
        }
        return null;
      }
      bytes(bytes) {
        this._header("content-length", bytes);
        return this;
      }
      location(uri) {
        this._header("location", uri);
        return this;
      }
      created(location) {
        Hoek.assert(this.request.method === "post" || this.request.method === "put" || this.request.method === "patch", "Cannot return 201 status codes for " + this.request.method.toUpperCase());
        this.statusCode = 201;
        this.location(location);
        return this;
      }
      compressed(encoding) {
        Hoek.assert(encoding && typeof encoding === "string", "Invalid content-encoding");
        this.settings.compressed = encoding;
        return this;
      }
      replacer(method) {
        this.settings.stringify = this.settings.stringify || {};
        this.settings.stringify.replacer = method;
        return this;
      }
      spaces(count) {
        this.settings.stringify = this.settings.stringify || {};
        this.settings.stringify.space = count;
        return this;
      }
      suffix(suffix) {
        this.settings.stringify = this.settings.stringify || {};
        this.settings.stringify.suffix = suffix;
        return this;
      }
      escape(escape) {
        this.settings.stringify = this.settings.stringify || {};
        this.settings.stringify.escape = escape;
        return this;
      }
      passThrough(enabled) {
        this.settings.passThrough = enabled !== false;
        return this;
      }
      redirect(location) {
        this.statusCode = 302;
        this.location(location);
        return this;
      }
      temporary(isTemporary) {
        Hoek.assert(this.headers.location, "Cannot set redirection mode without first setting a location");
        this._setTemporary(isTemporary !== false);
        return this;
      }
      permanent(isPermanent) {
        Hoek.assert(this.headers.location, "Cannot set redirection mode without first setting a location");
        this._setTemporary(isPermanent === false);
        return this;
      }
      rewritable(isRewritable) {
        Hoek.assert(this.headers.location, "Cannot set redirection mode without first setting a location");
        this._setRewritable(isRewritable !== false);
        return this;
      }
      _isTemporary() {
        return this.statusCode === 302 || this.statusCode === 307;
      }
      _isRewritable() {
        return this.statusCode === 301 || this.statusCode === 302;
      }
      _setTemporary(isTemporary) {
        if (isTemporary) {
          if (this._isRewritable()) {
            this.statusCode = 302;
          } else {
            this.statusCode = 307;
          }
        } else {
          if (this._isRewritable()) {
            this.statusCode = 301;
          } else {
            this.statusCode = 308;
          }
        }
      }
      _setRewritable(isRewritable) {
        if (isRewritable) {
          if (this._isTemporary()) {
            this.statusCode = 302;
          } else {
            this.statusCode = 301;
          }
        } else {
          if (this._isTemporary()) {
            this.statusCode = 307;
          } else {
            this.statusCode = 308;
          }
        }
      }
      encoding(encoding) {
        this.settings.encoding = encoding;
        return this;
      }
      charset(charset) {
        this.settings.charset = charset || null;
        return this;
      }
      ttl(ttl) {
        this.settings.ttl = ttl;
        return this;
      }
      state(name, value, options) {
        this.request._setState(name, value, options);
        return this;
      }
      unstate(name, options) {
        this.request._clearState(name, options);
        return this;
      }
      takeover() {
        this._takeover = true;
        return this;
      }
      _prepare() {
        Hoek.assert(this._state === "init");
        this._state = "prepare";
        this._passThrough();
        if (!this._processors.prepare) {
          return this;
        }
        try {
          return this._processors.prepare(this);
        } catch (err) {
          throw Boom.boomify(err);
        }
      }
      _passThrough() {
        if (this.variety === "stream" && this.settings.passThrough) {
          if (this.source.statusCode && !this.statusCode) {
            this.statusCode = this.source.statusCode;
          }
          if (this.source.headers) {
            let headerKeys = Object.keys(this.source.headers);
            if (headerKeys.length) {
              const localHeaders = this.headers;
              this.headers = {};
              const connection = this.source.headers.connection;
              const byHop = {};
              if (connection) {
                connection.split(/\s*,\s*/).forEach((header) => {
                  byHop[header] = true;
                });
              }
              for (const key of headerKeys) {
                const lower = key.toLowerCase();
                if (!internals.hopByHop[lower] && !byHop[lower]) {
                  this.header(lower, Hoek.clone(this.source.headers[key]));
                }
              }
              headerKeys = Object.keys(localHeaders);
              for (const key of headerKeys) {
                this.header(key, localHeaders[key], { append: key === "set-cookie" });
              }
            }
          }
        }
        this.statusCode = this.statusCode || 200;
      }
      async _marshal() {
        Hoek.assert(this._state === "prepare");
        this._state = "marshall";
        let source = this.source;
        if (this._processors.marshal) {
          try {
            source = await this._processors.marshal(this);
          } catch (err) {
            throw Boom.boomify(err);
          }
        }
        if (Streams.isStream(source)) {
          this._payload = source;
          return;
        }
        const jsonify = this.variety === "plain" && source !== null && typeof source !== "string";
        if (!jsonify && this.settings.stringify) {
          throw Boom.badImplementation("Cannot set formatting options on non object response");
        }
        let payload = source;
        if (jsonify) {
          const options = this.settings.stringify || {};
          const space = options.space || this.request.route.settings.json.space;
          const replacer = options.replacer || this.request.route.settings.json.replacer;
          const suffix = options.suffix || this.request.route.settings.json.suffix || "";
          const escape = this.request.route.settings.json.escape || false;
          try {
            if (replacer || space) {
              payload = JSON.stringify(payload, replacer, space);
            } else {
              payload = JSON.stringify(payload);
            }
          } catch (err) {
            throw Boom.boomify(err);
          }
          if (suffix) {
            payload = payload + suffix;
          }
          if (escape) {
            payload = Hoek.escapeJson(payload);
          }
        }
        this._payload = new internals.Response.Payload(payload, this.settings);
      }
      _tap() {
        if (!this._events) {
          return null;
        }
        if (this._events.hasListeners("peek") || this._events.hasListeners("finish")) {
          return new internals.Response.Peek(this._events);
        }
        return null;
      }
      _close() {
        if (this._state === "close") {
          return;
        }
        this._state = "close";
        if (this._processors.close) {
          try {
            this._processors.close(this);
          } catch (err) {
            Bounce.rethrow(err, "system");
            this.request._log(["response", "cleanup", "error"], err);
          }
        }
        const stream = this._payload || this.source;
        if (Streams.isStream(stream)) {
          internals.Response.drain(stream);
        }
      }
      _isPayloadSupported() {
        return this.request.method !== "head" && this.statusCode !== 304 && this.statusCode !== 204;
      }
      static drain(stream) {
        if (stream.destroy) {
          stream.destroy();
          return;
        }
        stream.unpipe();
        if (stream.close) {
          stream.close();
        }
      }
    };
    internals.Response.reserved = internals.reserved;
    internals.parseDate = function(string) {
      try {
        return Date.parse(string);
      } catch (errIgnore) {
      }
    };
    internals.Response.Payload = class extends Stream.Readable {
      constructor(payload, options) {
        super();
        this._data = payload;
        this._prefix = null;
        this._suffix = null;
        this._sizeOffset = 0;
        this._encoding = options.encoding;
      }
      _read(size) {
        if (this._prefix) {
          this.push(this._prefix, this._encoding);
        }
        if (this._data) {
          this.push(this._data, this._encoding);
        }
        if (this._suffix) {
          this.push(this._suffix, this._encoding);
        }
        this.push(null);
      }
      size() {
        if (!this._data) {
          return this._sizeOffset;
        }
        return (Buffer.isBuffer(this._data) ? this._data.length : Buffer.byteLength(this._data, this._encoding)) + this._sizeOffset;
      }
      jsonp(variable) {
        this._sizeOffset = this._sizeOffset + variable.length + 7;
        this._prefix = "/**/" + variable + "(";
        if (this._data !== null && !Buffer.isBuffer(this._data)) {
          this._data = this._data.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
        }
        this._suffix = ");";
      }
      writeToStream(stream) {
        if (this._prefix) {
          stream.write(this._prefix, this._encoding);
        }
        if (this._data) {
          stream.write(this._data, this._encoding);
        }
        if (this._suffix) {
          stream.write(this._suffix, this._encoding);
        }
        stream.end();
      }
    };
    internals.Response.Peek = class extends Stream.Transform {
      constructor(podium) {
        super();
        this._podium = podium;
        this.on("finish", () => podium.emit("finish"));
      }
      _transform(chunk, encoding, callback) {
        this._podium.emit("peek", [chunk, encoding]);
        this.push(chunk, encoding);
        callback();
      }
    };
  }
});

// node_modules/@hapi/hapi/lib/core.js
var require_core = __commonJS({
  "node_modules/@hapi/hapi/lib/core.js"(exports, module2) {
    "use strict";
    var Http = require("http");
    var Https = require("https");
    var Os = require("os");
    var Path = require("path");
    var Boom = require_lib5();
    var Bounce = require_lib6();
    var Call = require_lib9();
    var Catbox = require_lib11();
    var CatboxMemory = require_lib12();
    var Heavy = require_lib13();
    var Hoek = require_lib();
    var { Mimos } = require_lib14();
    var Podium = require_lib10();
    var Somever = require_lib7();
    var Statehood = require_lib19();
    var Auth = require_auth();
    var Compression = require_compression();
    var Config = require_config();
    var Cors = require_cors();
    var Ext = require_ext();
    var Methods = require_methods();
    var Request = require_request2();
    var Response = require_response2();
    var Route = require_route();
    var Toolkit = require_toolkit();
    var Validation = require_validation();
    var internals = {
      counter: {
        min: 1e4,
        max: 99999
      },
      events: [
        { name: "cachePolicy", spread: true },
        { name: "log", channels: ["app", "internal"], tags: true },
        { name: "request", channels: ["app", "internal", "error"], tags: true, spread: true },
        "response",
        "route",
        "start",
        "closing",
        "stop"
      ],
      badRequestResponse: Buffer.from("HTTP/1.1 400 Bad Request\r\n\r\n", "ascii")
    };
    exports = module2.exports = internals.Core = class {
      actives = /* @__PURE__ */ new WeakMap();
      app = {};
      auth = new Auth(this);
      caches = /* @__PURE__ */ new Map();
      compression = new Compression();
      controlled = null;
      dependencies = [];
      events = new Podium(internals.events);
      heavy = null;
      info = null;
      instances = /* @__PURE__ */ new Set();
      listener = null;
      methods = new Methods(this);
      mime = null;
      onConnection = null;
      phase = "stopped";
      plugins = {};
      registrations = {};
      registring = 0;
      Request = class extends Request {
      };
      Response = class extends Response {
      };
      requestCounter = { value: internals.counter.min, min: internals.counter.min, max: internals.counter.max };
      root = null;
      router = null;
      settings = null;
      sockets = null;
      started = false;
      states = null;
      toolkit = new Toolkit.Manager();
      type = null;
      validator = null;
      extensionsSeq = 0;
      extensions = {
        server: {
          onPreStart: new Ext("onPreStart", this),
          onPostStart: new Ext("onPostStart", this),
          onPreStop: new Ext("onPreStop", this),
          onPostStop: new Ext("onPostStop", this)
        },
        route: {
          onRequest: new Ext("onRequest", this),
          onPreAuth: new Ext("onPreAuth", this),
          onCredentials: new Ext("onCredentials", this),
          onPostAuth: new Ext("onPostAuth", this),
          onPreHandler: new Ext("onPreHandler", this),
          onPostHandler: new Ext("onPostHandler", this),
          onPreResponse: new Ext("onPreResponse", this),
          onPostResponse: new Ext("onPostResponse", this)
        }
      };
      decorations = {
        handler: /* @__PURE__ */ new Map(),
        request: /* @__PURE__ */ new Map(),
        response: /* @__PURE__ */ new Map(),
        server: /* @__PURE__ */ new Map(),
        toolkit: /* @__PURE__ */ new Map(),
        requestApply: null,
        public: { handler: [], request: [], response: [], server: [], toolkit: [] }
      };
      constructor(options) {
        const { settings, type } = internals.setup(options);
        this.settings = settings;
        this.type = type;
        this.heavy = new Heavy(this.settings.load);
        this.mime = new Mimos(this.settings.mime);
        this.router = new Call.Router(this.settings.router);
        this.states = new Statehood.Definitions(this.settings.state);
        this._debug();
        this._initializeCache();
        if (this.settings.routes.validate.validator) {
          this.validator = Validation.validator(this.settings.routes.validate.validator);
        }
        this.listener = this._createListener();
        this._initializeListener();
        this.info = this._info();
      }
      _debug() {
        const debug = this.settings.debug;
        if (!debug) {
          return;
        }
        const method = (event) => {
          const data = event.error || event.data;
          console.error("Debug:", event.tags.join(", "), data ? "\n    " + (data.stack || (typeof data === "object" ? Hoek.stringify(data) : data)) : "");
        };
        if (debug.log) {
          const filter = debug.log.some((tag) => tag === "*") ? void 0 : debug.log;
          this.events.on({ name: "log", filter }, method);
        }
        if (debug.request) {
          const filter = debug.request.some((tag) => tag === "*") ? void 0 : debug.request;
          this.events.on({ name: "request", filter }, (request, event) => method(event));
        }
      }
      _initializeCache() {
        if (this.settings.cache) {
          this._createCache(this.settings.cache);
        }
        if (!this.caches.has("_default")) {
          this._createCache([{ provider: CatboxMemory }]);
        }
      }
      _info() {
        const now = Date.now();
        const protocol = this.type === "tcp" ? this.settings.tls ? "https" : "http" : this.type;
        const host = this.settings.host || Os.hostname() || "localhost";
        const port = this.settings.port;
        const info = {
          created: now,
          started: 0,
          host,
          port,
          protocol,
          id: Os.hostname() + ":" + process.pid + ":" + now.toString(36),
          uri: this.settings.uri || protocol + ":" + (this.type === "tcp" ? "//" + host + (port ? ":" + port : "") : port)
        };
        return info;
      }
      _counter() {
        const next = ++this.requestCounter.value;
        if (this.requestCounter.value > this.requestCounter.max) {
          this.requestCounter.value = this.requestCounter.min;
        }
        return next - 1;
      }
      _createCache(configs) {
        Hoek.assert(this.phase !== "initializing", "Cannot provision server cache while server is initializing");
        configs = Config.apply("cache", configs);
        const added = [];
        for (let config of configs) {
          if (typeof config === "function") {
            config = { provider: { constructor: config } };
          }
          const name = config.name || "_default";
          Hoek.assert(!this.caches.has(name), "Cannot configure the same cache more than once: ", name === "_default" ? "default cache" : name);
          let client = null;
          if (config.provider) {
            let provider = config.provider;
            if (typeof provider === "function") {
              provider = { constructor: provider };
            }
            client = new Catbox.Client(provider.constructor, provider.options || { partition: "hapi-cache" });
          } else {
            client = new Catbox.Client(config.engine);
          }
          this.caches.set(name, { client, segments: {}, shared: config.shared || false });
          added.push(client);
        }
        return added;
      }
      registerServer(server3) {
        if (!this.root) {
          this.root = server3;
          this._defaultRoutes();
        }
        this.instances.add(server3);
      }
      async _start() {
        if (this.phase === "initialized" || this.phase === "started") {
          this._validateDeps();
        }
        if (this.phase === "started") {
          return;
        }
        if (this.phase !== "stopped" && this.phase !== "initialized") {
          throw new Error("Cannot start server while it is in " + this.phase + " phase");
        }
        if (this.phase !== "initialized") {
          await this._initialize();
        }
        this.phase = "starting";
        this.started = true;
        this.info.started = Date.now();
        try {
          await this._listen();
        } catch (err) {
          this.started = false;
          this.phase = "invalid";
          throw err;
        }
        this.phase = "started";
        await this.events.emit("start");
        try {
          if (this.controlled) {
            await Promise.all(this.controlled.map((control) => control.start()));
          }
          await this._invoke("onPostStart");
        } catch (err) {
          this.phase = "invalid";
          throw err;
        }
      }
      _listen() {
        return new Promise((resolve, reject) => {
          if (!this.settings.autoListen) {
            resolve();
            return;
          }
          const onError = (err) => {
            reject(err);
            return;
          };
          this.listener.once("error", onError);
          const finalize = () => {
            this.listener.removeListener("error", onError);
            resolve();
            return;
          };
          if (this.type !== "tcp") {
            this.listener.listen(this.settings.port, finalize);
          } else {
            const address = this.settings.address || this.settings.host || "0.0.0.0";
            this.listener.listen(this.settings.port, address, finalize);
          }
        });
      }
      async _initialize() {
        if (this.registring) {
          throw new Error("Cannot start server before plugins finished registration");
        }
        if (this.phase === "initialized") {
          return;
        }
        if (this.phase !== "stopped") {
          throw new Error("Cannot initialize server while it is in " + this.phase + " phase");
        }
        this._validateDeps();
        this.phase = "initializing";
        try {
          const caches = [];
          this.caches.forEach((cache) => caches.push(cache.client.start()));
          await Promise.all(caches);
          await this._invoke("onPreStart");
          this.heavy.start();
          this.phase = "initialized";
          if (this.controlled) {
            await Promise.all(this.controlled.map((control) => control.initialize()));
          }
        } catch (err) {
          this.phase = "invalid";
          throw err;
        }
      }
      _validateDeps() {
        for (const { deps, plugin } of this.dependencies) {
          for (const dep in deps) {
            const version = deps[dep];
            Hoek.assert(this.registrations[dep], "Plugin", plugin, "missing dependency", dep);
            Hoek.assert(version === "*" || Somever.match(this.registrations[dep].version, version), "Plugin", plugin, "requires", dep, "version", version, "but found", this.registrations[dep].version);
          }
        }
      }
      async _stop(options = {}) {
        options.timeout = options.timeout || 5e3;
        if (["stopped", "initialized", "started", "invalid"].indexOf(this.phase) === -1) {
          throw new Error("Cannot stop server while in " + this.phase + " phase");
        }
        this.phase = "stopping";
        try {
          await this._invoke("onPreStop");
          if (this.started) {
            this.started = false;
            this.info.started = 0;
            await this._unlisten(options.timeout);
          }
          const caches = [];
          this.caches.forEach((cache) => caches.push(cache.client.stop()));
          await Promise.all(caches);
          await this.events.emit("stop");
          this.heavy.stop();
          if (this.controlled) {
            await Promise.all(this.controlled.map((control) => control.stop(options)));
          }
          await this._invoke("onPostStop");
          this.phase = "stopped";
        } catch (err) {
          this.phase = "invalid";
          throw err;
        }
      }
      _unlisten(timeout) {
        let timeoutId = null;
        if (this.settings.operations.cleanStop) {
          const destroy = () => {
            for (const connection of this.sockets) {
              connection.destroy();
            }
            this.sockets.clear();
          };
          timeoutId = setTimeout(destroy, timeout);
          for (const connection of this.sockets) {
            if (!this.actives.has(connection)) {
              connection.end();
            }
          }
        }
        return new Promise((resolve) => {
          this.listener.close(() => {
            if (this.settings.operations.cleanStop) {
              this.listener.removeListener(this.settings.tls ? "secureConnection" : "connection", this.onConnection);
              clearTimeout(timeoutId);
            }
            this._initializeListener();
            resolve();
          });
          this.events.emit("closing");
        });
      }
      async _invoke(type) {
        const exts = this.extensions.server[type];
        if (!exts.nodes) {
          return;
        }
        for (const ext of exts.nodes) {
          const bind = ext.bind || ext.realm.settings.bind;
          const operation = ext.func.call(bind, ext.server, bind);
          await Toolkit.timed(operation, { timeout: ext.timeout, name: type });
        }
      }
      _defaultRoutes() {
        this.router.special("notFound", new Route({ method: "_special", path: "/{p*}", handler: internals.notFound }, this.root, { special: true }));
        this.router.special("badRequest", new Route({ method: "_special", path: "/{p*}", handler: internals.badRequest }, this.root, { special: true }));
        if (this.settings.routes.cors) {
          Cors.handler(this.root);
        }
      }
      _dispatch(options = {}) {
        return (req, res) => {
          const request = Request.generate(this.root, req, res, options);
          if (this.settings.operations.cleanStop && req.socket) {
            this.actives.set(req.socket, request);
            const env = { core: this, req };
            res.on("finish", internals.onFinish.bind(res, env));
          }
          if (this.settings.load.sampleInterval) {
            try {
              this.heavy.check();
            } catch (err) {
              Bounce.rethrow(err, "system");
              this._log(["load"], this.heavy.load);
              request._reply(err);
              return;
            }
          }
          request._execute();
        };
      }
      _createListener() {
        const listener = this.settings.listener || (this.settings.tls ? Https.createServer(this.settings.tls) : Http.createServer());
        listener.on("request", this._dispatch());
        listener.on("checkContinue", this._dispatch({ expectContinue: true }));
        listener.on("clientError", (err, socket) => {
          this._log(["connection", "client", "error"], err);
          if (socket.readable) {
            const request = this.settings.operations.cleanStop && this.actives.get(socket);
            if (request) {
              const error = Boom.badRequest();
              error.output.headers = { connection: "close" };
              request._reply(error);
            } else {
              socket.end(internals.badRequestResponse);
            }
          } else {
            socket.destroy(err);
          }
        });
        return listener;
      }
      _initializeListener() {
        this.listener.once("listening", () => {
          if (this.type === "tcp") {
            const address = this.listener.address();
            this.info.address = address.address;
            this.info.port = address.port;
            this.info.uri = this.settings.uri || this.info.protocol + "://" + this.info.host + ":" + this.info.port;
          }
          if (this.settings.operations.cleanStop) {
            this.sockets = /* @__PURE__ */ new Set();
            const self2 = this;
            const onClose = function() {
              self2.sockets.delete(this);
            };
            this.onConnection = (connection) => {
              this.sockets.add(connection);
              connection.on("close", onClose);
            };
            this.listener.on(this.settings.tls ? "secureConnection" : "connection", this.onConnection);
          }
        });
      }
      _cachePolicy(options, _segment, realm) {
        options = Config.apply("cachePolicy", options);
        const plugin = realm && realm.plugin;
        const segment = options.segment || _segment || (plugin ? `!${plugin}` : "");
        Hoek.assert(segment, "Missing cache segment name");
        const cacheName = options.cache || "_default";
        const cache = this.caches.get(cacheName);
        Hoek.assert(cache, "Unknown cache", cacheName);
        Hoek.assert(!cache.segments[segment] || cache.shared || options.shared, "Cannot provision the same cache segment more than once");
        cache.segments[segment] = true;
        const policy = new Catbox.Policy(options, cache.client, segment);
        this.events.emit("cachePolicy", [policy, options.cache, segment]);
        return policy;
      }
      log(tags, data) {
        return this._log(tags, data, "app");
      }
      _log(tags, data, channel = "internal") {
        if (!this.events.hasListeners("log")) {
          return;
        }
        if (!Array.isArray(tags)) {
          tags = [tags];
        }
        const timestamp = Date.now();
        const field = data instanceof Error ? "error" : "data";
        let event = { timestamp, tags, [field]: data, channel };
        if (typeof data === "function") {
          event = () => ({ timestamp, tags, data: data(), channel });
        }
        this.events.emit({ name: "log", tags, channel }, event);
      }
    };
    internals.setup = function(options = {}) {
      let settings = Hoek.clone(options, { shallow: ["cache", "listener", "routes.bind"] });
      settings.app = settings.app || {};
      settings.routes = Config.enable(settings.routes);
      settings = Config.apply("server", settings);
      if (settings.port === void 0) {
        settings.port = 0;
      }
      const type = typeof settings.port === "string" ? "socket" : "tcp";
      if (type === "socket") {
        settings.port = settings.port.indexOf("/") !== -1 ? Path.resolve(settings.port) : settings.port.toLowerCase();
      }
      if (settings.autoListen === void 0) {
        settings.autoListen = true;
      }
      Hoek.assert(settings.autoListen || !settings.port, "Cannot specify port when autoListen is false");
      Hoek.assert(settings.autoListen || !settings.address, "Cannot specify address when autoListen is false");
      return { settings, type };
    };
    internals.notFound = function() {
      throw Boom.notFound();
    };
    internals.badRequest = function() {
      throw Boom.badRequest();
    };
    internals.onFinish = function(env) {
      const { core, req } = env;
      core.actives.delete(req.socket);
      if (!core.started) {
        req.socket.end();
      }
    };
  }
});

// node_modules/@hapi/hapi/package.json
var require_package2 = __commonJS({
  "node_modules/@hapi/hapi/package.json"(exports, module2) {
    module2.exports = {
      name: "@hapi/hapi",
      description: "HTTP Server framework",
      homepage: "https://hapi.dev",
      version: "20.2.2",
      repository: "git://github.com/hapijs/hapi",
      main: "lib/index.js",
      engines: {
        node: ">=12.0.0"
      },
      files: [
        "lib"
      ],
      keywords: [
        "framework",
        "http",
        "api",
        "web"
      ],
      eslintConfig: {
        extends: [
          "plugin:@hapi/module"
        ]
      },
      dependencies: {
        "@hapi/accept": "^5.0.1",
        "@hapi/ammo": "^5.0.1",
        "@hapi/boom": "^9.1.0",
        "@hapi/bounce": "^2.0.0",
        "@hapi/call": "^8.0.0",
        "@hapi/catbox": "^11.1.1",
        "@hapi/catbox-memory": "^5.0.0",
        "@hapi/heavy": "^7.0.1",
        "@hapi/hoek": "^9.0.4",
        "@hapi/mimos": "^6.0.0",
        "@hapi/podium": "^4.1.1",
        "@hapi/shot": "^5.0.5",
        "@hapi/somever": "^3.0.0",
        "@hapi/statehood": "^7.0.4",
        "@hapi/subtext": "^7.0.3",
        "@hapi/teamwork": "^5.1.1",
        "@hapi/topo": "^5.0.0",
        "@hapi/validate": "^1.1.1"
      },
      devDependencies: {
        "@hapi/code": "^8.0.0",
        "@hapi/eslint-plugin": "*",
        "@hapi/inert": "^6.0.2",
        "@hapi/joi-legacy-test": "npm:@hapi/joi@^15.0.0",
        "@hapi/lab": "^24.4.0",
        "@hapi/vision": "^6.0.1",
        "@hapi/wreck": "^17.0.0",
        handlebars: "^4.7.4",
        joi: "^17.0.0",
        "legacy-readable-stream": "npm:readable-stream@^1.0.34"
      },
      scripts: {
        test: "lab -a @hapi/code -t 100 -L -m 5000",
        "test-tap": "lab -a @hapi/code -r tap -o tests.tap -m 5000",
        "test-cov-html": "lab -a @hapi/code -r html -o coverage.html -m 5000"
      },
      license: "BSD-3-Clause"
    };
  }
});

// node_modules/@hapi/hapi/lib/server.js
var require_server = __commonJS({
  "node_modules/@hapi/hapi/lib/server.js"(exports, module2) {
    "use strict";
    var Hoek = require_lib();
    var Shot = require_lib4();
    var Somever = require_lib7();
    var Teamwork = require_lib8();
    var Config = require_config();
    var Core = require_core();
    var Cors = require_cors();
    var Ext = require_ext();
    var Package = require_package2();
    var Route = require_route();
    var Toolkit = require_toolkit();
    var Validation = require_validation();
    var internals = {};
    exports = module2.exports = function(options) {
      const core = new Core(options);
      return new internals.Server(core);
    };
    internals.Server = class {
      constructor(core, name, parent) {
        this._core = core;
        this.app = core.app;
        this.auth = core.auth.public(this);
        this.decorations = core.decorations.public;
        this.cache = internals.cache(this);
        this.events = core.events;
        this.info = core.info;
        this.listener = core.listener;
        this.load = core.heavy.load;
        this.methods = core.methods.methods;
        this.mime = core.mime;
        this.plugins = core.plugins;
        this.registrations = core.registrations;
        this.settings = core.settings;
        this.states = core.states;
        this.type = core.type;
        this.version = Package.version;
        this.realm = {
          _extensions: {
            onPreAuth: new Ext("onPreAuth", core),
            onCredentials: new Ext("onCredentials", core),
            onPostAuth: new Ext("onPostAuth", core),
            onPreHandler: new Ext("onPreHandler", core),
            onPostHandler: new Ext("onPostHandler", core),
            onPreResponse: new Ext("onPreResponse", core),
            onPostResponse: new Ext("onPostResponse", core)
          },
          modifiers: {
            route: {}
          },
          parent: parent ? parent.realm : null,
          plugin: name,
          pluginOptions: {},
          plugins: {},
          _rules: null,
          settings: {
            bind: void 0,
            files: {
              relativeTo: void 0
            }
          },
          validator: null
        };
        for (const [property, method] of core.decorations.server.entries()) {
          this[property] = method;
        }
        core.registerServer(this);
      }
      _clone(name) {
        return new internals.Server(this._core, name, this);
      }
      bind(context) {
        Hoek.assert(typeof context === "object", "bind must be an object");
        this.realm.settings.bind = context;
      }
      control(server3) {
        Hoek.assert(server3 instanceof internals.Server, "Can only control Server objects");
        this._core.controlled = this._core.controlled || [];
        this._core.controlled.push(server3);
      }
      decoder(encoding, decoder) {
        return this._core.compression.addDecoder(encoding, decoder);
      }
      decorate(type, property, method, options = {}) {
        Hoek.assert(this._core.decorations.public[type], "Unknown decoration type:", type);
        Hoek.assert(property, "Missing decoration property name");
        Hoek.assert(typeof property === "string" || typeof property === "symbol", "Decoration property must be a string or a symbol");
        const propertyName = property.toString();
        Hoek.assert(propertyName[0] !== "_", "Property name cannot begin with an underscore:", propertyName);
        const existing = this._core.decorations[type].get(property);
        if (options.extend) {
          Hoek.assert(type !== "handler", "Cannot extent handler decoration:", propertyName);
          Hoek.assert(existing, `Cannot extend missing ${type} decoration: ${propertyName}`);
          Hoek.assert(typeof method === "function", `Extended ${type} decoration method must be a function: ${propertyName}`);
          method = method(existing);
        } else {
          Hoek.assert(existing === void 0, `${type[0].toUpperCase() + type.slice(1)} decoration already defined: ${propertyName}`);
        }
        if (type === "handler") {
          Hoek.assert(typeof method === "function", "Handler must be a function:", propertyName);
          Hoek.assert(!method.defaults || typeof method.defaults === "object" || typeof method.defaults === "function", "Handler defaults property must be an object or function");
          Hoek.assert(!options.extend, "Cannot extend handler decoration:", propertyName);
        } else if (type === "request") {
          Hoek.assert(!this._core.Request.reserved.includes(property), "Cannot override built-in request interface decoration:", propertyName);
          if (options.apply) {
            this._core.decorations.requestApply = this._core.decorations.requestApply || /* @__PURE__ */ new Map();
            this._core.decorations.requestApply.set(property, method);
          } else {
            this._core.Request.prototype[property] = method;
          }
        } else if (type === "response") {
          Hoek.assert(!this._core.Response.reserved.includes(property), "Cannot override built-in response interface decoration:", propertyName);
          this._core.Response.prototype[property] = method;
        } else if (type === "toolkit") {
          Hoek.assert(!Toolkit.reserved.includes(property), "Cannot override built-in toolkit decoration:", propertyName);
          this._core.toolkit.decorate(property, method);
        } else {
          if (typeof property === "string") {
            Hoek.assert(!Object.getOwnPropertyNames(internals.Server.prototype).includes(property), "Cannot override the built-in server interface method:", propertyName);
          } else {
            Hoek.assert(!Object.getOwnPropertySymbols(internals.Server.prototype).includes(property), "Cannot override the built-in server interface method:", propertyName);
          }
          this._core.instances.forEach((server3) => {
            server3[property] = method;
          });
        }
        this._core.decorations[type].set(property, method);
        this._core.decorations.public[type].push(property);
      }
      dependency(dependencies, after) {
        Hoek.assert(this.realm.plugin, "Cannot call dependency() outside of a plugin");
        Hoek.assert(!after || typeof after === "function", "Invalid after method");
        if (typeof dependencies === "string") {
          dependencies = { [dependencies]: "*" };
        } else if (Array.isArray(dependencies)) {
          const map = {};
          for (const dependency of dependencies) {
            map[dependency] = "*";
          }
          dependencies = map;
        }
        this._core.dependencies.push({ plugin: this.realm.plugin, deps: dependencies });
        if (after) {
          this.ext("onPreStart", after, { after: Object.keys(dependencies) });
        }
      }
      encoder(encoding, encoder) {
        return this._core.compression.addEncoder(encoding, encoder);
      }
      event(event) {
        this._core.events.registerEvent(event);
      }
      expose(key, value, options = {}) {
        Hoek.assert(this.realm.plugin, "Cannot call expose() outside of a plugin");
        let plugin = this.realm.plugin;
        if (plugin[0] === "@" && options.scope !== true) {
          plugin = plugin.replace(/^@([^/]+)\//, ($0, $1) => {
            return !options.scope ? "" : `${$1}__`;
          });
        }
        this._core.plugins[plugin] = this._core.plugins[plugin] || {};
        if (typeof key === "string") {
          this._core.plugins[plugin][key] = value;
        } else {
          Hoek.merge(this._core.plugins[plugin], key);
        }
      }
      ext(events, method, options) {
        let promise;
        if (typeof events === "string") {
          if (!method) {
            const team = new Teamwork.Team();
            method = (request, h) => {
              team.attend(request);
              return h.continue;
            };
            promise = team.work;
          }
          events = { type: events, method, options };
        }
        events = Config.apply("exts", events);
        for (const event of events) {
          this._ext(event);
        }
        return promise;
      }
      _ext(event) {
        event = Object.assign({}, event);
        event.realm = this.realm;
        const type = event.type;
        if (!this._core.extensions.server[type]) {
          if (event.options.sandbox === "plugin") {
            Hoek.assert(this.realm._extensions[type], "Unknown event type", type);
            return this.realm._extensions[type].add(event);
          }
          Hoek.assert(this._core.extensions.route[type], "Unknown event type", type);
          return this._core.extensions.route[type].add(event);
        }
        Hoek.assert(!event.options.sandbox, "Cannot specify sandbox option for server extension");
        Hoek.assert(type !== "onPreStart" || this._core.phase === "stopped", "Cannot add onPreStart (after) extension after the server was initialized");
        event.server = this;
        this._core.extensions.server[type].add(event);
      }
      async inject(options) {
        let settings = options;
        if (typeof settings === "string") {
          settings = { url: settings };
        }
        if (!settings.authority || settings.auth || settings.app || settings.plugins || settings.allowInternals !== void 0) {
          settings = Object.assign({}, settings);
          delete settings.auth;
          delete settings.app;
          delete settings.plugins;
          delete settings.allowInternals;
          settings.authority = settings.authority || this._core.info.host + ":" + this._core.info.port;
        }
        Hoek.assert(!options.credentials, "options.credentials no longer supported (use options.auth)");
        if (options.auth) {
          Hoek.assert(typeof options.auth === "object", "options.auth must be an object");
          Hoek.assert(options.auth.credentials, "options.auth.credentials is missing");
          Hoek.assert(options.auth.strategy, "options.auth.strategy is missing");
        }
        const needle = this._core._dispatch({
          auth: options.auth,
          allowInternals: options.allowInternals,
          app: options.app,
          plugins: options.plugins,
          isInjected: true
        });
        const res = await Shot.inject(needle, settings);
        const custom = res.raw.res[Config.symbol];
        if (custom) {
          delete res.raw.res[Config.symbol];
          res.request = custom.request;
          if (custom.error) {
            throw custom.error;
          }
          if (custom.result !== void 0) {
            res.result = custom.result;
          }
        }
        if (res.result === void 0) {
          res.result = res.payload;
        }
        return res;
      }
      log(tags, data) {
        return this._core.log(tags, data);
      }
      lookup(id) {
        Hoek.assert(id && typeof id === "string", "Invalid route id:", id);
        const record = this._core.router.ids.get(id);
        if (!record) {
          return null;
        }
        return record.route.public;
      }
      match(method, path, host) {
        Hoek.assert(method && typeof method === "string", "Invalid method:", method);
        Hoek.assert(path && typeof path === "string" && path[0] === "/", "Invalid path:", path);
        Hoek.assert(!host || typeof host === "string", "Invalid host:", host);
        const match = this._core.router.route(method.toLowerCase(), path, host);
        Hoek.assert(match !== this._core.router.specials.badRequest, "Invalid path:", path);
        if (match === this._core.router.specials.notFound) {
          return null;
        }
        return match.route.public;
      }
      method(name, method, options = {}) {
        return this._core.methods.add(name, method, options, this.realm);
      }
      path(relativeTo) {
        Hoek.assert(relativeTo && typeof relativeTo === "string", "relativeTo must be a non-empty string");
        this.realm.settings.files.relativeTo = relativeTo;
      }
      async register(plugins, options = {}) {
        if (this.realm.modifiers.route.prefix || this.realm.modifiers.route.vhost) {
          options = Hoek.clone(options);
          options.routes = options.routes || {};
          options.routes.prefix = (this.realm.modifiers.route.prefix || "") + (options.routes.prefix || "") || void 0;
          options.routes.vhost = this.realm.modifiers.route.vhost || options.routes.vhost;
        }
        options = Config.apply("register", options);
        ++this._core.registring;
        try {
          const items = [].concat(plugins);
          for (let item of items) {
            if (!item.plugin) {
              item = {
                plugin: item
              };
            } else if (!item.plugin.register) {
              item = {
                options: item.options,
                once: item.once,
                routes: item.routes,
                plugin: item.plugin.plugin
              };
            } else if (typeof item === "function") {
              item = Object.assign({}, item);
            }
            item = Config.apply("plugin", item);
            const name = item.plugin.name || item.plugin.pkg.name;
            const clone = this._clone(name);
            clone.realm.modifiers.route.prefix = item.routes.prefix || options.routes.prefix;
            clone.realm.modifiers.route.vhost = item.routes.vhost || options.routes.vhost;
            clone.realm.pluginOptions = item.options || {};
            const requirements = item.plugin.requirements;
            Hoek.assert(!requirements.node || Somever.match(process.version, requirements.node), "Plugin", name, "requires node version", requirements.node, "but found", process.version);
            Hoek.assert(!requirements.hapi || Somever.match(this.version, requirements.hapi), "Plugin", name, "requires hapi version", requirements.hapi, "but found", this.version);
            if (this._core.registrations[name]) {
              if (item.plugin.once || item.once || options.once) {
                continue;
              }
              Hoek.assert(item.plugin.multiple, "Plugin", name, "already registered");
            } else {
              this._core.registrations[name] = {
                version: item.plugin.version || item.plugin.pkg.version,
                name,
                options: item.options
              };
            }
            if (item.plugin.dependencies) {
              clone.dependency(item.plugin.dependencies);
            }
            await item.plugin.register(clone, item.options || {});
          }
        } finally {
          --this._core.registring;
        }
      }
      route(options) {
        Hoek.assert(typeof options === "object", "Invalid route options");
        options = [].concat(options);
        for (const config of options) {
          if (Array.isArray(config.method)) {
            for (const method of config.method) {
              const settings = Object.assign({}, config);
              settings.method = method;
              this._addRoute(settings, this);
            }
          } else {
            this._addRoute(config, this);
          }
        }
      }
      _addRoute(config, server3) {
        const route = new Route(config, server3);
        const vhosts = [].concat(route.settings.vhost || "*");
        for (const vhost of vhosts) {
          const record = this._core.router.add({ method: route.method, path: route.path, vhost, analysis: route._analysis, id: route.settings.id }, route);
          route.fingerprint = record.fingerprint;
          route.params = record.params;
        }
        this.events.emit("route", route.public);
        Cors.options(route.public, server3);
      }
      rules(processor, options = {}) {
        Hoek.assert(!this.realm._rules, "Server realm rules already defined");
        const settings = Config.apply("rules", options);
        if (settings.validate) {
          const schema = settings.validate.schema;
          settings.validate.schema = Validation.compile(schema, null, this.realm, this._core);
        }
        this.realm._rules = { processor, settings };
      }
      state(name, options) {
        this.states.add(name, options);
      }
      table(host) {
        return this._core.router.table(host);
      }
      validator(validator) {
        Hoek.assert(!this.realm.validator, "Validator already set");
        this.realm.validator = Validation.validator(validator);
      }
      start() {
        return this._core._start();
      }
      initialize() {
        return this._core._initialize();
      }
      stop(options) {
        return this._core._stop(options);
      }
    };
    internals.cache = (plugin) => {
      const policy = function(options, _segment) {
        return this._core._cachePolicy(options, _segment, plugin.realm);
      };
      policy.provision = async (opts) => {
        const clients = plugin._core._createCache(opts);
        if (["initialized", "starting", "started"].includes(plugin._core.phase)) {
          await Promise.all(clients.map((client) => client.start()));
        }
      };
      return policy;
    };
  }
});

// node_modules/@hapi/hapi/lib/index.js
var require_lib29 = __commonJS({
  "node_modules/@hapi/hapi/lib/index.js"(exports) {
    "use strict";
    var Server = require_server();
    exports.Server = Server;
    exports.server = Server;
  }
});

// node_modules/@hapi/joi/package.json
var require_package3 = __commonJS({
  "node_modules/@hapi/joi/package.json"(exports, module2) {
    module2.exports = {
      name: "@hapi/joi",
      description: "Object schema validation",
      version: "17.1.1",
      repository: "git://github.com/hapijs/joi",
      main: "lib/index.js",
      browser: "dist/joi-browser.min.js",
      files: [
        "lib/**/*",
        "dist/*"
      ],
      keywords: [
        "schema",
        "validation"
      ],
      dependencies: {
        "@hapi/address": "^4.0.1",
        "@hapi/formula": "^2.0.0",
        "@hapi/hoek": "^9.0.0",
        "@hapi/pinpoint": "^2.0.0",
        "@hapi/topo": "^5.0.0"
      },
      devDependencies: {
        "@hapi/bourne": "2.x.x",
        "@hapi/code": "8.x.x",
        "@hapi/lab": "22.x.x",
        "@hapi/joi-legacy-test": "npm:@hapi/joi@15.x.x"
      },
      scripts: {
        prepublishOnly: "cd browser && npm install && npm run build",
        test: "lab -t 100 -a @hapi/code -L",
        "test-cov-html": "lab -r html -o coverage.html -a @hapi/code"
      },
      license: "BSD-3-Clause"
    };
  }
});

// node_modules/@hapi/joi/lib/schemas.js
var require_schemas2 = __commonJS({
  "node_modules/@hapi/joi/lib/schemas.js"(exports) {
    "use strict";
    var Joi2 = require_lib32();
    var internals = {};
    internals.wrap = Joi2.string().min(1).max(2).allow(false);
    exports.preferences = Joi2.object({
      allowUnknown: Joi2.boolean(),
      abortEarly: Joi2.boolean(),
      cache: Joi2.boolean(),
      context: Joi2.object(),
      convert: Joi2.boolean(),
      dateFormat: Joi2.valid("date", "iso", "string", "time", "utc"),
      debug: Joi2.boolean(),
      errors: {
        escapeHtml: Joi2.boolean(),
        label: Joi2.valid("path", "key", false),
        language: [
          Joi2.string(),
          Joi2.object().ref()
        ],
        render: Joi2.boolean(),
        stack: Joi2.boolean(),
        wrap: {
          label: internals.wrap,
          array: internals.wrap
        }
      },
      externals: Joi2.boolean(),
      messages: Joi2.object(),
      noDefaults: Joi2.boolean(),
      nonEnumerables: Joi2.boolean(),
      presence: Joi2.valid("required", "optional", "forbidden"),
      skipFunctions: Joi2.boolean(),
      stripUnknown: Joi2.object({
        arrays: Joi2.boolean(),
        objects: Joi2.boolean()
      }).or("arrays", "objects").allow(true, false),
      warnings: Joi2.boolean()
    }).strict();
    internals.nameRx = /^[a-zA-Z0-9]\w*$/;
    internals.rule = Joi2.object({
      alias: Joi2.array().items(Joi2.string().pattern(internals.nameRx)).single(),
      args: Joi2.array().items(
        Joi2.string(),
        Joi2.object({
          name: Joi2.string().pattern(internals.nameRx).required(),
          ref: Joi2.boolean(),
          assert: Joi2.alternatives([
            Joi2.function(),
            Joi2.object().schema()
          ]).conditional("ref", { is: true, then: Joi2.required() }),
          normalize: Joi2.function(),
          message: Joi2.string().when("assert", { is: Joi2.function(), then: Joi2.required() })
        })
      ),
      convert: Joi2.boolean(),
      manifest: Joi2.boolean(),
      method: Joi2.function().allow(false),
      multi: Joi2.boolean(),
      validate: Joi2.function()
    });
    exports.extension = Joi2.object({
      type: Joi2.alternatives([
        Joi2.string(),
        Joi2.object().regex()
      ]).required(),
      args: Joi2.function(),
      base: Joi2.object().schema().when("type", { is: Joi2.object().regex(), then: Joi2.forbidden() }),
      coerce: [
        Joi2.function().maxArity(3),
        Joi2.object({ method: Joi2.function().maxArity(3).required(), from: Joi2.array().items(Joi2.string()).single() })
      ],
      flags: Joi2.object().pattern(internals.nameRx, Joi2.object({
        setter: Joi2.string(),
        default: Joi2.any()
      })),
      manifest: {
        build: Joi2.function().arity(2)
      },
      messages: [Joi2.object(), Joi2.string()],
      modifiers: Joi2.object().pattern(internals.nameRx, Joi2.function().minArity(1).maxArity(2)),
      overrides: Joi2.object().pattern(internals.nameRx, Joi2.function()),
      prepare: Joi2.function().maxArity(3),
      rebuild: Joi2.function().arity(1),
      rules: Joi2.object().pattern(internals.nameRx, internals.rule),
      terms: Joi2.object().pattern(internals.nameRx, Joi2.object({
        init: Joi2.array().allow(null).required(),
        manifest: Joi2.object().pattern(/.+/, [
          Joi2.valid("schema", "single"),
          Joi2.object({
            mapped: Joi2.object({
              from: Joi2.string().required(),
              to: Joi2.string().required()
            }).required()
          })
        ])
      })),
      validate: Joi2.function().maxArity(3)
    }).strict();
    exports.extensions = Joi2.array().items(Joi2.object(), Joi2.function().arity(1)).strict();
    internals.desc = {
      buffer: Joi2.object({
        buffer: Joi2.string()
      }),
      func: Joi2.object({
        function: Joi2.function().required(),
        options: {
          literal: true
        }
      }),
      override: Joi2.object({
        override: true
      }),
      ref: Joi2.object({
        ref: Joi2.object({
          type: Joi2.valid("value", "global", "local"),
          path: Joi2.array().required(),
          separator: Joi2.string().length(1).allow(false),
          ancestor: Joi2.number().min(0).integer().allow("root"),
          map: Joi2.array().items(Joi2.array().length(2)).min(1),
          adjust: Joi2.function(),
          iterables: Joi2.boolean(),
          in: Joi2.boolean()
        }).required()
      }),
      regex: Joi2.object({
        regex: Joi2.string().min(3)
      }),
      special: Joi2.object({
        special: Joi2.valid("deep").required()
      }),
      template: Joi2.object({
        template: Joi2.string().required(),
        options: Joi2.object()
      }),
      value: Joi2.object({
        value: Joi2.alternatives([Joi2.object(), Joi2.array()]).required()
      })
    };
    internals.desc.entity = Joi2.alternatives([
      Joi2.array().items(Joi2.link("...")),
      Joi2.boolean(),
      Joi2.function(),
      Joi2.number(),
      Joi2.string(),
      internals.desc.buffer,
      internals.desc.func,
      internals.desc.ref,
      internals.desc.regex,
      internals.desc.special,
      internals.desc.template,
      internals.desc.value,
      Joi2.link("/")
    ]);
    internals.desc.values = Joi2.array().items(
      null,
      Joi2.boolean(),
      Joi2.function(),
      Joi2.number().allow(Infinity, -Infinity),
      Joi2.string().allow(""),
      Joi2.symbol(),
      internals.desc.buffer,
      internals.desc.func,
      internals.desc.override,
      internals.desc.ref,
      internals.desc.regex,
      internals.desc.template,
      internals.desc.value
    );
    internals.desc.messages = Joi2.object().pattern(/.+/, [
      Joi2.string(),
      internals.desc.template,
      Joi2.object().pattern(/.+/, [Joi2.string(), internals.desc.template])
    ]);
    exports.description = Joi2.object({
      type: Joi2.string().required(),
      flags: Joi2.object({
        cast: Joi2.string(),
        default: Joi2.any(),
        description: Joi2.string(),
        empty: Joi2.link("/"),
        failover: internals.desc.entity,
        id: Joi2.string(),
        label: Joi2.string(),
        only: true,
        presence: ["optional", "required", "forbidden"],
        result: ["raw", "strip"],
        strip: Joi2.boolean(),
        unit: Joi2.string()
      }).unknown(),
      preferences: {
        allowUnknown: Joi2.boolean(),
        abortEarly: Joi2.boolean(),
        cache: Joi2.boolean(),
        convert: Joi2.boolean(),
        dateFormat: ["date", "iso", "string", "time", "utc"],
        errors: {
          escapeHtml: Joi2.boolean(),
          label: ["path", "key"],
          language: [
            Joi2.string(),
            internals.desc.ref
          ],
          wrap: {
            label: internals.wrap,
            array: internals.wrap
          }
        },
        externals: Joi2.boolean(),
        messages: internals.desc.messages,
        noDefaults: Joi2.boolean(),
        nonEnumerables: Joi2.boolean(),
        presence: ["required", "optional", "forbidden"],
        skipFunctions: Joi2.boolean(),
        stripUnknown: Joi2.object({
          arrays: Joi2.boolean(),
          objects: Joi2.boolean()
        }).or("arrays", "objects").allow(true, false),
        warnings: Joi2.boolean()
      },
      allow: internals.desc.values,
      invalid: internals.desc.values,
      rules: Joi2.array().min(1).items({
        name: Joi2.string().required(),
        args: Joi2.object().min(1),
        keep: Joi2.boolean(),
        message: [
          Joi2.string(),
          internals.desc.messages
        ],
        warn: Joi2.boolean()
      }),
      keys: Joi2.object().pattern(/.*/, Joi2.link("/")),
      link: internals.desc.ref
    }).pattern(/^[a-z]\w*$/, Joi2.any());
  }
});

// node_modules/@hapi/formula/lib/index.js
var require_lib30 = __commonJS({
  "node_modules/@hapi/formula/lib/index.js"(exports) {
    "use strict";
    var internals = {
      operators: ["!", "^", "*", "/", "%", "+", "-", "<", "<=", ">", ">=", "==", "!=", "&&", "||", "??"],
      operatorCharacters: ["!", "^", "*", "/", "%", "+", "-", "<", "=", ">", "&", "|", "?"],
      operatorsOrder: [["^"], ["*", "/", "%"], ["+", "-"], ["<", "<=", ">", ">="], ["==", "!="], ["&&"], ["||", "??"]],
      operatorsPrefix: ["!", "n"],
      literals: {
        '"': '"',
        "`": "`",
        "'": "'",
        "[": "]"
      },
      numberRx: /^(?:[0-9]*\.?[0-9]*){1}$/,
      tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,
      symbol: Symbol("formula"),
      settings: Symbol("settings")
    };
    exports.Parser = class {
      constructor(string, options = {}) {
        if (!options[internals.settings] && options.constants) {
          for (const constant in options.constants) {
            const value = options.constants[constant];
            if (value !== null && !["boolean", "number", "string"].includes(typeof value)) {
              throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);
            }
          }
        }
        this.settings = options[internals.settings] ? options : Object.assign({ [internals.settings]: true, constants: {}, functions: {} }, options);
        this.single = null;
        this._parts = null;
        this._parse(string);
      }
      _parse(string) {
        let parts = [];
        let current = "";
        let parenthesis = 0;
        let literal = false;
        const flush = (inner) => {
          if (parenthesis) {
            throw new Error("Formula missing closing parenthesis");
          }
          const last = parts.length ? parts[parts.length - 1] : null;
          if (!literal && !current && !inner) {
            return;
          }
          if (last && last.type === "reference" && inner === ")") {
            last.type = "function";
            last.value = this._subFormula(current, last.value);
            current = "";
            return;
          }
          if (inner === ")") {
            const sub = new exports.Parser(current, this.settings);
            parts.push({ type: "segment", value: sub });
          } else if (literal) {
            if (literal === "]") {
              parts.push({ type: "reference", value: current });
              current = "";
              return;
            }
            parts.push({ type: "literal", value: current });
          } else if (internals.operatorCharacters.includes(current)) {
            if (last && last.type === "operator" && internals.operators.includes(last.value + current)) {
              last.value += current;
            } else {
              parts.push({ type: "operator", value: current });
            }
          } else if (current.match(internals.numberRx)) {
            parts.push({ type: "constant", value: parseFloat(current) });
          } else if (this.settings.constants[current] !== void 0) {
            parts.push({ type: "constant", value: this.settings.constants[current] });
          } else {
            if (!current.match(internals.tokenRx)) {
              throw new Error(`Formula contains invalid token: ${current}`);
            }
            parts.push({ type: "reference", value: current });
          }
          current = "";
        };
        for (const c of string) {
          if (literal) {
            if (c === literal) {
              flush();
              literal = false;
            } else {
              current += c;
            }
          } else if (parenthesis) {
            if (c === "(") {
              current += c;
              ++parenthesis;
            } else if (c === ")") {
              --parenthesis;
              if (!parenthesis) {
                flush(c);
              } else {
                current += c;
              }
            } else {
              current += c;
            }
          } else if (c in internals.literals) {
            literal = internals.literals[c];
          } else if (c === "(") {
            flush();
            ++parenthesis;
          } else if (internals.operatorCharacters.includes(c)) {
            flush();
            current = c;
            flush();
          } else if (c !== " ") {
            current += c;
          } else {
            flush();
          }
        }
        flush();
        parts = parts.map((part, i) => {
          if (part.type !== "operator" || part.value !== "-" || i && parts[i - 1].type !== "operator") {
            return part;
          }
          return { type: "operator", value: "n" };
        });
        let operator = false;
        for (const part of parts) {
          if (part.type === "operator") {
            if (internals.operatorsPrefix.includes(part.value)) {
              continue;
            }
            if (!operator) {
              throw new Error("Formula contains an operator in invalid position");
            }
            if (!internals.operators.includes(part.value)) {
              throw new Error(`Formula contains an unknown operator ${part.value}`);
            }
          } else if (operator) {
            throw new Error("Formula missing expected operator");
          }
          operator = !operator;
        }
        if (!operator) {
          throw new Error("Formula contains invalid trailing operator");
        }
        if (parts.length === 1 && ["reference", "literal", "constant"].includes(parts[0].type)) {
          this.single = { type: parts[0].type === "reference" ? "reference" : "value", value: parts[0].value };
        }
        this._parts = parts.map((part) => {
          if (part.type === "operator") {
            return internals.operatorsPrefix.includes(part.value) ? part : part.value;
          }
          if (part.type !== "reference") {
            return part.value;
          }
          if (this.settings.tokenRx && !this.settings.tokenRx.test(part.value)) {
            throw new Error(`Formula contains invalid reference ${part.value}`);
          }
          if (this.settings.reference) {
            return this.settings.reference(part.value);
          }
          return internals.reference(part.value);
        });
      }
      _subFormula(string, name) {
        const method = this.settings.functions[name];
        if (typeof method !== "function") {
          throw new Error(`Formula contains unknown function ${name}`);
        }
        let args = [];
        if (string) {
          let current = "";
          let parenthesis = 0;
          let literal = false;
          const flush = () => {
            if (!current) {
              throw new Error(`Formula contains function ${name} with invalid arguments ${string}`);
            }
            args.push(current);
            current = "";
          };
          for (let i = 0; i < string.length; ++i) {
            const c = string[i];
            if (literal) {
              current += c;
              if (c === literal) {
                literal = false;
              }
            } else if (c in internals.literals && !parenthesis) {
              current += c;
              literal = internals.literals[c];
            } else if (c === "," && !parenthesis) {
              flush();
            } else {
              current += c;
              if (c === "(") {
                ++parenthesis;
              } else if (c === ")") {
                --parenthesis;
              }
            }
          }
          flush();
        }
        args = args.map((arg) => new exports.Parser(arg, this.settings));
        return function(context) {
          const innerValues = [];
          for (const arg of args) {
            innerValues.push(arg.evaluate(context));
          }
          return method.call(context, ...innerValues);
        };
      }
      evaluate(context) {
        const parts = this._parts.slice();
        for (let i = parts.length - 2; i >= 0; --i) {
          const part = parts[i];
          if (part && part.type === "operator") {
            const current = parts[i + 1];
            parts.splice(i + 1, 1);
            const value = internals.evaluate(current, context);
            parts[i] = internals.single(part.value, value);
          }
        }
        internals.operatorsOrder.forEach((set) => {
          for (let i = 1; i < parts.length - 1; ) {
            if (set.includes(parts[i])) {
              const operator = parts[i];
              const left = internals.evaluate(parts[i - 1], context);
              const right = internals.evaluate(parts[i + 1], context);
              parts.splice(i, 2);
              const result = internals.calculate(operator, left, right);
              parts[i - 1] = result === 0 ? 0 : result;
            } else {
              i += 2;
            }
          }
        });
        return internals.evaluate(parts[0], context);
      }
    };
    exports.Parser.prototype[internals.symbol] = true;
    internals.reference = function(name) {
      return function(context) {
        return context && context[name] !== void 0 ? context[name] : null;
      };
    };
    internals.evaluate = function(part, context) {
      if (part === null) {
        return null;
      }
      if (typeof part === "function") {
        return part(context);
      }
      if (part[internals.symbol]) {
        return part.evaluate(context);
      }
      return part;
    };
    internals.single = function(operator, value) {
      if (operator === "!") {
        return value ? false : true;
      }
      const negative = -value;
      if (negative === 0) {
        return 0;
      }
      return negative;
    };
    internals.calculate = function(operator, left, right) {
      if (operator === "??") {
        return internals.exists(left) ? left : right;
      }
      if (typeof left === "string" || typeof right === "string") {
        if (operator === "+") {
          left = internals.exists(left) ? left : "";
          right = internals.exists(right) ? right : "";
          return left + right;
        }
      } else {
        switch (operator) {
          case "^":
            return Math.pow(left, right);
          case "*":
            return left * right;
          case "/":
            return left / right;
          case "%":
            return left % right;
          case "+":
            return left + right;
          case "-":
            return left - right;
        }
      }
      switch (operator) {
        case "<":
          return left < right;
        case "<=":
          return left <= right;
        case ">":
          return left > right;
        case ">=":
          return left >= right;
        case "==":
          return left === right;
        case "!=":
          return left !== right;
        case "&&":
          return left && right;
        case "||":
          return left || right;
      }
      return null;
    };
    internals.exists = function(value) {
      return value !== null && value !== void 0;
    };
  }
});

// node_modules/@hapi/joi/lib/annotate.js
var require_annotate2 = __commonJS({
  "node_modules/@hapi/joi/lib/annotate.js"(exports) {
    "use strict";
    var Clone = require_clone();
    var Common = require_common2();
    var internals = {
      annotations: Symbol("annotations")
    };
    exports.error = function(stripColorCodes) {
      if (!this._original || typeof this._original !== "object") {
        return this.details[0].message;
      }
      const redFgEscape = stripColorCodes ? "" : "\x1B[31m";
      const redBgEscape = stripColorCodes ? "" : "\x1B[41m";
      const endColor = stripColorCodes ? "" : "\x1B[0m";
      const obj = Clone(this._original);
      for (let i = this.details.length - 1; i >= 0; --i) {
        const pos = i + 1;
        const error = this.details[i];
        const path = error.path;
        let node = obj;
        for (let j = 0; ; ++j) {
          const seg = path[j];
          if (Common.isSchema(node)) {
            node = node.clone();
          }
          if (j + 1 < path.length && typeof node[seg] !== "string") {
            node = node[seg];
          } else {
            const refAnnotations = node[internals.annotations] || { errors: {}, missing: {} };
            node[internals.annotations] = refAnnotations;
            const cacheKey = seg || error.context.key;
            if (node[seg] !== void 0) {
              refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
              refAnnotations.errors[cacheKey].push(pos);
            } else {
              refAnnotations.missing[cacheKey] = pos;
            }
            break;
          }
        }
      }
      const replacers = {
        key: /_\$key\$_([, \d]+)_\$end\$_"/g,
        missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
        arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
        specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
      };
      let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`).replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`).replace(replacers.arrayIndex, ($0, $1, $2) => `
${$2} ${redFgEscape}[${$1}]${endColor}`).replace(replacers.specials, ($0, $1) => $1);
      message = `${message}
${redFgEscape}`;
      for (let i = 0; i < this.details.length; ++i) {
        const pos = i + 1;
        message = `${message}
[${pos}] ${this.details[i].message}`;
      }
      message = message + endColor;
      return message;
    };
    internals.safeStringify = function(obj, spaces) {
      return JSON.stringify(obj, internals.serializer(), spaces);
    };
    internals.serializer = function() {
      const keys = [];
      const stack = [];
      const cycleReplacer = (key, value) => {
        if (stack[0] === value) {
          return "[Circular ~]";
        }
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };
      return function(key, value) {
        if (stack.length > 0) {
          const thisPos = stack.indexOf(this);
          if (~thisPos) {
            stack.length = thisPos + 1;
            keys.length = thisPos + 1;
            keys[thisPos] = key;
          } else {
            stack.push(this);
            keys.push(key);
          }
          if (~stack.indexOf(value)) {
            value = cycleReplacer.call(this, key, value);
          }
        } else {
          stack.push(value);
        }
        if (value) {
          const annotations = value[internals.annotations];
          if (annotations) {
            if (Array.isArray(value)) {
              const annotated = [];
              for (let i = 0; i < value.length; ++i) {
                if (annotations.errors[i]) {
                  annotated.push(`_$idx$_${annotations.errors[i].sort().join(", ")}_$end$_`);
                }
                annotated.push(value[i]);
              }
              value = annotated;
            } else {
              for (const errorKey in annotations.errors) {
                value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(", ")}_$end$_`] = value[errorKey];
                value[errorKey] = void 0;
              }
              for (const missingKey in annotations.missing) {
                value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = "__missing__";
              }
            }
            return value;
          }
        }
        if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === "function" || typeof value === "symbol") {
          return "[" + value.toString() + "]";
        }
        return value;
      };
    };
  }
});

// node_modules/@hapi/joi/lib/errors.js
var require_errors2 = __commonJS({
  "node_modules/@hapi/joi/lib/errors.js"(exports) {
    "use strict";
    var Annotate = require_annotate2();
    var Common = require_common2();
    var Template = require_template2();
    exports.Report = class {
      constructor(code, value, local2, flags, messages, state, prefs) {
        this.code = code;
        this.flags = flags;
        this.messages = messages;
        this.path = state.path;
        this.prefs = prefs;
        this.state = state;
        this.value = value;
        this.message = null;
        this.template = null;
        this.local = local2 || {};
        this.local.label = exports.label(this.flags, this.state, this.prefs, this.messages);
        if (this.value !== void 0 && !this.local.hasOwnProperty("value")) {
          this.local.value = this.value;
        }
        if (this.path.length) {
          const key = this.path[this.path.length - 1];
          if (typeof key !== "object") {
            this.local.key = key;
          }
        }
      }
      _setTemplate(template) {
        this.template = template;
        if (!this.flags.label && this.path.length === 0) {
          const localized = this._template(this.template, "root");
          if (localized) {
            this.local.label = localized;
          }
        }
      }
      toString() {
        if (this.message) {
          return this.message;
        }
        const code = this.code;
        if (!this.prefs.errors.render) {
          return this.code;
        }
        const template = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);
        if (template === void 0) {
          return `Error code "${code}" is not defined, your custom type is missing the correct messages definition`;
        }
        this.message = template.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] });
        if (!this.prefs.errors.label) {
          this.message = this.message.replace(/^"" /, "").trim();
        }
        return this.message;
      }
      _template(messages, code) {
        return exports.template(this.value, messages, code || this.code, this.state, this.prefs);
      }
    };
    exports.path = function(path) {
      let label = "";
      for (const segment of path) {
        if (typeof segment === "object") {
          continue;
        }
        if (typeof segment === "string") {
          if (label) {
            label += ".";
          }
          label += segment;
        } else {
          label += `[${segment}]`;
        }
      }
      return label;
    };
    exports.template = function(value, messages, code, state, prefs) {
      if (!messages) {
        return;
      }
      if (Template.isTemplate(messages)) {
        return code !== "root" ? messages : null;
      }
      let lang = prefs.errors.language;
      if (Common.isResolvable(lang)) {
        lang = lang.resolve(value, state, prefs);
      }
      if (lang && messages[lang] && messages[lang][code] !== void 0) {
        return messages[lang][code];
      }
      return messages[code];
    };
    exports.label = function(flags, state, prefs, messages) {
      if (flags.label) {
        return flags.label;
      }
      if (!prefs.errors.label) {
        return "";
      }
      let path = state.path;
      if (prefs.errors.label === "key" && state.path.length > 1) {
        path = state.path.slice(-1);
      }
      const normalized = exports.path(path);
      if (normalized) {
        return normalized;
      }
      return exports.template(null, prefs.messages, "root", state, prefs) || messages && exports.template(null, messages, "root", state, prefs) || "value";
    };
    exports.process = function(errors, original, prefs) {
      if (!errors) {
        return null;
      }
      const { override, message, details } = exports.details(errors);
      if (override) {
        return override;
      }
      if (prefs.errors.stack) {
        return new exports.ValidationError(message, details, original);
      }
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      const validationError = new exports.ValidationError(message, details, original);
      Error.stackTraceLimit = limit;
      return validationError;
    };
    exports.details = function(errors, options = {}) {
      let messages = [];
      const details = [];
      for (const item of errors) {
        if (item instanceof Error) {
          if (options.override !== false) {
            return { override: item };
          }
          const message2 = item.toString();
          messages.push(message2);
          details.push({
            message: message2,
            type: "override",
            context: { error: item }
          });
          continue;
        }
        const message = item.toString();
        messages.push(message);
        details.push({
          message,
          path: item.path.filter((v) => typeof v !== "object"),
          type: item.code,
          context: item.local
        });
      }
      if (messages.length > 1) {
        messages = [...new Set(messages)];
      }
      return { message: messages.join(". "), details };
    };
    exports.ValidationError = class extends Error {
      constructor(message, details, original) {
        super(message);
        this._original = original;
        this.details = details;
      }
      static isError(err) {
        return err instanceof exports.ValidationError;
      }
    };
    exports.ValidationError.prototype.isJoi = true;
    exports.ValidationError.prototype.name = "ValidationError";
    exports.ValidationError.prototype.annotate = Annotate.error;
  }
});

// node_modules/@hapi/joi/lib/ref.js
var require_ref2 = __commonJS({
  "node_modules/@hapi/joi/lib/ref.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Reach = require_reach();
    var Common = require_common2();
    var Template;
    var internals = {
      symbol: Symbol("ref"),
      defaults: {
        adjust: null,
        in: false,
        iterables: null,
        map: null,
        separator: ".",
        type: "value"
      }
    };
    exports.create = function(key, options = {}) {
      Assert(typeof key === "string", "Invalid reference key:", key);
      Common.assertOptions(options, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "separator"]);
      Assert(!options.prefix || typeof options.prefix === "object", "options.prefix must be of type object");
      const ref = Object.assign({}, internals.defaults, options);
      delete ref.prefix;
      const separator = ref.separator;
      const context = internals.context(key, separator, options.prefix);
      ref.type = context.type;
      key = context.key;
      if (ref.type === "value") {
        if (context.root) {
          Assert(!separator || key[0] !== separator, "Cannot specify relative path with root prefix");
          ref.ancestor = "root";
          if (!key) {
            key = null;
          }
        }
        if (separator && separator === key) {
          key = null;
          ref.ancestor = 0;
        } else {
          if (ref.ancestor !== void 0) {
            Assert(!separator || !key || key[0] !== separator, "Cannot combine prefix with ancestor option");
          } else {
            const [ancestor, slice] = internals.ancestor(key, separator);
            if (slice) {
              key = key.slice(slice);
              if (key === "") {
                key = null;
              }
            }
            ref.ancestor = ancestor;
          }
        }
      }
      ref.path = separator ? key === null ? [] : key.split(separator) : [key];
      return new internals.Ref(ref);
    };
    exports.in = function(key, options = {}) {
      return exports.create(key, Object.assign({}, options, { in: true }));
    };
    exports.isRef = function(ref) {
      return ref ? !!ref[Common.symbols.ref] : false;
    };
    internals.Ref = class {
      constructor(options) {
        Assert(typeof options === "object", "Invalid reference construction");
        Common.assertOptions(options, [
          "adjust",
          "ancestor",
          "in",
          "iterables",
          "map",
          "path",
          "separator",
          "type",
          "depth",
          "key",
          "root",
          "display"
        ]);
        Assert([false, void 0].includes(options.separator) || typeof options.separator === "string" && options.separator.length === 1, "Invalid separator");
        Assert(!options.adjust || typeof options.adjust === "function", "options.adjust must be a function");
        Assert(!options.map || Array.isArray(options.map), "options.map must be an array");
        Assert(!options.map || !options.adjust, "Cannot set both map and adjust options");
        Object.assign(this, internals.defaults, options);
        Assert(this.type === "value" || this.ancestor === void 0, "Non-value references cannot reference ancestors");
        if (Array.isArray(this.map)) {
          this.map = new Map(this.map);
        }
        this.depth = this.path.length;
        this.key = this.path.length ? this.path.join(this.separator) : null;
        this.root = this.path[0];
        this.updateDisplay();
      }
      resolve(value, state, prefs, local2, options = {}) {
        Assert(!this.in || options.in, "Invalid in() reference usage");
        if (this.type === "global") {
          return this._resolve(prefs.context, state, options);
        }
        if (this.type === "local") {
          return this._resolve(local2, state, options);
        }
        if (!this.ancestor) {
          return this._resolve(value, state, options);
        }
        if (this.ancestor === "root") {
          return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);
        }
        Assert(this.ancestor <= state.ancestors.length, "Invalid reference exceeds the schema root:", this.display);
        return this._resolve(state.ancestors[this.ancestor - 1], state, options);
      }
      _resolve(target, state, options) {
        let resolved;
        if (this.type === "value" && state.mainstay.shadow && options.shadow !== false) {
          resolved = state.mainstay.shadow.get(this.absolute(state));
        }
        if (resolved === void 0) {
          resolved = Reach(target, this.path, { iterables: this.iterables, functions: true });
        }
        if (this.adjust) {
          resolved = this.adjust(resolved);
        }
        if (this.map) {
          const mapped = this.map.get(resolved);
          if (mapped !== void 0) {
            resolved = mapped;
          }
        }
        if (state.mainstay) {
          state.mainstay.tracer.resolve(state, this, resolved);
        }
        return resolved;
      }
      toString() {
        return this.display;
      }
      absolute(state) {
        return [...state.path.slice(0, -this.ancestor), ...this.path];
      }
      clone() {
        return new internals.Ref(this);
      }
      describe() {
        const ref = { path: this.path };
        if (this.type !== "value") {
          ref.type = this.type;
        }
        if (this.separator !== ".") {
          ref.separator = this.separator;
        }
        if (this.type === "value" && this.ancestor !== 1) {
          ref.ancestor = this.ancestor;
        }
        if (this.map) {
          ref.map = [...this.map];
        }
        for (const key of ["adjust", "iterables"]) {
          if (this[key] !== null) {
            ref[key] = this[key];
          }
        }
        if (this.in !== false) {
          ref.in = true;
        }
        return { ref };
      }
      updateDisplay() {
        const key = this.key !== null ? this.key : "";
        if (this.type !== "value") {
          this.display = `ref:${this.type}:${key}`;
          return;
        }
        if (!this.separator) {
          this.display = `ref:${key}`;
          return;
        }
        if (!this.ancestor) {
          this.display = `ref:${this.separator}${key}`;
          return;
        }
        if (this.ancestor === "root") {
          this.display = `ref:root:${key}`;
          return;
        }
        if (this.ancestor === 1) {
          this.display = `ref:${key || ".."}`;
          return;
        }
        const lead = new Array(this.ancestor + 1).fill(this.separator).join("");
        this.display = `ref:${lead}${key || ""}`;
      }
    };
    internals.Ref.prototype[Common.symbols.ref] = true;
    exports.build = function(desc) {
      desc = Object.assign({}, internals.defaults, desc);
      if (desc.type === "value" && desc.ancestor === void 0) {
        desc.ancestor = 1;
      }
      return new internals.Ref(desc);
    };
    internals.context = function(key, separator, prefix = {}) {
      key = key.trim();
      if (prefix) {
        const globalp = prefix.global === void 0 ? "$" : prefix.global;
        if (globalp !== separator && key.startsWith(globalp)) {
          return { key: key.slice(globalp.length), type: "global" };
        }
        const local2 = prefix.local === void 0 ? "#" : prefix.local;
        if (local2 !== separator && key.startsWith(local2)) {
          return { key: key.slice(local2.length), type: "local" };
        }
        const root = prefix.root === void 0 ? "/" : prefix.root;
        if (root !== separator && key.startsWith(root)) {
          return { key: key.slice(root.length), type: "value", root: true };
        }
      }
      return { key, type: "value" };
    };
    internals.ancestor = function(key, separator) {
      if (!separator) {
        return [1, 0];
      }
      if (key[0] !== separator) {
        return [1, 0];
      }
      if (key[1] !== separator) {
        return [0, 1];
      }
      let i = 2;
      while (key[i] === separator) {
        ++i;
      }
      return [i - 1, i];
    };
    exports.toSibling = 0;
    exports.toParent = 1;
    exports.Manager = class {
      constructor() {
        this.refs = [];
      }
      register(source, target) {
        if (!source) {
          return;
        }
        target = target === void 0 ? exports.toParent : target;
        if (Array.isArray(source)) {
          for (const ref of source) {
            this.register(ref, target);
          }
          return;
        }
        if (Common.isSchema(source)) {
          for (const item of source._refs.refs) {
            if (item.ancestor - target >= 0) {
              this.refs.push({ ancestor: item.ancestor - target, root: item.root });
            }
          }
          return;
        }
        if (exports.isRef(source) && source.type === "value" && source.ancestor - target >= 0) {
          this.refs.push({ ancestor: source.ancestor - target, root: source.root });
        }
        Template = Template || require_template2();
        if (Template.isTemplate(source)) {
          this.register(source.refs(), target);
        }
      }
      get length() {
        return this.refs.length;
      }
      clone() {
        const copy = new exports.Manager();
        copy.refs = Clone(this.refs);
        return copy;
      }
      reset() {
        this.refs = [];
      }
      roots() {
        return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);
      }
    };
  }
});

// node_modules/@hapi/joi/lib/template.js
var require_template2 = __commonJS({
  "node_modules/@hapi/joi/lib/template.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var EscapeHtml = require_escapeHtml();
    var Formula = require_lib30();
    var Common = require_common2();
    var Errors = require_errors2();
    var Ref = require_ref2();
    var internals = {
      symbol: Symbol("template"),
      opens: new Array(1e3).join("\0"),
      closes: new Array(1e3).join(""),
      dateFormat: {
        date: Date.prototype.toDateString,
        iso: Date.prototype.toISOString,
        string: Date.prototype.toString,
        time: Date.prototype.toTimeString,
        utc: Date.prototype.toUTCString
      }
    };
    module2.exports = exports = internals.Template = class {
      constructor(source, options) {
        Assert(typeof source === "string", "Template source must be a string");
        Assert(!source.includes("\0") && !source.includes(""), "Template source cannot contain reserved control characters");
        this.source = source;
        this.rendered = source;
        this._template = null;
        this._settings = Clone(options);
        this._parse();
      }
      _parse() {
        if (!this.source.includes("{")) {
          return;
        }
        const encoded = internals.encode(this.source);
        const parts = internals.split(encoded);
        let refs = false;
        const processed = [];
        const head = parts.shift();
        if (head) {
          processed.push(head);
        }
        for (const part of parts) {
          const raw = part[0] !== "{";
          const ender = raw ? "}" : "}}";
          const end = part.indexOf(ender);
          if (end === -1 || part[1] === "{") {
            processed.push(`{${internals.decode(part)}`);
            continue;
          }
          const variable = part.slice(raw ? 0 : 1, end);
          const dynamic = this._ref(internals.decode(variable), raw);
          processed.push(dynamic);
          if (typeof dynamic !== "string") {
            refs = true;
          }
          const rest = part.slice(end + ender.length);
          if (rest) {
            processed.push(internals.decode(rest));
          }
        }
        if (!refs) {
          this.rendered = processed.join("");
          return;
        }
        this._template = processed;
      }
      static date(date, prefs) {
        return internals.dateFormat[prefs.dateFormat].call(date);
      }
      describe(options = {}) {
        if (!this._settings && options.compact) {
          return this.source;
        }
        const desc = { template: this.source };
        if (this._settings) {
          desc.options = this._settings;
        }
        return desc;
      }
      static build(desc) {
        return new internals.Template(desc.template, desc.options);
      }
      isDynamic() {
        return !!this._template;
      }
      static isTemplate(template) {
        return template ? !!template[Common.symbols.template] : false;
      }
      refs() {
        if (!this._template) {
          return;
        }
        const refs = [];
        for (const part of this._template) {
          if (typeof part !== "string") {
            refs.push(...part.refs);
          }
        }
        return refs;
      }
      resolve(value, state, prefs, local2) {
        if (this._template && this._template.length === 1) {
          return this._part(this._template[0], value, state, prefs, local2, {});
        }
        return this.render(value, state, prefs, local2);
      }
      _part(part, ...args) {
        if (part.ref) {
          return part.ref.resolve(...args);
        }
        return part.formula.evaluate(args);
      }
      render(value, state, prefs, local2, options = {}) {
        if (!this.isDynamic()) {
          return this.rendered;
        }
        const parts = [];
        for (const part of this._template) {
          if (typeof part === "string") {
            parts.push(part);
          } else {
            const rendered = this._part(part, value, state, prefs, local2, options);
            const string = internals.stringify(rendered, prefs, options.errors);
            if (string !== void 0) {
              const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : EscapeHtml(string);
              const ends = part.ref && part.ref.type === "local" && part.ref.key === "label" && prefs.errors.wrap.label;
              parts.push(internals.wrap(result, ends));
            }
          }
        }
        return parts.join("");
      }
      _ref(content, raw) {
        const refs = [];
        const reference = (variable) => {
          const ref = Ref.create(variable, this._settings);
          refs.push(ref);
          return (context) => ref.resolve(...context);
        };
        try {
          var formula = new Formula.Parser(content, { reference, functions: internals.functions, constants: internals.constants });
        } catch (err) {
          err.message = `Invalid template variable "${content}" fails due to: ${err.message}`;
          throw err;
        }
        if (formula.single) {
          if (formula.single.type === "reference") {
            return { ref: refs[0], raw, refs };
          }
          return internals.stringify(formula.single.value);
        }
        return { formula, raw, refs };
      }
      toString() {
        return this.source;
      }
    };
    internals.Template.prototype[Common.symbols.template] = true;
    internals.Template.prototype.isImmutable = true;
    internals.encode = function(string) {
      return string.replace(/\\(\{+)/g, ($0, $1) => {
        return internals.opens.slice(0, $1.length);
      }).replace(/\\(\}+)/g, ($0, $1) => {
        return internals.closes.slice(0, $1.length);
      });
    };
    internals.decode = function(string) {
      return string.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
    };
    internals.split = function(string) {
      const parts = [];
      let current = "";
      for (let i = 0; i < string.length; ++i) {
        const char = string[i];
        if (char === "{") {
          let next = "";
          while (i + 1 < string.length && string[i + 1] === "{") {
            next += "{";
            ++i;
          }
          parts.push(current);
          current = next;
        } else {
          current += char;
        }
      }
      parts.push(current);
      return parts;
    };
    internals.wrap = function(value, ends) {
      if (!ends) {
        return value;
      }
      if (ends.length === 1) {
        return `${ends}${value}${ends}`;
      }
      return `${ends[0]}${value}${ends[1]}`;
    };
    internals.stringify = function(value, prefs, options) {
      const type = typeof value;
      if (value === null) {
        return "null";
      }
      if (type === "string") {
        return value;
      }
      if (type === "number" || type === "function" || type === "symbol") {
        return value.toString();
      }
      if (type !== "object") {
        return JSON.stringify(value);
      }
      if (value instanceof Date) {
        return internals.Template.date(value, prefs);
      }
      if (value instanceof Map) {
        const pairs = [];
        for (const [key, sym] of value.entries()) {
          pairs.push(`${key.toString()} -> ${sym.toString()}`);
        }
        value = pairs;
      }
      if (!Array.isArray(value)) {
        return value.toString();
      }
      let partial = "";
      for (const item of value) {
        partial = partial + (partial.length ? ", " : "") + internals.stringify(item, prefs, options);
      }
      return internals.wrap(partial, prefs.errors.wrap.array);
    };
    internals.constants = {
      true: true,
      false: false,
      null: null,
      second: 1e3,
      minute: 60 * 1e3,
      hour: 60 * 60 * 1e3,
      day: 24 * 60 * 60 * 1e3
    };
    internals.functions = {
      if(condition, then, otherwise) {
        return condition ? then : otherwise;
      },
      msg(code) {
        const [value, state, prefs, local2, options] = this;
        const messages = options.messages;
        if (!messages) {
          return "";
        }
        const template = Errors.template(value, messages[0], code, state, prefs) || Errors.template(value, messages[1], code, state, prefs);
        if (!template) {
          return "";
        }
        return template.render(value, state, prefs, local2, options);
      },
      number(value) {
        if (typeof value === "number") {
          return value;
        }
        if (typeof value === "string") {
          return parseFloat(value);
        }
        if (typeof value === "boolean") {
          return value ? 1 : 0;
        }
        if (value instanceof Date) {
          return value.getTime();
        }
        return null;
      }
    };
  }
});

// node_modules/@hapi/joi/lib/messages.js
var require_messages2 = __commonJS({
  "node_modules/@hapi/joi/lib/messages.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Template = require_template2();
    exports.compile = function(messages, target) {
      if (typeof messages === "string") {
        Assert(!target, "Cannot set single message string");
        return new Template(messages);
      }
      if (Template.isTemplate(messages)) {
        Assert(!target, "Cannot set single message template");
        return messages;
      }
      Assert(typeof messages === "object" && !Array.isArray(messages), "Invalid message options");
      target = target ? Clone(target) : {};
      for (let code in messages) {
        const message = messages[code];
        if (code === "root" || Template.isTemplate(message)) {
          target[code] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code] = new Template(message);
          continue;
        }
        Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
        const language = code;
        target[language] = target[language] || {};
        for (code in message) {
          const localized = message[code];
          if (code === "root" || Template.isTemplate(localized)) {
            target[language][code] = localized;
            continue;
          }
          Assert(typeof localized === "string", "Invalid message for", code, "in", language);
          target[language][code] = new Template(localized);
        }
      }
      return target;
    };
    exports.decompile = function(messages) {
      const target = {};
      for (let code in messages) {
        const message = messages[code];
        if (code === "root") {
          target[code] = message;
          continue;
        }
        if (Template.isTemplate(message)) {
          target[code] = message.describe({ compact: true });
          continue;
        }
        const language = code;
        target[language] = {};
        for (code in message) {
          const localized = message[code];
          if (code === "root") {
            target[language][code] = localized;
            continue;
          }
          target[language][code] = localized.describe({ compact: true });
        }
      }
      return target;
    };
    exports.merge = function(base, extended) {
      if (!base) {
        return exports.compile(extended);
      }
      if (!extended) {
        return base;
      }
      if (typeof extended === "string") {
        return new Template(extended);
      }
      if (Template.isTemplate(extended)) {
        return extended;
      }
      const target = Clone(base);
      for (let code in extended) {
        const message = extended[code];
        if (code === "root" || Template.isTemplate(message)) {
          target[code] = message;
          continue;
        }
        if (typeof message === "string") {
          target[code] = new Template(message);
          continue;
        }
        Assert(typeof message === "object" && !Array.isArray(message), "Invalid message for", code);
        const language = code;
        target[language] = target[language] || {};
        for (code in message) {
          const localized = message[code];
          if (code === "root" || Template.isTemplate(localized)) {
            target[language][code] = localized;
            continue;
          }
          Assert(typeof localized === "string", "Invalid message for", code, "in", language);
          target[language][code] = new Template(localized);
        }
      }
      return target;
    };
  }
});

// node_modules/@hapi/joi/lib/common.js
var require_common2 = __commonJS({
  "node_modules/@hapi/joi/lib/common.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var AssertError = require_error();
    var Pkg = require_package3();
    var Messages;
    var Schemas;
    var internals = {
      isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
    };
    exports.version = Pkg.version;
    exports.defaults = {
      abortEarly: true,
      allowUnknown: false,
      cache: true,
      context: null,
      convert: true,
      dateFormat: "iso",
      errors: {
        escapeHtml: false,
        label: "path",
        language: null,
        render: true,
        stack: false,
        wrap: {
          label: '"',
          array: "[]"
        }
      },
      externals: true,
      messages: {},
      nonEnumerables: false,
      noDefaults: false,
      presence: "optional",
      skipFunctions: false,
      stripUnknown: false,
      warnings: false
    };
    exports.symbols = {
      any: Symbol.for("@hapi/joi/schema"),
      arraySingle: Symbol("arraySingle"),
      deepDefault: Symbol("deepDefault"),
      literal: Symbol("literal"),
      override: Symbol("override"),
      prefs: Symbol("prefs"),
      ref: Symbol("ref"),
      values: Symbol("values"),
      template: Symbol("template")
    };
    exports.assertOptions = function(options, keys, name = "Options") {
      Assert(options && typeof options === "object" && !Array.isArray(options), "Options must be of type object");
      const unknownKeys = Object.keys(options).filter((k) => !keys.includes(k));
      Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);
    };
    exports.checkPreferences = function(prefs) {
      Schemas = Schemas || require_schemas2();
      const result = Schemas.preferences.validate(prefs);
      if (result.error) {
        throw new AssertError([result.error.details[0].message]);
      }
    };
    exports.compare = function(a, b, operator) {
      switch (operator) {
        case "=":
          return a === b;
        case ">":
          return a > b;
        case "<":
          return a < b;
        case ">=":
          return a >= b;
        case "<=":
          return a <= b;
      }
    };
    exports.default = function(value, defaultValue) {
      return value === void 0 ? defaultValue : value;
    };
    exports.isIsoDate = function(date) {
      return internals.isoDate.test(date);
    };
    exports.isNumber = function(value) {
      return typeof value === "number" && !isNaN(value);
    };
    exports.isResolvable = function(obj) {
      if (!obj) {
        return false;
      }
      return obj[exports.symbols.ref] || obj[exports.symbols.template];
    };
    exports.isSchema = function(schema, options = {}) {
      const any = schema && schema[exports.symbols.any];
      if (!any) {
        return false;
      }
      Assert(options.legacy || any.version === exports.version, "Cannot mix different versions of joi schemas");
      return true;
    };
    exports.isValues = function(obj) {
      return obj[exports.symbols.values];
    };
    exports.limit = function(value) {
      return Number.isSafeInteger(value) && value >= 0;
    };
    exports.preferences = function(target, source) {
      Messages = Messages || require_messages2();
      target = target || {};
      source = source || {};
      const merged = Object.assign({}, target, source);
      if (source.errors && target.errors) {
        merged.errors = Object.assign({}, target.errors, source.errors);
        merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);
      }
      if (source.messages) {
        merged.messages = Messages.compile(source.messages, target.messages);
      }
      delete merged[exports.symbols.prefs];
      return merged;
    };
    exports.tryWithPath = function(fn, key, options = {}) {
      try {
        return fn();
      } catch (err) {
        if (err.path !== void 0) {
          err.path = key + "." + err.path;
        } else {
          err.path = key;
        }
        if (options.append) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    exports.validateArg = function(value, label, { assert, message }) {
      if (exports.isSchema(assert)) {
        const result = assert.validate(value);
        if (!result.error) {
          return;
        }
        return result.error.message;
      } else if (!assert(value)) {
        return label ? `${label} ${message}` : message;
      }
    };
    exports.verifyFlat = function(args, method) {
      for (const arg of args) {
        Assert(!Array.isArray(arg), "Method no longer accepts array arguments:", method);
      }
    };
  }
});

// node_modules/@hapi/joi/lib/cache.js
var require_cache = __commonJS({
  "node_modules/@hapi/joi/lib/cache.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common2();
    var internals = {
      max: 1e3,
      supported: /* @__PURE__ */ new Set(["undefined", "boolean", "number", "string"])
    };
    exports.provider = {
      provision(options) {
        return new internals.Cache(options);
      }
    };
    internals.Cache = class {
      constructor(options = {}) {
        Common.assertOptions(options, ["max"]);
        Assert(options.max === void 0 || options.max && options.max > 0 && isFinite(options.max), "Invalid max cache size");
        this._max = options.max || internals.max;
        this._map = /* @__PURE__ */ new Map();
        this._list = new internals.List();
      }
      get length() {
        return this._map.size;
      }
      set(key, value) {
        if (key !== null && !internals.supported.has(typeof key)) {
          return;
        }
        let node = this._map.get(key);
        if (node) {
          node.value = value;
          this._list.first(node);
          return;
        }
        node = this._list.unshift({ key, value });
        this._map.set(key, node);
        this._compact();
      }
      get(key) {
        const node = this._map.get(key);
        if (node) {
          this._list.first(node);
          return Clone(node.value);
        }
      }
      _compact() {
        if (this._map.size > this._max) {
          const node = this._list.pop();
          this._map.delete(node.key);
        }
      }
    };
    internals.List = class {
      constructor() {
        this.tail = null;
        this.head = null;
      }
      unshift(node) {
        node.next = null;
        node.prev = this.head;
        if (this.head) {
          this.head.next = node;
        }
        this.head = node;
        if (!this.tail) {
          this.tail = node;
        }
        return node;
      }
      first(node) {
        if (node === this.head) {
          return;
        }
        this._remove(node);
        this.unshift(node);
      }
      pop() {
        return this._remove(this.tail);
      }
      _remove(node) {
        const { next, prev } = node;
        next.prev = prev;
        if (prev) {
          prev.next = next;
        }
        if (node === this.tail) {
          this.tail = next;
        }
        node.prev = null;
        node.next = null;
        return node;
      }
    };
  }
});

// node_modules/@hapi/joi/lib/compile.js
var require_compile2 = __commonJS({
  "node_modules/@hapi/joi/lib/compile.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Common = require_common2();
    var Ref = require_ref2();
    var internals = {};
    exports.schema = function(Joi2, config, options = {}) {
      Common.assertOptions(options, ["appendPath", "override"]);
      try {
        return internals.schema(Joi2, config, options);
      } catch (err) {
        if (options.appendPath && err.path !== void 0) {
          err.message = `${err.message} (${err.path})`;
        }
        throw err;
      }
    };
    internals.schema = function(Joi2, config, options) {
      Assert(config !== void 0, "Invalid undefined schema");
      if (Array.isArray(config)) {
        Assert(config.length, "Invalid empty array schema");
        if (config.length === 1) {
          config = config[0];
        }
      }
      const valid = (base, ...values) => {
        if (options.override !== false) {
          return base.valid(Joi2.override, ...values);
        }
        return base.valid(...values);
      };
      if (internals.simple(config)) {
        return valid(Joi2, config);
      }
      if (typeof config === "function") {
        return Joi2.custom(config);
      }
      Assert(typeof config === "object", "Invalid schema content:", typeof config);
      if (Common.isResolvable(config)) {
        return valid(Joi2, config);
      }
      if (Common.isSchema(config)) {
        return config;
      }
      if (Array.isArray(config)) {
        for (const item of config) {
          if (!internals.simple(item)) {
            return Joi2.alternatives().try(...config);
          }
        }
        return valid(Joi2, ...config);
      }
      if (config instanceof RegExp) {
        return Joi2.string().regex(config);
      }
      if (config instanceof Date) {
        return valid(Joi2.date(), config);
      }
      Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      return Joi2.object().keys(config);
    };
    exports.ref = function(id, options) {
      return Ref.isRef(id) ? id : Ref.create(id, options);
    };
    exports.compile = function(root, schema, options = {}) {
      Common.assertOptions(options, ["legacy"]);
      const any = schema && schema[Common.symbols.any];
      if (any) {
        Assert(options.legacy || any.version === Common.version, "Cannot mix different versions of joi schemas:", any.version, Common.version);
        return schema;
      }
      if (typeof schema !== "object" || !options.legacy) {
        return exports.schema(root, schema, { appendPath: true });
      }
      const compiler = internals.walk(schema);
      if (!compiler) {
        return exports.schema(root, schema, { appendPath: true });
      }
      return compiler.compile(compiler.root, schema);
    };
    internals.walk = function(schema) {
      if (typeof schema !== "object") {
        return null;
      }
      if (Array.isArray(schema)) {
        for (const item of schema) {
          const compiler = internals.walk(item);
          if (compiler) {
            return compiler;
          }
        }
        return null;
      }
      const any = schema[Common.symbols.any];
      if (any) {
        return { root: schema[any.root], compile: any.compile };
      }
      Assert(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
      for (const key in schema) {
        const compiler = internals.walk(schema[key]);
        if (compiler) {
          return compiler;
        }
      }
      return null;
    };
    internals.simple = function(value) {
      return value === null || ["boolean", "string", "number"].includes(typeof value);
    };
    exports.when = function(schema, condition, options) {
      if (options === void 0) {
        Assert(condition && typeof condition === "object", "Missing options");
        options = condition;
        condition = Ref.create(".");
      }
      if (Array.isArray(options)) {
        options = { switch: options };
      }
      Common.assertOptions(options, ["is", "not", "then", "otherwise", "switch", "break"]);
      if (Common.isSchema(condition)) {
        Assert(options.is === void 0, '"is" can not be used with a schema condition');
        Assert(options.not === void 0, '"not" can not be used with a schema condition');
        Assert(options.switch === void 0, '"switch" can not be used with a schema condition');
        return internals.condition(schema, { is: condition, then: options.then, otherwise: options.otherwise, break: options.break });
      }
      Assert(Ref.isRef(condition) || typeof condition === "string", "Invalid condition:", condition);
      Assert(options.not === void 0 || options.is === void 0, 'Cannot combine "is" with "not"');
      if (options.switch === void 0) {
        let rule2 = options;
        if (options.not !== void 0) {
          rule2 = { is: options.not, then: options.otherwise, otherwise: options.then, break: options.break };
        }
        let is = rule2.is !== void 0 ? schema.$_compile(rule2.is) : schema.$_root.invalid(null, false, 0, "").required();
        Assert(rule2.then !== void 0 || rule2.otherwise !== void 0, 'options must have at least one of "then", "otherwise", or "switch"');
        Assert(rule2.break === void 0 || rule2.then === void 0 || rule2.otherwise === void 0, "Cannot specify then, otherwise, and break all together");
        if (options.is !== void 0 && !Ref.isRef(options.is) && !Common.isSchema(options.is)) {
          is = is.required();
        }
        return internals.condition(schema, { ref: exports.ref(condition), is, then: rule2.then, otherwise: rule2.otherwise, break: rule2.break });
      }
      Assert(Array.isArray(options.switch), '"switch" must be an array');
      Assert(options.is === void 0, 'Cannot combine "switch" with "is"');
      Assert(options.not === void 0, 'Cannot combine "switch" with "not"');
      Assert(options.then === void 0, 'Cannot combine "switch" with "then"');
      const rule = {
        ref: exports.ref(condition),
        switch: [],
        break: options.break
      };
      for (let i = 0; i < options.switch.length; ++i) {
        const test = options.switch[i];
        const last = i === options.switch.length - 1;
        Common.assertOptions(test, last ? ["is", "then", "otherwise"] : ["is", "then"]);
        Assert(test.is !== void 0, 'Switch statement missing "is"');
        Assert(test.then !== void 0, 'Switch statement missing "then"');
        const item = {
          is: schema.$_compile(test.is),
          then: schema.$_compile(test.then)
        };
        if (!Ref.isRef(test.is) && !Common.isSchema(test.is)) {
          item.is = item.is.required();
        }
        if (last) {
          Assert(options.otherwise === void 0 || test.otherwise === void 0, 'Cannot specify "otherwise" inside and outside a "switch"');
          const otherwise = options.otherwise !== void 0 ? options.otherwise : test.otherwise;
          if (otherwise !== void 0) {
            Assert(rule.break === void 0, "Cannot specify both otherwise and break");
            item.otherwise = schema.$_compile(otherwise);
          }
        }
        rule.switch.push(item);
      }
      return rule;
    };
    internals.condition = function(schema, condition) {
      for (const key of ["then", "otherwise"]) {
        if (condition[key] === void 0) {
          delete condition[key];
        } else {
          condition[key] = schema.$_compile(condition[key]);
        }
      }
      return condition;
    };
  }
});

// node_modules/@hapi/joi/lib/extend.js
var require_extend2 = __commonJS({
  "node_modules/@hapi/joi/lib/extend.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common2();
    var Messages = require_messages2();
    var internals = {};
    exports.type = function(from, options) {
      const base = Object.getPrototypeOf(from);
      const prototype = Clone(base);
      const schema = from._assign(Object.create(prototype));
      const def = Object.assign({}, options);
      delete def.base;
      prototype._definition = def;
      const parent = base._definition || {};
      def.messages = Messages.merge(parent.messages, def.messages);
      def.properties = Object.assign({}, parent.properties, def.properties);
      schema.type = def.type;
      def.flags = Object.assign({}, parent.flags, def.flags);
      const terms = Object.assign({}, parent.terms);
      if (def.terms) {
        for (const name in def.terms) {
          const term = def.terms[name];
          Assert(schema.$_terms[name] === void 0, "Invalid term override for", def.type, name);
          schema.$_terms[name] = term.init;
          terms[name] = term;
        }
      }
      def.terms = terms;
      if (!def.args) {
        def.args = parent.args;
      }
      def.prepare = internals.prepare(def.prepare, parent.prepare);
      if (def.coerce) {
        if (typeof def.coerce === "function") {
          def.coerce = { method: def.coerce };
        }
        if (def.coerce.from && !Array.isArray(def.coerce.from)) {
          def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };
        }
      }
      def.coerce = internals.coerce(def.coerce, parent.coerce);
      def.validate = internals.validate(def.validate, parent.validate);
      const rules = Object.assign({}, parent.rules);
      if (def.rules) {
        for (const name in def.rules) {
          const rule = def.rules[name];
          Assert(typeof rule === "object", "Invalid rule definition for", def.type, name);
          let method = rule.method;
          if (method === void 0) {
            method = function() {
              return this.$_addRule(name);
            };
          }
          if (method) {
            Assert(!prototype[name], "Rule conflict in", def.type, name);
            prototype[name] = method;
          }
          Assert(!rules[name], "Rule conflict in", def.type, name);
          rules[name] = rule;
          if (rule.alias) {
            const aliases = [].concat(rule.alias);
            for (const alias of aliases) {
              prototype[alias] = rule.method;
            }
          }
          if (rule.args) {
            rule.argsByName = /* @__PURE__ */ new Map();
            rule.args = rule.args.map((arg) => {
              if (typeof arg === "string") {
                arg = { name: arg };
              }
              Assert(!rule.argsByName.has(arg.name), "Duplicated argument name", arg.name);
              if (Common.isSchema(arg.assert)) {
                arg.assert = arg.assert.strict().label(arg.name);
              }
              rule.argsByName.set(arg.name, arg);
              return arg;
            });
          }
        }
      }
      def.rules = rules;
      const modifiers = Object.assign({}, parent.modifiers);
      if (def.modifiers) {
        for (const name in def.modifiers) {
          Assert(!prototype[name], "Rule conflict in", def.type, name);
          const modifier = def.modifiers[name];
          Assert(typeof modifier === "function", "Invalid modifier definition for", def.type, name);
          const method = function(arg) {
            return this.rule({ [name]: arg });
          };
          prototype[name] = method;
          modifiers[name] = modifier;
        }
      }
      def.modifiers = modifiers;
      if (def.overrides) {
        prototype._super = base;
        schema.$_super = {};
        for (const override in def.overrides) {
          Assert(base[override], "Cannot override missing", override);
          schema.$_super[override] = base[override].bind(schema);
        }
        Object.assign(prototype, def.overrides);
      }
      def.cast = Object.assign({}, parent.cast, def.cast);
      const manifest = Object.assign({}, parent.manifest, def.manifest);
      manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);
      def.manifest = manifest;
      def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);
      return schema;
    };
    internals.build = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(obj, desc) {
        return parent(child(obj, desc), desc);
      };
    };
    internals.coerce = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return {
        from: child.from && parent.from ? [.../* @__PURE__ */ new Set([...child.from, ...parent.from])] : null,
        method(value, helpers) {
          let coerced;
          if (!parent.from || parent.from.includes(typeof value)) {
            coerced = parent.method(value, helpers);
            if (coerced) {
              if (coerced.errors || coerced.value === void 0) {
                return coerced;
              }
              value = coerced.value;
            }
          }
          if (!child.from || child.from.includes(typeof value)) {
            const own = child.method(value, helpers);
            if (own) {
              return own;
            }
          }
          return coerced;
        }
      };
    };
    internals.prepare = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(value, helpers) {
        const prepared = child(value, helpers);
        if (prepared) {
          if (prepared.errors || prepared.value === void 0) {
            return prepared;
          }
          value = prepared.value;
        }
        return parent(value, helpers) || prepared;
      };
    };
    internals.rebuild = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(schema) {
        parent(schema);
        child(schema);
      };
    };
    internals.validate = function(child, parent) {
      if (!child || !parent) {
        return child || parent;
      }
      return function(value, helpers) {
        const result = parent(value, helpers);
        if (result) {
          if (result.errors && (!Array.isArray(result.errors) || result.errors.length)) {
            return result;
          }
          value = result.value;
        }
        return child(value, helpers) || result;
      };
    };
  }
});

// node_modules/@hapi/joi/lib/manifest.js
var require_manifest = __commonJS({
  "node_modules/@hapi/joi/lib/manifest.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Common = require_common2();
    var Messages = require_messages2();
    var Ref = require_ref2();
    var Template = require_template2();
    var Schemas;
    var internals = {};
    exports.describe = function(schema) {
      const def = schema._definition;
      const desc = {
        type: schema.type,
        flags: {},
        rules: []
      };
      for (const flag in schema._flags) {
        if (flag[0] !== "_") {
          desc.flags[flag] = internals.describe(schema._flags[flag]);
        }
      }
      if (!Object.keys(desc.flags).length) {
        delete desc.flags;
      }
      if (schema._preferences) {
        desc.preferences = Clone(schema._preferences, { shallow: ["messages"] });
        delete desc.preferences[Common.symbols.prefs];
        if (desc.preferences.messages) {
          desc.preferences.messages = Messages.decompile(desc.preferences.messages);
        }
      }
      if (schema._valids) {
        desc.allow = schema._valids.describe();
      }
      if (schema._invalids) {
        desc.invalid = schema._invalids.describe();
      }
      for (const rule of schema._rules) {
        const ruleDef = def.rules[rule.name];
        if (ruleDef.manifest === false) {
          continue;
        }
        const item = { name: rule.name };
        for (const custom in def.modifiers) {
          if (rule[custom] !== void 0) {
            item[custom] = internals.describe(rule[custom]);
          }
        }
        if (rule.args) {
          item.args = {};
          for (const key in rule.args) {
            const arg = rule.args[key];
            if (key === "options" && !Object.keys(arg).length) {
              continue;
            }
            item.args[key] = internals.describe(arg, { assign: key });
          }
          if (!Object.keys(item.args).length) {
            delete item.args;
          }
        }
        desc.rules.push(item);
      }
      if (!desc.rules.length) {
        delete desc.rules;
      }
      for (const term in schema.$_terms) {
        if (term[0] === "_") {
          continue;
        }
        Assert(!desc[term], "Cannot describe schema due to internal name conflict with", term);
        const items = schema.$_terms[term];
        if (!items) {
          continue;
        }
        if (items instanceof Map) {
          if (items.size) {
            desc[term] = [...items.entries()];
          }
          continue;
        }
        if (Common.isValues(items)) {
          desc[term] = items.describe();
          continue;
        }
        Assert(def.terms[term], "Term", term, "missing configuration");
        const manifest = def.terms[term].manifest;
        const mapped = typeof manifest === "object";
        if (!items.length && !mapped) {
          continue;
        }
        const normalized = [];
        for (const item of items) {
          normalized.push(internals.describe(item));
        }
        if (mapped) {
          const { from, to } = manifest.mapped;
          desc[term] = {};
          for (const item of normalized) {
            desc[term][item[to]] = item[from];
          }
          continue;
        }
        if (manifest === "single") {
          Assert(normalized.length === 1, "Term", term, "contains more than one item");
          desc[term] = normalized[0];
          continue;
        }
        desc[term] = normalized;
      }
      internals.validate(schema.$_root, desc);
      return desc;
    };
    internals.describe = function(item, options = {}) {
      if (Array.isArray(item)) {
        return item.map(internals.describe);
      }
      if (item === Common.symbols.deepDefault) {
        return { special: "deep" };
      }
      if (typeof item !== "object" || item === null) {
        return item;
      }
      if (options.assign === "options") {
        return Clone(item);
      }
      if (Buffer && Buffer.isBuffer(item)) {
        return { buffer: item.toString("binary") };
      }
      if (item instanceof Date) {
        return item.toISOString();
      }
      if (item instanceof Error) {
        return item;
      }
      if (item instanceof RegExp) {
        if (options.assign === "regex") {
          return item.toString();
        }
        return { regex: item.toString() };
      }
      if (item[Common.symbols.literal]) {
        return { function: item.literal };
      }
      if (typeof item.describe === "function") {
        if (options.assign === "ref") {
          return item.describe().ref;
        }
        return item.describe();
      }
      const normalized = {};
      for (const key in item) {
        const value = item[key];
        if (value === void 0) {
          continue;
        }
        normalized[key] = internals.describe(value, { assign: key });
      }
      return normalized;
    };
    exports.build = function(joi, desc) {
      const builder = new internals.Builder(joi);
      return builder.parse(desc);
    };
    internals.Builder = class {
      constructor(joi) {
        this.joi = joi;
      }
      parse(desc) {
        internals.validate(this.joi, desc);
        let schema = this.joi[desc.type]();
        const def = schema._definition;
        if (desc.flags) {
          for (const flag in desc.flags) {
            const setter = def.flags[flag] && def.flags[flag].setter || flag;
            Assert(typeof schema[setter] === "function", "Invalid flag", flag, "for type", desc.type);
            schema = schema[setter](this.build(desc.flags[flag]));
          }
        }
        if (desc.preferences) {
          schema = schema.preferences(this.build(desc.preferences));
        }
        if (desc.allow) {
          schema = schema.allow(...this.build(desc.allow));
        }
        if (desc.invalid) {
          schema = schema.invalid(...this.build(desc.invalid));
        }
        if (desc.rules) {
          for (const rule of desc.rules) {
            Assert(typeof schema[rule.name] === "function", "Invalid rule", rule.name, "for type", desc.type);
            const args = [];
            if (rule.args) {
              const built = {};
              for (const key in rule.args) {
                built[key] = this.build(rule.args[key], { assign: key });
              }
              const keys = Object.keys(built);
              const definition = def.rules[rule.name].args;
              if (definition) {
                Assert(keys.length <= definition.length, "Invalid number of arguments for", desc.type, rule.name, "(expected up to", definition.length, ", found", keys.length, ")");
                for (const { name } of definition) {
                  args.push(built[name]);
                }
              } else {
                Assert(keys.length === 1, "Invalid number of arguments for", desc.type, rule.name, "(expected up to 1, found", keys.length, ")");
                args.push(built[keys[0]]);
              }
            }
            schema = schema[rule.name](...args);
            const options = {};
            for (const custom in def.modifiers) {
              if (rule[custom] !== void 0) {
                options[custom] = this.build(rule[custom]);
              }
            }
            if (Object.keys(options).length) {
              schema = schema.rule(options);
            }
          }
        }
        const terms = {};
        for (const key in desc) {
          if (["allow", "flags", "invalid", "whens", "preferences", "rules", "type"].includes(key)) {
            continue;
          }
          Assert(def.terms[key], "Term", key, "missing configuration");
          const manifest = def.terms[key].manifest;
          if (manifest === "schema") {
            terms[key] = desc[key].map((item) => this.parse(item));
            continue;
          }
          if (manifest === "values") {
            terms[key] = desc[key].map((item) => this.build(item));
            continue;
          }
          if (manifest === "single") {
            terms[key] = this.build(desc[key]);
            continue;
          }
          if (typeof manifest === "object") {
            terms[key] = {};
            for (const name in desc[key]) {
              const value = desc[key][name];
              terms[key][name] = this.parse(value);
            }
            continue;
          }
          terms[key] = this.build(desc[key]);
        }
        if (desc.whens) {
          terms.whens = desc.whens.map((when) => this.build(when));
        }
        schema = def.manifest.build(schema, terms);
        schema.$_temp.ruleset = false;
        return schema;
      }
      build(desc, options = {}) {
        if (desc === null) {
          return null;
        }
        if (Array.isArray(desc)) {
          return desc.map((item) => this.build(item));
        }
        if (desc instanceof Error) {
          return desc;
        }
        if (options.assign === "options") {
          return Clone(desc);
        }
        if (options.assign === "regex") {
          return internals.regex(desc);
        }
        if (options.assign === "ref") {
          return Ref.build(desc);
        }
        if (typeof desc !== "object") {
          return desc;
        }
        if (Object.keys(desc).length === 1) {
          if (desc.buffer) {
            Assert(Buffer, "Buffers are not supported");
            return Buffer && Buffer.from(desc.buffer, "binary");
          }
          if (desc.function) {
            return { [Common.symbols.literal]: true, literal: desc.function };
          }
          if (desc.override) {
            return Common.symbols.override;
          }
          if (desc.ref) {
            return Ref.build(desc.ref);
          }
          if (desc.regex) {
            return internals.regex(desc.regex);
          }
          if (desc.special) {
            Assert(["deep"].includes(desc.special), "Unknown special value", desc.special);
            return Common.symbols.deepDefault;
          }
          if (desc.value) {
            return Clone(desc.value);
          }
        }
        if (desc.type) {
          return this.parse(desc);
        }
        if (desc.template) {
          return Template.build(desc);
        }
        const normalized = {};
        for (const key in desc) {
          normalized[key] = this.build(desc[key], { assign: key });
        }
        return normalized;
      }
    };
    internals.regex = function(string) {
      const end = string.lastIndexOf("/");
      const exp = string.slice(1, end);
      const flags = string.slice(end + 1);
      return new RegExp(exp, flags);
    };
    internals.validate = function(joi, desc) {
      Schemas = Schemas || require_schemas2();
      joi.assert(desc, Schemas.description);
    };
  }
});

// node_modules/@hapi/pinpoint/lib/index.js
var require_lib31 = __commonJS({
  "node_modules/@hapi/pinpoint/lib/index.js"(exports) {
    "use strict";
    exports.location = function(depth = 0) {
      const orig = Error.prepareStackTrace;
      Error.prepareStackTrace = (ignore, stack) => stack;
      const capture = {};
      Error.captureStackTrace(capture, this);
      const line = capture.stack[depth + 1];
      Error.prepareStackTrace = orig;
      return {
        filename: line.getFileName(),
        line: line.getLineNumber()
      };
    };
  }
});

// node_modules/@hapi/joi/lib/trace.js
var require_trace = __commonJS({
  "node_modules/@hapi/joi/lib/trace.js"(exports) {
    "use strict";
    var DeepEqual = require_deepEqual();
    var Pinpoint = require_lib31();
    var Errors = require_errors2();
    var internals = {
      codes: {
        error: 1,
        pass: 2,
        full: 3
      },
      labels: {
        0: "never used",
        1: "always error",
        2: "always pass"
      }
    };
    exports.setup = function(root) {
      const trace = function() {
        root._tracer = root._tracer || new internals.Tracer();
        return root._tracer;
      };
      root.trace = trace;
      root[Symbol.for("@hapi/lab/coverage/initialize")] = trace;
      root.untrace = () => {
        root._tracer = null;
      };
    };
    exports.location = function(schema) {
      return schema.$_setFlag("_tracerLocation", Pinpoint.location(2));
    };
    internals.Tracer = class {
      constructor() {
        this.name = "Joi";
        this._schemas = /* @__PURE__ */ new Map();
      }
      _register(schema) {
        const existing = this._schemas.get(schema);
        if (existing) {
          return existing.store;
        }
        const store = new internals.Store(schema);
        const { filename, line } = schema._flags._tracerLocation || Pinpoint.location(5);
        this._schemas.set(schema, { filename, line, store });
        return store;
      }
      _combine(merged, sources) {
        for (const { store } of this._schemas.values()) {
          store._combine(merged, sources);
        }
      }
      report(file) {
        const coverage = [];
        for (const { filename, line, store } of this._schemas.values()) {
          if (file && file !== filename) {
            continue;
          }
          const missing = [];
          const skipped = [];
          for (const [schema, log] of store._sources.entries()) {
            if (internals.sub(log.paths, skipped)) {
              continue;
            }
            if (!log.entry) {
              missing.push({
                status: "never reached",
                paths: [...log.paths]
              });
              skipped.push(...log.paths);
              continue;
            }
            for (const type of ["valid", "invalid"]) {
              const set = schema[`_${type}s`];
              if (!set) {
                continue;
              }
              const values = new Set(set._values);
              const refs = new Set(set._refs);
              for (const { value, ref } of log[type]) {
                values.delete(value);
                refs.delete(ref);
              }
              if (values.size || refs.size) {
                missing.push({
                  status: [...values, ...[...refs].map((ref) => ref.display)],
                  rule: `${type}s`
                });
              }
            }
            const rules = schema._rules.map((rule) => rule.name);
            for (const type of ["default", "failover"]) {
              if (schema._flags[type] !== void 0) {
                rules.push(type);
              }
            }
            for (const name of rules) {
              const status = internals.labels[log.rule[name] || 0];
              if (status) {
                const report = { rule: name, status };
                if (log.paths.size) {
                  report.paths = [...log.paths];
                }
                missing.push(report);
              }
            }
          }
          if (missing.length) {
            coverage.push({
              filename,
              line,
              missing,
              severity: "error",
              message: `Schema missing tests for ${missing.map(internals.message).join(", ")}`
            });
          }
        }
        return coverage.length ? coverage : null;
      }
    };
    internals.Store = class {
      constructor(schema) {
        this.active = true;
        this._sources = /* @__PURE__ */ new Map();
        this._combos = /* @__PURE__ */ new Map();
        this._scan(schema);
      }
      debug(state, source, name, result) {
        state.mainstay.debug && state.mainstay.debug.push({ type: source, name, result, path: state.path });
      }
      entry(schema, state) {
        internals.debug(state, { type: "entry" });
        this._record(schema, (log) => {
          log.entry = true;
        });
      }
      filter(schema, state, source, value) {
        internals.debug(state, { type: source, ...value });
        this._record(schema, (log) => {
          log[source].add(value);
        });
      }
      log(schema, state, source, name, result) {
        internals.debug(state, { type: source, name, result: result === "full" ? "pass" : result });
        this._record(schema, (log) => {
          log[source][name] = log[source][name] || 0;
          log[source][name] |= internals.codes[result];
        });
      }
      resolve(state, ref, to) {
        if (!state.mainstay.debug) {
          return;
        }
        const log = { type: "resolve", ref: ref.display, to, path: state.path };
        state.mainstay.debug.push(log);
      }
      value(state, by, from, to, name) {
        if (!state.mainstay.debug || DeepEqual(from, to)) {
          return;
        }
        const log = { type: "value", by, from, to, path: state.path };
        if (name) {
          log.name = name;
        }
        state.mainstay.debug.push(log);
      }
      _record(schema, each) {
        const log = this._sources.get(schema);
        if (log) {
          each(log);
          return;
        }
        const sources = this._combos.get(schema);
        for (const source of sources) {
          this._record(source, each);
        }
      }
      _scan(schema, _path) {
        const path = _path || [];
        let log = this._sources.get(schema);
        if (!log) {
          log = {
            paths: /* @__PURE__ */ new Set(),
            entry: false,
            rule: {},
            valid: /* @__PURE__ */ new Set(),
            invalid: /* @__PURE__ */ new Set()
          };
          this._sources.set(schema, log);
        }
        if (path.length) {
          log.paths.add(path);
        }
        const each = (sub, source) => {
          const subId = internals.id(sub, source);
          this._scan(sub, path.concat(subId));
        };
        schema.$_modify({ each, ref: false });
      }
      _combine(merged, sources) {
        this._combos.set(merged, sources);
      }
    };
    internals.message = function(item) {
      const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ":" : "") : "";
      return `${path}${item.rule || ""} (${item.status})`;
    };
    internals.id = function(schema, { source, name, path, key }) {
      if (schema._flags.id) {
        return schema._flags.id;
      }
      if (key) {
        return key;
      }
      name = `@${name}`;
      if (source === "terms") {
        return [name, path[Math.min(path.length - 1, 1)]];
      }
      return name;
    };
    internals.sub = function(paths, skipped) {
      for (const path of paths) {
        for (const skip of skipped) {
          if (DeepEqual(path.slice(0, skip.length), skip)) {
            return true;
          }
        }
      }
      return false;
    };
    internals.debug = function(state, event) {
      if (state.mainstay.debug) {
        event.path = state.debug ? [...state.path, state.debug] : state.path;
        state.mainstay.debug.push(event);
      }
    };
  }
});

// node_modules/@hapi/joi/lib/modify.js
var require_modify2 = __commonJS({
  "node_modules/@hapi/joi/lib/modify.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Common = require_common2();
    var Ref = require_ref2();
    var internals = {};
    exports.Ids = internals.Ids = class {
      constructor() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      clone() {
        const clone = new internals.Ids();
        clone._byId = new Map(this._byId);
        clone._byKey = new Map(this._byKey);
        clone._schemaChain = this._schemaChain;
        return clone;
      }
      concat(source) {
        if (source._schemaChain) {
          this._schemaChain = true;
        }
        for (const [id, value] of source._byId.entries()) {
          Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, value);
        }
        for (const [key, value] of source._byKey.entries()) {
          Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, value);
        }
      }
      fork(path, adjuster, root) {
        const chain = this._collect(path);
        chain.push({ schema: root });
        const tail = chain.shift();
        let adjusted = { id: tail.id, schema: adjuster(tail.schema) };
        Assert(Common.isSchema(adjusted.schema), "adjuster function failed to return a joi schema type");
        for (const node of chain) {
          adjusted = { id: node.id, schema: internals.fork(node.schema, adjusted.id, adjusted.schema) };
        }
        return adjusted.schema;
      }
      labels(path, behind = []) {
        const current = path[0];
        const node = this._get(current);
        if (!node) {
          return [...behind, ...path].join(".");
        }
        const forward = path.slice(1);
        behind = [...behind, node.schema._flags.label || current];
        if (!forward.length) {
          return behind.join(".");
        }
        return node.schema._ids.labels(forward, behind);
      }
      reach(path, behind = []) {
        const current = path[0];
        const node = this._get(current);
        Assert(node, "Schema does not contain path", [...behind, ...path].join("."));
        const forward = path.slice(1);
        if (!forward.length) {
          return node.schema;
        }
        return node.schema._ids.reach(forward, [...behind, current]);
      }
      register(schema, { key } = {}) {
        if (!schema || !Common.isSchema(schema)) {
          return;
        }
        if (schema.$_property("schemaChain") || schema._ids._schemaChain) {
          this._schemaChain = true;
        }
        const id = schema._flags.id;
        if (id) {
          const existing = this._byId.get(id);
          Assert(!existing || existing.schema === schema, "Cannot add different schemas with the same id:", id);
          Assert(!this._byKey.has(id), "Schema id conflicts with existing key:", id);
          this._byId.set(id, { schema, id });
        }
        if (key) {
          Assert(!this._byKey.has(key), "Schema already contains key:", key);
          Assert(!this._byId.has(key), "Schema key conflicts with existing id:", key);
          this._byKey.set(key, { schema, id: key });
        }
      }
      reset() {
        this._byId = /* @__PURE__ */ new Map();
        this._byKey = /* @__PURE__ */ new Map();
        this._schemaChain = false;
      }
      _collect(path, behind = [], nodes = []) {
        const current = path[0];
        const node = this._get(current);
        Assert(node, "Schema does not contain path", [...behind, ...path].join("."));
        nodes = [node, ...nodes];
        const forward = path.slice(1);
        if (!forward.length) {
          return nodes;
        }
        return node.schema._ids._collect(forward, [...behind, current], nodes);
      }
      _get(id) {
        return this._byId.get(id) || this._byKey.get(id);
      }
    };
    internals.fork = function(schema, id, replacement) {
      const each = (item, { key }) => {
        if (id === (item._flags.id || key)) {
          return replacement;
        }
      };
      const obj = exports.schema(schema, { each, ref: false });
      return obj ? obj.$_mutateRebuild() : schema;
    };
    exports.schema = function(schema, options) {
      let obj;
      for (const name in schema._flags) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema._flags[name], { source: "flags", name }, options);
        if (result !== void 0) {
          obj = obj || schema.clone();
          obj._flags[name] = result;
        }
      }
      for (let i = 0; i < schema._rules.length; ++i) {
        const rule = schema._rules[i];
        const result = internals.scan(rule.args, { source: "rules", name: rule.name }, options);
        if (result !== void 0) {
          obj = obj || schema.clone();
          const clone = Object.assign({}, rule);
          clone.args = result;
          obj._rules[i] = clone;
          const existingUnique = obj._singleRules.get(rule.name);
          if (existingUnique === rule) {
            obj._singleRules.set(rule.name, clone);
          }
        }
      }
      for (const name in schema.$_terms) {
        if (name[0] === "_") {
          continue;
        }
        const result = internals.scan(schema.$_terms[name], { source: "terms", name }, options);
        if (result !== void 0) {
          obj = obj || schema.clone();
          obj.$_terms[name] = result;
        }
      }
      return obj;
    };
    internals.scan = function(item, source, options, _path, _key) {
      const path = _path || [];
      if (item === null || typeof item !== "object") {
        return;
      }
      let clone;
      if (Array.isArray(item)) {
        for (let i = 0; i < item.length; ++i) {
          const key = source.source === "terms" && source.name === "keys" && item[i].key;
          const result = internals.scan(item[i], source, options, [i, ...path], key);
          if (result !== void 0) {
            clone = clone || item.slice();
            clone[i] = result;
          }
        }
        return clone;
      }
      if (options.schema !== false && Common.isSchema(item) || options.ref !== false && Ref.isRef(item)) {
        const result = options.each(item, { ...source, path, key: _key });
        if (result === item) {
          return;
        }
        return result;
      }
      for (const key in item) {
        if (key[0] === "_") {
          continue;
        }
        const result = internals.scan(item[key], source, options, [key, ...path], _key);
        if (result !== void 0) {
          clone = clone || Object.assign({}, item);
          clone[key] = result;
        }
      }
      return clone;
    };
  }
});

// node_modules/@hapi/joi/lib/state.js
var require_state2 = __commonJS({
  "node_modules/@hapi/joi/lib/state.js"(exports, module2) {
    "use strict";
    var Clone = require_clone();
    var Reach = require_reach();
    var Common = require_common2();
    var internals = {
      value: Symbol("value")
    };
    module2.exports = internals.State = class {
      constructor(path, ancestors, state) {
        this.path = path;
        this.ancestors = ancestors;
        this.mainstay = state.mainstay;
        this.schemas = state.schemas;
        this.debug = null;
      }
      localize(path, ancestors = null, schema = null) {
        const state = new internals.State(path, ancestors, this);
        if (schema && state.schemas) {
          state.schemas = [internals.schemas(schema), ...state.schemas];
        }
        return state;
      }
      nest(schema, debug) {
        const state = new internals.State(this.path, this.ancestors, this);
        state.schemas = state.schemas && [internals.schemas(schema), ...state.schemas];
        state.debug = debug;
        return state;
      }
      shadow(value, reason) {
        this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();
        this.mainstay.shadow.set(this.path, value, reason);
      }
      snapshot() {
        if (this.mainstay.shadow) {
          this._snapshot = Clone(this.mainstay.shadow.node(this.path));
        }
      }
      restore() {
        if (this.mainstay.shadow) {
          this.mainstay.shadow.override(this.path, this._snapshot);
          this._snapshot = void 0;
        }
      }
    };
    internals.schemas = function(schema) {
      if (Common.isSchema(schema)) {
        return { schema };
      }
      return schema;
    };
    internals.Shadow = class {
      constructor() {
        this._values = null;
      }
      set(path, value, reason) {
        if (!path.length) {
          return;
        }
        if (reason === "strip" && typeof path[path.length - 1] === "number") {
          return;
        }
        this._values = this._values || /* @__PURE__ */ new Map();
        let node = this._values;
        for (let i = 0; i < path.length; ++i) {
          const segment = path[i];
          let next = node.get(segment);
          if (!next) {
            next = /* @__PURE__ */ new Map();
            node.set(segment, next);
          }
          node = next;
        }
        node[internals.value] = value;
      }
      get(path) {
        const node = this.node(path);
        if (node) {
          return node[internals.value];
        }
      }
      node(path) {
        if (!this._values) {
          return;
        }
        return Reach(this._values, path, { iterables: true });
      }
      override(path, node) {
        if (!this._values) {
          return;
        }
        const parents = path.slice(0, -1);
        const own = path[path.length - 1];
        const parent = Reach(this._values, parents, { iterables: true });
        if (node) {
          parent.set(own, node);
          return;
        }
        if (parent) {
          parent.delete(own);
        }
      }
    };
  }
});

// node_modules/@hapi/joi/lib/validator.js
var require_validator2 = __commonJS({
  "node_modules/@hapi/joi/lib/validator.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Ignore = require_ignore();
    var Reach = require_reach();
    var Common = require_common2();
    var Errors = require_errors2();
    var State = require_state2();
    var internals = {
      result: Symbol("result")
    };
    exports.entry = function(value, schema, prefs) {
      let settings = Common.defaults;
      if (prefs) {
        Assert(prefs.warnings === void 0, "Cannot override warnings preference in synchronous validation");
        settings = Common.preferences(Common.defaults, prefs);
      }
      const result = internals.entry(value, schema, settings);
      Assert(!result.mainstay.externals.length, "Schema with external rules must use validateAsync()");
      const outcome = { value: result.value };
      if (result.error) {
        outcome.error = result.error;
      }
      if (result.mainstay.warnings.length) {
        outcome.warning = Errors.details(result.mainstay.warnings);
      }
      if (result.mainstay.debug) {
        outcome.debug = result.mainstay.debug;
      }
      return outcome;
    };
    exports.entryAsync = async function(value, schema, prefs) {
      let settings = Common.defaults;
      if (prefs) {
        settings = Common.preferences(Common.defaults, prefs);
      }
      const result = internals.entry(value, schema, settings);
      const mainstay = result.mainstay;
      if (result.error) {
        if (mainstay.debug) {
          result.error.debug = mainstay.debug;
        }
        throw result.error;
      }
      if (mainstay.externals.length) {
        let root = result.value;
        for (const { method, path, label } of mainstay.externals) {
          let node = root;
          let key;
          let parent;
          if (path.length) {
            key = path[path.length - 1];
            parent = Reach(root, path.slice(0, -1));
            node = parent[key];
          }
          try {
            const output = await method(node);
            if (output === void 0 || output === node) {
              continue;
            }
            if (parent) {
              parent[key] = output;
            } else {
              root = output;
            }
          } catch (err) {
            err.message += ` (${label})`;
            throw err;
          }
        }
        result.value = root;
      }
      if (!settings.warnings && !settings.debug) {
        return result.value;
      }
      const outcome = { value: result.value };
      if (mainstay.warnings.length) {
        outcome.warning = Errors.details(mainstay.warnings);
      }
      if (mainstay.debug) {
        outcome.debug = mainstay.debug;
      }
      return outcome;
    };
    internals.entry = function(value, schema, prefs) {
      const { tracer, cleanup } = internals.tracer(schema, prefs);
      const debug = prefs.debug ? [] : null;
      const links = schema._ids._schemaChain ? /* @__PURE__ */ new Map() : null;
      const mainstay = { externals: [], warnings: [], tracer, debug, links };
      const schemas = schema._ids._schemaChain ? [{ schema }] : null;
      const state = new State([], [], { mainstay, schemas });
      const result = exports.validate(value, schema, state, prefs);
      if (cleanup) {
        schema.$_root.untrace();
      }
      const error = Errors.process(result.errors, value, prefs);
      return { value: result.value, error, mainstay };
    };
    internals.tracer = function(schema, prefs) {
      if (schema.$_root._tracer) {
        return { tracer: schema.$_root._tracer._register(schema) };
      }
      if (prefs.debug) {
        Assert(schema.$_root.trace, "Debug mode not supported");
        return { tracer: schema.$_root.trace()._register(schema), cleanup: true };
      }
      return { tracer: internals.ignore };
    };
    exports.validate = function(value, schema, state, prefs, overrides = {}) {
      if (schema.$_terms.whens) {
        schema = schema._generate(value, state, prefs).schema;
      }
      if (schema._preferences) {
        prefs = internals.prefs(schema, prefs);
      }
      if (schema._cache && prefs.cache) {
        const result = schema._cache.get(value);
        state.mainstay.tracer.debug(state, "validate", "cached", !!result);
        if (result) {
          return result;
        }
      }
      const createError = (code, local2, localState) => schema.$_createError(code, value, local2, localState || state, prefs);
      const helpers = {
        original: value,
        prefs,
        schema,
        state,
        error: createError,
        warn: (code, local2, localState) => state.mainstay.warnings.push(createError(code, local2, localState)),
        message: (messages, local2) => schema.$_createError("custom", value, local2, state, prefs, { messages })
      };
      state.mainstay.tracer.entry(schema, state);
      const def = schema._definition;
      if (def.prepare && value !== void 0 && prefs.convert) {
        const prepared = def.prepare(value, helpers);
        if (prepared) {
          state.mainstay.tracer.value(state, "prepare", value, prepared.value);
          if (prepared.errors) {
            return internals.finalize(prepared.value, [].concat(prepared.errors), helpers);
          }
          value = prepared.value;
        }
      }
      if (def.coerce && value !== void 0 && prefs.convert && (!def.coerce.from || def.coerce.from.includes(typeof value))) {
        const coerced = def.coerce.method(value, helpers);
        if (coerced) {
          state.mainstay.tracer.value(state, "coerced", value, coerced.value);
          if (coerced.errors) {
            return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);
          }
          value = coerced.value;
        }
      }
      const empty = schema._flags.empty;
      if (empty && empty.$_match(internals.trim(value, schema), state.nest(empty), Common.defaults)) {
        state.mainstay.tracer.value(state, "empty", value, void 0);
        value = void 0;
      }
      const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? "ignore" : prefs.presence);
      if (value === void 0) {
        if (presence === "forbidden") {
          return internals.finalize(value, null, helpers);
        }
        if (presence === "required") {
          return internals.finalize(value, [schema.$_createError("any.required", value, null, state, prefs)], helpers);
        }
        if (presence === "optional") {
          if (schema._flags.default !== Common.symbols.deepDefault) {
            return internals.finalize(value, null, helpers);
          }
          state.mainstay.tracer.value(state, "default", value, {});
          value = {};
        }
      } else if (presence === "forbidden") {
        return internals.finalize(value, [schema.$_createError("any.unknown", value, null, state, prefs)], helpers);
      }
      const errors = [];
      if (schema._valids) {
        const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
          if (prefs.convert) {
            state.mainstay.tracer.value(state, "valids", value, match.value);
            value = match.value;
          }
          state.mainstay.tracer.filter(schema, state, "valid", match);
          return internals.finalize(value, null, helpers);
        }
        if (schema._flags.only) {
          const report = schema.$_createError("any.only", value, { valids: schema._valids.values({ display: true }) }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [report], helpers);
          }
          errors.push(report);
        }
      }
      if (schema._invalids) {
        const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
          state.mainstay.tracer.filter(schema, state, "invalid", match);
          const report = schema.$_createError("any.invalid", value, { invalids: schema._invalids.values({ display: true }) }, state, prefs);
          if (prefs.abortEarly) {
            return internals.finalize(value, [report], helpers);
          }
          errors.push(report);
        }
      }
      if (def.validate) {
        const base = def.validate(value, helpers);
        if (base) {
          state.mainstay.tracer.value(state, "base", value, base.value);
          value = base.value;
          if (base.errors) {
            if (!Array.isArray(base.errors)) {
              errors.push(base.errors);
              return internals.finalize(value, errors, helpers);
            }
            if (base.errors.length) {
              errors.push(...base.errors);
              return internals.finalize(value, errors, helpers);
            }
          }
        }
      }
      if (!schema._rules.length) {
        return internals.finalize(value, errors, helpers);
      }
      return internals.rules(value, errors, helpers);
    };
    internals.rules = function(value, errors, helpers) {
      const { schema, state, prefs } = helpers;
      for (const rule of schema._rules) {
        const definition = schema._definition.rules[rule.method];
        if (definition.convert && prefs.convert) {
          state.mainstay.tracer.log(schema, state, "rule", rule.name, "full");
          continue;
        }
        let ret;
        let args = rule.args;
        if (rule._resolve.length) {
          args = Object.assign({}, args);
          for (const key of rule._resolve) {
            const resolver = definition.argsByName.get(key);
            const resolved = args[key].resolve(value, state, prefs);
            const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;
            const invalid = Common.validateArg(normalized, null, resolver);
            if (invalid) {
              ret = schema.$_createError("any.ref", resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);
              break;
            }
            args[key] = normalized;
          }
        }
        ret = ret || definition.validate(value, helpers, args, rule);
        const result = internals.rule(ret, rule);
        if (result.errors) {
          state.mainstay.tracer.log(schema, state, "rule", rule.name, "error");
          if (rule.warn) {
            state.mainstay.warnings.push(...result.errors);
            continue;
          }
          if (prefs.abortEarly) {
            return internals.finalize(value, result.errors, helpers);
          }
          errors.push(...result.errors);
        } else {
          state.mainstay.tracer.log(schema, state, "rule", rule.name, "pass");
          state.mainstay.tracer.value(state, "rule", value, result.value, rule.name);
          value = result.value;
        }
      }
      return internals.finalize(value, errors, helpers);
    };
    internals.rule = function(ret, rule) {
      if (ret instanceof Errors.Report) {
        internals.error(ret, rule);
        return { errors: [ret], value: null };
      }
      if (Array.isArray(ret) && (ret[0] instanceof Errors.Report || ret[0] instanceof Error)) {
        ret.forEach((report) => internals.error(report, rule));
        return { errors: ret, value: null };
      }
      return { errors: null, value: ret };
    };
    internals.error = function(report, rule) {
      if (rule.message) {
        report._setTemplate(rule.message);
      }
      return report;
    };
    internals.finalize = function(value, errors, helpers) {
      errors = errors || [];
      const { schema, state, prefs } = helpers;
      if (errors.length) {
        const failover = internals.default("failover", void 0, errors, helpers);
        if (failover !== void 0) {
          state.mainstay.tracer.value(state, "failover", value, failover);
          value = failover;
          errors = [];
        }
      }
      if (errors.length && schema._flags.error) {
        if (typeof schema._flags.error === "function") {
          errors = schema._flags.error(errors);
          if (!Array.isArray(errors)) {
            errors = [errors];
          }
          for (const error of errors) {
            Assert(error instanceof Error || error instanceof Errors.Report, "error() must return an Error object");
          }
        } else {
          errors = [schema._flags.error];
        }
      }
      if (value === void 0) {
        const defaulted = internals.default("default", value, errors, helpers);
        state.mainstay.tracer.value(state, "default", value, defaulted);
        value = defaulted;
      }
      if (schema._flags.cast && value !== void 0) {
        const caster = schema._definition.cast[schema._flags.cast];
        if (caster.from(value)) {
          const casted = caster.to(value, helpers);
          state.mainstay.tracer.value(state, "cast", value, casted, schema._flags.cast);
          value = casted;
        }
      }
      if (schema.$_terms.externals && prefs.externals && prefs._externals !== false) {
        for (const { method } of schema.$_terms.externals) {
          state.mainstay.externals.push({ method, path: state.path, label: Errors.label(schema._flags, state, prefs) });
        }
      }
      const result = { value, errors: errors.length ? errors : null };
      if (schema._flags.result) {
        result.value = schema._flags.result === "strip" ? void 0 : helpers.original;
        state.mainstay.tracer.value(state, schema._flags.result, value, result.value);
        state.shadow(value, schema._flags.result);
      }
      if (schema._cache && prefs.cache !== false && !schema._refs.length) {
        schema._cache.set(helpers.original, result);
      }
      return result;
    };
    internals.prefs = function(schema, prefs) {
      const isDefaultOptions = prefs === Common.defaults;
      if (isDefaultOptions && schema._preferences[Common.symbols.prefs]) {
        return schema._preferences[Common.symbols.prefs];
      }
      prefs = Common.preferences(prefs, schema._preferences);
      if (isDefaultOptions) {
        schema._preferences[Common.symbols.prefs] = prefs;
      }
      return prefs;
    };
    internals.default = function(flag, value, errors, helpers) {
      const { schema, state, prefs } = helpers;
      const source = schema._flags[flag];
      if (prefs.noDefaults || source === void 0) {
        return value;
      }
      state.mainstay.tracer.log(schema, state, "rule", flag, "full");
      if (!source) {
        return source;
      }
      if (typeof source === "function") {
        const args = source.length ? [Clone(state.ancestors[0]), helpers] : [];
        try {
          return source(...args);
        } catch (err) {
          errors.push(schema.$_createError(`any.${flag}`, null, { error: err }, state, prefs));
          return;
        }
      }
      if (typeof source !== "object") {
        return source;
      }
      if (source[Common.symbols.literal]) {
        return source.literal;
      }
      if (Common.isResolvable(source)) {
        return source.resolve(value, state, prefs);
      }
      return Clone(source);
    };
    internals.trim = function(value, schema) {
      if (typeof value !== "string") {
        return value;
      }
      const trim = schema.$_getRule("trim");
      if (!trim || !trim.args.enabled) {
        return value;
      }
      return value.trim();
    };
    internals.ignore = {
      active: false,
      debug: Ignore,
      entry: Ignore,
      filter: Ignore,
      log: Ignore,
      resolve: Ignore,
      value: Ignore
    };
  }
});

// node_modules/@hapi/joi/lib/values.js
var require_values2 = __commonJS({
  "node_modules/@hapi/joi/lib/values.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var Common = require_common2();
    var internals = {};
    module2.exports = internals.Values = class {
      constructor(values, refs) {
        this._values = new Set(values);
        this._refs = new Set(refs);
        this._lowercase = internals.lowercases(values);
        this._override = false;
      }
      get length() {
        return this._values.size + this._refs.size;
      }
      add(value, refs) {
        if (Common.isResolvable(value)) {
          if (!this._refs.has(value)) {
            this._refs.add(value);
            if (refs) {
              refs.register(value);
            }
          }
          return;
        }
        if (!this.has(value, null, null, false)) {
          this._values.add(value);
          if (typeof value === "string") {
            this._lowercase.set(value.toLowerCase(), value);
          }
        }
      }
      static merge(target, source, remove) {
        target = target || new internals.Values();
        if (source) {
          if (source._override) {
            return source.clone();
          }
          for (const item of [...source._values, ...source._refs]) {
            target.add(item);
          }
        }
        if (remove) {
          for (const item of [...remove._values, ...remove._refs]) {
            target.remove(item);
          }
        }
        return target.length ? target : null;
      }
      remove(value) {
        if (Common.isResolvable(value)) {
          this._refs.delete(value);
          return;
        }
        this._values.delete(value);
        if (typeof value === "string") {
          this._lowercase.delete(value.toLowerCase());
        }
      }
      has(value, state, prefs, insensitive) {
        return !!this.get(value, state, prefs, insensitive);
      }
      get(value, state, prefs, insensitive) {
        if (!this.length) {
          return false;
        }
        if (this._values.has(value)) {
          return { value };
        }
        if (typeof value === "string" && value && insensitive) {
          const found = this._lowercase.get(value.toLowerCase());
          if (found) {
            return { value: found };
          }
        }
        if (!this._refs.size && typeof value !== "object") {
          return false;
        }
        if (typeof value === "object") {
          for (const item of this._values) {
            if (DeepEqual(item, value)) {
              return { value: item };
            }
          }
        }
        if (state) {
          for (const ref of this._refs) {
            const resolved = ref.resolve(value, state, prefs, null, { in: true });
            if (resolved === void 0) {
              continue;
            }
            const items = !ref.in || typeof resolved !== "object" ? [resolved] : Array.isArray(resolved) ? resolved : Object.keys(resolved);
            for (const item of items) {
              if (typeof item !== typeof value) {
                continue;
              }
              if (insensitive && value && typeof value === "string") {
                if (item.toLowerCase() === value.toLowerCase()) {
                  return { value: item, ref };
                }
              } else {
                if (DeepEqual(item, value)) {
                  return { value: item, ref };
                }
              }
            }
          }
        }
        return false;
      }
      override() {
        this._override = true;
      }
      values(options) {
        if (options && options.display) {
          const values = [];
          for (const item of [...this._values, ...this._refs]) {
            if (item !== void 0) {
              values.push(item);
            }
          }
          return values;
        }
        return Array.from([...this._values, ...this._refs]);
      }
      clone() {
        const set = new internals.Values(this._values, this._refs);
        set._override = this._override;
        return set;
      }
      concat(source) {
        Assert(!source._override, "Cannot concat override set of values");
        const set = new internals.Values([...this._values, ...source._values], [...this._refs, ...source._refs]);
        set._override = this._override;
        return set;
      }
      describe() {
        const normalized = [];
        if (this._override) {
          normalized.push({ override: true });
        }
        for (const value of this._values.values()) {
          normalized.push(value && typeof value === "object" ? { value } : value);
        }
        for (const value of this._refs.values()) {
          normalized.push(value.describe());
        }
        return normalized;
      }
    };
    internals.Values.prototype[Common.symbols.values] = true;
    internals.Values.prototype.slice = internals.Values.prototype.clone;
    internals.lowercases = function(from) {
      const map = /* @__PURE__ */ new Map();
      if (from) {
        for (const value of from) {
          if (typeof value === "string") {
            map.set(value.toLowerCase(), value);
          }
        }
      }
      return map;
    };
  }
});

// node_modules/@hapi/joi/lib/base.js
var require_base2 = __commonJS({
  "node_modules/@hapi/joi/lib/base.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var DeepEqual = require_deepEqual();
    var Merge = require_merge();
    var Cache = require_cache();
    var Common = require_common2();
    var Compile = require_compile2();
    var Errors = require_errors2();
    var Extend = require_extend2();
    var Manifest = require_manifest();
    var Messages = require_messages2();
    var Modify = require_modify2();
    var Ref = require_ref2();
    var Trace = require_trace();
    var Validator = require_validator2();
    var Values = require_values2();
    var internals = {};
    internals.Base = class {
      constructor(type) {
        this.type = type;
        this.$_root = null;
        this._definition = {};
        this._ids = new Modify.Ids();
        this._preferences = null;
        this._refs = new Ref.Manager();
        this._cache = null;
        this._valids = null;
        this._invalids = null;
        this._flags = {};
        this._rules = [];
        this._singleRules = /* @__PURE__ */ new Map();
        this.$_terms = {};
        this.$_temp = {
          ruleset: null,
          whens: {}
        };
      }
      describe() {
        Assert(typeof Manifest.describe === "function", "Manifest functionality disabled");
        return Manifest.describe(this);
      }
      allow(...values) {
        Common.verifyFlat(values, "allow");
        return this._values(values, "_valids");
      }
      alter(targets) {
        Assert(targets && typeof targets === "object" && !Array.isArray(targets), "Invalid targets argument");
        Assert(!this._inRuleset(), "Cannot set alterations inside a ruleset");
        const obj = this.clone();
        obj.$_terms.alterations = obj.$_terms.alterations || [];
        for (const target in targets) {
          const adjuster = targets[target];
          Assert(typeof adjuster === "function", "Alteration adjuster for", target, "must be a function");
          obj.$_terms.alterations.push({ target, adjuster });
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      cast(to) {
        Assert(to === false || typeof to === "string", "Invalid to value");
        Assert(to === false || this._definition.cast[to], "Type", this.type, "does not support casting to", to);
        return this.$_setFlag("cast", to === false ? void 0 : to);
      }
      default(value, options) {
        return this._default("default", value, options);
      }
      description(desc) {
        Assert(desc && typeof desc === "string", "Description must be a non-empty string");
        return this.$_setFlag("description", desc);
      }
      empty(schema) {
        const obj = this.clone();
        if (schema !== void 0) {
          schema = obj.$_compile(schema, { override: false });
        }
        return obj.$_setFlag("empty", schema, { clone: false });
      }
      error(err) {
        Assert(err, "Missing error");
        Assert(err instanceof Error || typeof err === "function", "Must provide a valid Error object or a function");
        return this.$_setFlag("error", err);
      }
      example(example, options = {}) {
        Assert(example !== void 0, "Missing example");
        Common.assertOptions(options, ["override"]);
        return this._inner("examples", example, { single: true, override: options.override });
      }
      external(method, description) {
        if (typeof method === "object") {
          Assert(!description, "Cannot combine options with description");
          description = method.description;
          method = method.method;
        }
        Assert(typeof method === "function", "Method must be a function");
        Assert(description === void 0 || description && typeof description === "string", "Description must be a non-empty string");
        return this._inner("externals", { method, description }, { single: true });
      }
      failover(value, options) {
        return this._default("failover", value, options);
      }
      forbidden() {
        return this.presence("forbidden");
      }
      id(id) {
        if (!id) {
          return this.$_setFlag("id", void 0);
        }
        Assert(typeof id === "string", "id must be a non-empty string");
        Assert(/^[^\.]+$/.test(id), "id cannot contain period character");
        return this.$_setFlag("id", id);
      }
      invalid(...values) {
        return this._values(values, "_invalids");
      }
      label(name) {
        Assert(name && typeof name === "string", "Label name must be a non-empty string");
        return this.$_setFlag("label", name);
      }
      meta(meta) {
        Assert(meta !== void 0, "Meta cannot be undefined");
        return this._inner("metas", meta, { single: true });
      }
      note(...notes) {
        Assert(notes.length, "Missing notes");
        for (const note of notes) {
          Assert(note && typeof note === "string", "Notes must be non-empty strings");
        }
        return this._inner("notes", notes);
      }
      only(mode = true) {
        Assert(typeof mode === "boolean", "Invalid mode:", mode);
        return this.$_setFlag("only", mode);
      }
      optional() {
        return this.presence("optional");
      }
      prefs(prefs) {
        Assert(prefs, "Missing preferences");
        Assert(prefs.context === void 0, "Cannot override context");
        Assert(prefs.externals === void 0, "Cannot override externals");
        Assert(prefs.warnings === void 0, "Cannot override warnings");
        Assert(prefs.debug === void 0, "Cannot override debug");
        Common.checkPreferences(prefs);
        const obj = this.clone();
        obj._preferences = Common.preferences(obj._preferences, prefs);
        return obj;
      }
      presence(mode) {
        Assert(["optional", "required", "forbidden"].includes(mode), "Unknown presence mode", mode);
        return this.$_setFlag("presence", mode);
      }
      raw(enabled = true) {
        return this.$_setFlag("result", enabled ? "raw" : void 0);
      }
      result(mode) {
        Assert(["raw", "strip"].includes(mode), "Unknown result mode", mode);
        return this.$_setFlag("result", mode);
      }
      required() {
        return this.presence("required");
      }
      strict(enabled) {
        const obj = this.clone();
        const convert = enabled === void 0 ? false : !enabled;
        obj._preferences = Common.preferences(obj._preferences, { convert });
        return obj;
      }
      strip(enabled = true) {
        return this.$_setFlag("result", enabled ? "strip" : void 0);
      }
      tag(...tags) {
        Assert(tags.length, "Missing tags");
        for (const tag of tags) {
          Assert(tag && typeof tag === "string", "Tags must be non-empty strings");
        }
        return this._inner("tags", tags);
      }
      unit(name) {
        Assert(name && typeof name === "string", "Unit name must be a non-empty string");
        return this.$_setFlag("unit", name);
      }
      valid(...values) {
        Common.verifyFlat(values, "valid");
        const obj = this.allow(...values);
        obj.$_setFlag("only", !!obj._valids, { clone: false });
        return obj;
      }
      when(condition, options) {
        const obj = this.clone();
        if (!obj.$_terms.whens) {
          obj.$_terms.whens = [];
        }
        const when = Compile.when(obj, condition, options);
        if (!["any", "link"].includes(obj.type)) {
          const conditions = when.is ? [when] : when.switch;
          for (const item of conditions) {
            Assert(!item.then || item.then.type === "any" || item.then.type === obj.type, "Cannot combine", obj.type, "with", item.then && item.then.type);
            Assert(!item.otherwise || item.otherwise.type === "any" || item.otherwise.type === obj.type, "Cannot combine", obj.type, "with", item.otherwise && item.otherwise.type);
          }
        }
        obj.$_terms.whens.push(when);
        return obj.$_mutateRebuild();
      }
      cache(cache) {
        Assert(!this._inRuleset(), "Cannot set caching inside a ruleset");
        Assert(!this._cache, "Cannot override schema cache");
        const obj = this.clone();
        obj._cache = cache || Cache.provider.provision();
        obj.$_temp.ruleset = false;
        return obj;
      }
      clone() {
        const obj = Object.create(Object.getPrototypeOf(this));
        return this._assign(obj);
      }
      concat(source) {
        Assert(Common.isSchema(source), "Invalid schema object");
        Assert(this.type === "any" || source.type === "any" || source.type === this.type, "Cannot merge type", this.type, "with another type:", source.type);
        Assert(!this._inRuleset(), "Cannot concatenate onto a schema with open ruleset");
        Assert(!source._inRuleset(), "Cannot concatenate a schema with open ruleset");
        let obj = this.clone();
        if (this.type === "any" && source.type !== "any") {
          const tmpObj = source.clone();
          for (const key of Object.keys(obj)) {
            if (key !== "type") {
              tmpObj[key] = obj[key];
            }
          }
          obj = tmpObj;
        }
        obj._ids.concat(source._ids);
        obj._refs.register(source, Ref.toSibling);
        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);
        for (const name of source._singleRules.keys()) {
          if (obj._singleRules.has(name)) {
            obj._rules = obj._rules.filter((target) => target.keep || target.name !== name);
            obj._singleRules.delete(name);
          }
        }
        for (const test of source._rules) {
          if (!source._definition.rules[test.method].multi) {
            obj._singleRules.set(test.name, test);
          }
          obj._rules.push(test);
        }
        if (obj._flags.empty && source._flags.empty) {
          obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
          const flags = Object.assign({}, source._flags);
          delete flags.empty;
          Merge(obj._flags, flags);
        } else if (source._flags.empty) {
          obj._flags.empty = source._flags.empty;
          const flags = Object.assign({}, source._flags);
          delete flags.empty;
          Merge(obj._flags, flags);
        } else {
          Merge(obj._flags, source._flags);
        }
        for (const key in source.$_terms) {
          const terms = source.$_terms[key];
          if (!terms) {
            if (!obj.$_terms[key]) {
              obj.$_terms[key] = terms;
            }
            continue;
          }
          if (!obj.$_terms[key]) {
            obj.$_terms[key] = terms.slice();
            continue;
          }
          obj.$_terms[key] = obj.$_terms[key].concat(terms);
        }
        if (this.$_root._tracer) {
          this.$_root._tracer._combine(obj, [this, source]);
        }
        return obj.$_mutateRebuild();
      }
      extend(options) {
        Assert(!options.base, "Cannot extend type with another base");
        return Extend.type(this, options);
      }
      extract(path) {
        path = Array.isArray(path) ? path : path.split(".");
        return this._ids.reach(path);
      }
      fork(paths, adjuster) {
        Assert(!this._inRuleset(), "Cannot fork inside a ruleset");
        let obj = this;
        for (let path of [].concat(paths)) {
          path = Array.isArray(path) ? path : path.split(".");
          obj = obj._ids.fork(path, adjuster, obj);
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      rule(options) {
        const def = this._definition;
        Common.assertOptions(options, Object.keys(def.modifiers));
        Assert(this.$_temp.ruleset !== false, "Cannot apply rules to empty ruleset or the last rule added does not support rule properties");
        const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
        Assert(start >= 0 && start < this._rules.length, "Cannot apply rules to empty ruleset");
        const obj = this.clone();
        for (let i = start; i < obj._rules.length; ++i) {
          const original = obj._rules[i];
          const rule = Clone(original);
          for (const name in options) {
            def.modifiers[name](rule, options[name]);
            Assert(rule.name === original.name, "Cannot change rule name");
          }
          obj._rules[i] = rule;
          if (obj._singleRules.get(rule.name) === original) {
            obj._singleRules.set(rule.name, rule);
          }
        }
        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
      }
      get ruleset() {
        Assert(!this._inRuleset(), "Cannot start a new ruleset without closing the previous one");
        const obj = this.clone();
        obj.$_temp.ruleset = obj._rules.length;
        return obj;
      }
      get $() {
        return this.ruleset;
      }
      tailor(targets) {
        targets = [].concat(targets);
        Assert(!this._inRuleset(), "Cannot tailor inside a ruleset");
        let obj = this;
        if (this.$_terms.alterations) {
          for (const { target, adjuster } of this.$_terms.alterations) {
            if (targets.includes(target)) {
              obj = adjuster(obj);
              Assert(Common.isSchema(obj), "Alteration adjuster for", target, "failed to return a schema object");
            }
          }
        }
        obj = obj.$_modify({ each: (item) => item.tailor(targets), ref: false });
        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
      }
      tracer() {
        return Trace.location ? Trace.location(this) : this;
      }
      validate(value, options) {
        return Validator.entry(value, this, options);
      }
      validateAsync(value, options) {
        return Validator.entryAsync(value, this, options);
      }
      $_addRule(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        Assert(options && typeof options === "object", "Invalid options");
        Assert(options.name && typeof options.name === "string", "Invalid rule name");
        for (const key in options) {
          Assert(key[0] !== "_", "Cannot set private rule properties");
        }
        const rule = Object.assign({}, options);
        rule._resolve = [];
        rule.method = rule.method || rule.name;
        const definition = this._definition.rules[rule.method];
        const args = rule.args;
        Assert(definition, "Unknown rule", rule.method);
        const obj = this.clone();
        if (args) {
          Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, "Invalid rule definition for", this.type, rule.name);
          for (const key in args) {
            let arg = args[key];
            if (arg === void 0) {
              delete args[key];
              continue;
            }
            if (definition.argsByName) {
              const resolver = definition.argsByName.get(key);
              if (resolver.ref && Common.isResolvable(arg)) {
                rule._resolve.push(key);
                obj.$_mutateRegister(arg);
              } else {
                if (resolver.normalize) {
                  arg = resolver.normalize(arg);
                  args[key] = arg;
                }
                if (resolver.assert) {
                  const error = Common.validateArg(arg, key, resolver);
                  Assert(!error, error, "or reference");
                }
              }
            }
            args[key] = arg;
          }
        }
        if (!definition.multi) {
          obj._ruleRemove(rule.name, { clone: false });
          obj._singleRules.set(rule.name, rule);
        }
        if (obj.$_temp.ruleset === false) {
          obj.$_temp.ruleset = null;
        }
        if (definition.priority) {
          obj._rules.unshift(rule);
        } else {
          obj._rules.push(rule);
        }
        return obj;
      }
      $_compile(schema, options) {
        return Compile.schema(this.$_root, schema, options);
      }
      $_createError(code, value, local2, state, prefs, options = {}) {
        const flags = options.flags !== false ? this._flags : {};
        const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;
        return new Errors.Report(code, value, local2, flags, messages, state, prefs);
      }
      $_getFlag(name) {
        return this._flags[name];
      }
      $_getRule(name) {
        return this._singleRules.get(name);
      }
      $_mapLabels(path) {
        path = Array.isArray(path) ? path : path.split(".");
        return this._ids.labels(path);
      }
      $_match(value, state, prefs, overrides) {
        prefs = Object.assign({}, prefs);
        prefs.abortEarly = true;
        prefs._externals = false;
        state.snapshot();
        const result = !Validator.validate(value, this, state, prefs, overrides).errors;
        state.restore();
        return result;
      }
      $_modify(options) {
        Common.assertOptions(options, ["each", "once", "ref", "schema"]);
        return Modify.schema(this, options) || this;
      }
      $_mutateRebuild() {
        Assert(!this._inRuleset(), "Cannot add this rule inside a ruleset");
        this._refs.reset();
        this._ids.reset();
        const each = (item, { source, name, path, key }) => {
          const family = this._definition[source][name] && this._definition[source][name].register;
          if (family !== false) {
            this.$_mutateRegister(item, { family, key });
          }
        };
        this.$_modify({ each });
        if (this._definition.rebuild) {
          this._definition.rebuild(this);
        }
        this.$_temp.ruleset = false;
        return this;
      }
      $_mutateRegister(schema, { family, key } = {}) {
        this._refs.register(schema, family);
        this._ids.register(schema, { key });
      }
      $_property(name) {
        return this._definition.properties[name];
      }
      $_reach(path) {
        return this._ids.reach(path);
      }
      $_rootReferences() {
        return this._refs.roots();
      }
      $_setFlag(name, value, options = {}) {
        Assert(name[0] === "_" || !this._inRuleset(), "Cannot set flag inside a ruleset");
        const flag = this._definition.flags[name] || {};
        if (DeepEqual(value, flag.default)) {
          value = void 0;
        }
        if (DeepEqual(value, this._flags[name])) {
          return this;
        }
        const obj = options.clone !== false ? this.clone() : this;
        if (value !== void 0) {
          obj._flags[name] = value;
          obj.$_mutateRegister(value);
        } else {
          delete obj._flags[name];
        }
        if (name[0] !== "_") {
          obj.$_temp.ruleset = false;
        }
        return obj;
      }
      $_validate(value, state, prefs) {
        return Validator.validate(value, this, state, prefs);
      }
      _assign(target) {
        target.type = this.type;
        target.$_root = this.$_root;
        target.$_temp = Object.assign({}, this.$_temp);
        target.$_temp.whens = {};
        target._ids = this._ids.clone();
        target._preferences = this._preferences;
        target._valids = this._valids && this._valids.clone();
        target._invalids = this._invalids && this._invalids.clone();
        target._rules = this._rules.slice();
        target._singleRules = Clone(this._singleRules, { shallow: true });
        target._refs = this._refs.clone();
        target._flags = Object.assign({}, this._flags);
        target._cache = null;
        target.$_terms = {};
        for (const key in this.$_terms) {
          target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
        }
        target.$_super = {};
        for (const override in this.$_super) {
          target.$_super[override] = this._super[override].bind(target);
        }
        return target;
      }
      _default(flag, value, options = {}) {
        Common.assertOptions(options, "literal");
        Assert(value !== void 0, "Missing", flag, "value");
        Assert(typeof value === "function" || !options.literal, "Only function value supports literal option");
        if (typeof value === "function" && options.literal) {
          value = {
            [Common.symbols.literal]: true,
            literal: value
          };
        }
        const obj = this.$_setFlag(flag, value);
        return obj;
      }
      _generate(value, state, prefs) {
        if (!this.$_terms.whens) {
          return { schema: this };
        }
        const whens = [];
        const ids = [];
        for (let i = 0; i < this.$_terms.whens.length; ++i) {
          const when = this.$_terms.whens[i];
          if (when.concat) {
            whens.push(when.concat);
            ids.push(`${i}.concat`);
            continue;
          }
          const input = when.ref ? when.ref.resolve(value, state, prefs) : value;
          const tests = when.is ? [when] : when.switch;
          const before = ids.length;
          for (let j = 0; j < tests.length; ++j) {
            const { is, then, otherwise } = tests[j];
            const baseId = `${i}${when.switch ? "." + j : ""}`;
            if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {
              if (then) {
                const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);
                const { schema: generated, id: id2 } = then._generate(value, localState, prefs);
                whens.push(generated);
                ids.push(`${baseId}.then${id2 ? `(${id2})` : ""}`);
                break;
              }
            } else if (otherwise) {
              const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);
              const { schema: generated, id: id2 } = otherwise._generate(value, localState, prefs);
              whens.push(generated);
              ids.push(`${baseId}.otherwise${id2 ? `(${id2})` : ""}`);
              break;
            }
          }
          if (when.break && ids.length > before) {
            break;
          }
        }
        const id = ids.join(", ");
        state.mainstay.tracer.debug(state, "rule", "when", id);
        if (!id) {
          return { schema: this };
        }
        if (!state.mainstay.tracer.active && this.$_temp.whens[id]) {
          return { schema: this.$_temp.whens[id], id };
        }
        let obj = this;
        if (this._definition.generate) {
          obj = this._definition.generate(this, value, state, prefs);
        }
        for (const when of whens) {
          obj = obj.concat(when);
        }
        if (this.$_root._tracer) {
          this.$_root._tracer._combine(obj, [this, ...whens]);
        }
        this.$_temp.whens[id] = obj;
        return { schema: obj, id };
      }
      _inner(type, values, options = {}) {
        Assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);
        const obj = this.clone();
        if (!obj.$_terms[type] || options.override) {
          obj.$_terms[type] = [];
        }
        if (options.single) {
          obj.$_terms[type].push(values);
        } else {
          obj.$_terms[type].push(...values);
        }
        obj.$_temp.ruleset = false;
        return obj;
      }
      _inRuleset() {
        return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
      }
      _ruleRemove(name, options = {}) {
        if (!this._singleRules.has(name)) {
          return this;
        }
        const obj = options.clone !== false ? this.clone() : this;
        obj._singleRules.delete(name);
        const filtered = [];
        for (let i = 0; i < obj._rules.length; ++i) {
          const test = obj._rules[i];
          if (test.name === name && !test.keep) {
            if (obj._inRuleset() && i < obj.$_temp.ruleset) {
              --obj.$_temp.ruleset;
            }
            continue;
          }
          filtered.push(test);
        }
        obj._rules = filtered;
        return obj;
      }
      _values(values, key) {
        Common.verifyFlat(values, key.slice(1, -1));
        const obj = this.clone();
        const override = values[0] === Common.symbols.override;
        if (override) {
          values = values.slice(1);
        }
        if (!obj[key] && values.length) {
          obj[key] = new Values();
        } else if (override) {
          obj[key] = values.length ? new Values() : null;
          obj.$_mutateRebuild();
        }
        if (!obj[key]) {
          return obj;
        }
        if (override) {
          obj[key].override();
        }
        for (const value of values) {
          Assert(value !== void 0, "Cannot call allow/valid/invalid with undefined");
          Assert(value !== Common.symbols.override, "Override must be the first value");
          const other = key === "_invalids" ? "_valids" : "_invalids";
          if (obj[other]) {
            obj[other].remove(value);
            if (!obj[other].length) {
              Assert(key === "_valids" || !obj._flags.only, "Setting invalid value", value, "leaves schema rejecting all values due to previous valid rule");
              obj[other] = null;
            }
          }
          obj[key].add(value, obj._refs);
        }
        return obj;
      }
    };
    internals.Base.prototype[Common.symbols.any] = {
      version: Common.version,
      compile: Compile.compile,
      root: "$_root"
    };
    internals.Base.prototype.isImmutable = true;
    internals.Base.prototype.deny = internals.Base.prototype.invalid;
    internals.Base.prototype.disallow = internals.Base.prototype.invalid;
    internals.Base.prototype.equal = internals.Base.prototype.valid;
    internals.Base.prototype.exist = internals.Base.prototype.required;
    internals.Base.prototype.not = internals.Base.prototype.invalid;
    internals.Base.prototype.options = internals.Base.prototype.prefs;
    internals.Base.prototype.preferences = internals.Base.prototype.prefs;
    module2.exports = new internals.Base();
  }
});

// node_modules/@hapi/joi/lib/types/any.js
var require_any2 = __commonJS({
  "node_modules/@hapi/joi/lib/types/any.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Base = require_base2();
    var Common = require_common2();
    var Messages = require_messages2();
    module2.exports = Base.extend({
      type: "any",
      flags: {
        only: { default: false }
      },
      terms: {
        alterations: { init: null },
        examples: { init: null },
        externals: { init: null },
        metas: { init: [] },
        notes: { init: [] },
        shared: { init: null },
        tags: { init: [] },
        whens: { init: null }
      },
      rules: {
        custom: {
          method(method, description) {
            Assert(typeof method === "function", "Method must be a function");
            Assert(description === void 0 || description && typeof description === "string", "Description must be a non-empty string");
            return this.$_addRule({ name: "custom", args: { method, description } });
          },
          validate(value, helpers, { method }) {
            try {
              return method(value, helpers);
            } catch (err) {
              return helpers.error("any.custom", { error: err });
            }
          },
          args: ["method", "description"],
          multi: true
        },
        messages: {
          method(messages) {
            return this.prefs({ messages });
          }
        },
        shared: {
          method(schema) {
            Assert(Common.isSchema(schema) && schema._flags.id, "Schema must be a schema with an id");
            const obj = this.clone();
            obj.$_terms.shared = obj.$_terms.shared || [];
            obj.$_terms.shared.push(schema);
            obj.$_mutateRegister(schema);
            return obj;
          }
        },
        warning: {
          method(code, local2) {
            Assert(code && typeof code === "string", "Invalid warning code");
            return this.$_addRule({ name: "warning", args: { code, local: local2 }, warn: true });
          },
          validate(value, helpers, { code, local: local2 }) {
            return helpers.error(code, local2);
          },
          args: ["code", "local"],
          multi: true
        }
      },
      modifiers: {
        keep(rule, enabled = true) {
          rule.keep = enabled;
        },
        message(rule, message) {
          rule.message = Messages.compile(message);
        },
        warn(rule, enabled = true) {
          rule.warn = enabled;
        }
      },
      manifest: {
        build(obj, desc) {
          for (const key in desc) {
            const values = desc[key];
            if (["examples", "externals", "metas", "notes", "tags"].includes(key)) {
              for (const value of values) {
                obj = obj[key.slice(0, -1)](value);
              }
              continue;
            }
            if (key === "alterations") {
              const alter = {};
              for (const { target, adjuster } of values) {
                alter[target] = adjuster;
              }
              obj = obj.alter(alter);
              continue;
            }
            if (key === "whens") {
              for (const value of values) {
                const { ref, is, not, then, otherwise, concat } = value;
                if (concat) {
                  obj = obj.concat(concat);
                } else if (ref) {
                  obj = obj.when(ref, { is, not, then, otherwise, switch: value.switch, break: value.break });
                } else {
                  obj = obj.when(is, { then, otherwise, break: value.break });
                }
              }
              continue;
            }
            if (key === "shared") {
              for (const value of values) {
                obj = obj.shared(value);
              }
            }
          }
          return obj;
        }
      },
      messages: {
        "any.custom": "{{#label}} failed custom validation because {{#error.message}}",
        "any.default": "{{#label}} threw an error when running default method",
        "any.failover": "{{#label}} threw an error when running failover method",
        "any.invalid": "{{#label}} contains an invalid value",
        "any.only": '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
        "any.ref": '{{#label}} {{#arg}} references "{{#ref}}" which {{#reason}}',
        "any.required": "{{#label}} is required",
        "any.unknown": "{{#label}} is not allowed"
      }
    });
  }
});

// node_modules/@hapi/joi/lib/types/alternatives.js
var require_alternatives2 = __commonJS({
  "node_modules/@hapi/joi/lib/types/alternatives.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any2();
    var Common = require_common2();
    var Compile = require_compile2();
    var Errors = require_errors2();
    var Ref = require_ref2();
    var internals = {};
    module2.exports = Any.extend({
      type: "alternatives",
      flags: {
        match: { default: "any" }
      },
      terms: {
        matches: { init: [], register: Ref.toSibling }
      },
      args(schema, ...schemas) {
        if (schemas.length === 1) {
          if (Array.isArray(schemas[0])) {
            return schema.try(...schemas[0]);
          }
        }
        return schema.try(...schemas);
      },
      validate(value, helpers) {
        const { schema, error, state, prefs } = helpers;
        if (schema._flags.match) {
          let hits = 0;
          let matched;
          for (let i = 0; i < schema.$_terms.matches.length; ++i) {
            const item = schema.$_terms.matches[i];
            const localState = state.nest(item.schema, `match.${i}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              ++hits;
              matched = result.value;
            } else {
              localState.restore();
            }
          }
          if (!hits) {
            return { errors: error("alternatives.any") };
          }
          if (schema._flags.match === "one") {
            return hits === 1 ? { value: matched } : { errors: error("alternatives.one") };
          }
          return hits === schema.$_terms.matches.length ? { value } : { errors: error("alternatives.all") };
        }
        const errors = [];
        for (let i = 0; i < schema.$_terms.matches.length; ++i) {
          const item = schema.$_terms.matches[i];
          if (item.schema) {
            const localState = state.nest(item.schema, `match.${i}`);
            localState.snapshot();
            const result = item.schema.$_validate(value, localState, prefs);
            if (!result.errors) {
              return result;
            }
            localState.restore();
            errors.push({ schema: item.schema, reports: result.errors });
            continue;
          }
          const input = item.ref ? item.ref.resolve(value, state, prefs) : value;
          const tests = item.is ? [item] : item.switch;
          for (let j = 0; j < tests.length; ++j) {
            const test = tests[j];
            const { is, then, otherwise } = test;
            const id = `match.${i}${item.switch ? "." + j : ""}`;
            if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {
              if (otherwise) {
                return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);
              }
            } else if (then) {
              return then.$_validate(value, state.nest(then, `${id}.then`), prefs);
            }
          }
        }
        return internals.errors(errors, helpers);
      },
      rules: {
        conditional: {
          method(condition, options) {
            Assert(!this._flags._endedSwitch, "Unreachable condition");
            Assert(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule");
            Assert(options.break === void 0, "Cannot use break option with alternatives conditional");
            const obj = this.clone();
            const match = Compile.when(obj, condition, options);
            const conditions = match.is ? [match] : match.switch;
            for (const item of conditions) {
              if (item.then && item.otherwise) {
                obj.$_setFlag("_endedSwitch", true, { clone: false });
                break;
              }
            }
            obj.$_terms.matches.push(match);
            return obj.$_mutateRebuild();
          }
        },
        match: {
          method(mode) {
            Assert(["any", "one", "all"].includes(mode), "Invalid alternatives match mode", mode);
            if (mode !== "any") {
              for (const match of this.$_terms.matches) {
                Assert(match.schema, "Cannot combine match mode", mode, "with conditional rules");
              }
            }
            return this.$_setFlag("match", mode);
          }
        },
        try: {
          method(...schemas) {
            Assert(schemas.length, "Missing alternative schemas");
            Common.verifyFlat(schemas, "try");
            Assert(!this._flags._endedSwitch, "Unreachable condition");
            const obj = this.clone();
            for (const schema of schemas) {
              obj.$_terms.matches.push({ schema: obj.$_compile(schema) });
            }
            return obj.$_mutateRebuild();
          }
        }
      },
      overrides: {
        label(name) {
          const obj = this.$_super.label(name);
          const each = (item, source) => source.path[0] !== "is" ? item.label(name) : void 0;
          return obj.$_modify({ each, ref: false });
        }
      },
      rebuild(schema) {
        const each = (item) => {
          if (Common.isSchema(item) && item.type === "array") {
            schema.$_setFlag("_arrayItems", true, { clone: false });
          }
        };
        schema.$_modify({ each });
      },
      manifest: {
        build(obj, desc) {
          if (desc.matches) {
            for (const match of desc.matches) {
              const { schema, ref, is, not, then, otherwise } = match;
              if (schema) {
                obj = obj.try(schema);
              } else if (ref) {
                obj = obj.conditional(ref, { is, then, not, otherwise, switch: match.switch });
              } else {
                obj = obj.conditional(is, { then, otherwise });
              }
            }
          }
          return obj;
        }
      },
      messages: {
        "alternatives.all": "{{#label}} does not match all of the required types",
        "alternatives.any": "{{#label}} does not match any of the allowed types",
        "alternatives.match": "{{#label}} does not match any of the allowed types",
        "alternatives.one": "{{#label}} matches more than one allowed type",
        "alternatives.types": "{{#label}} must be one of {{#types}}"
      }
    });
    internals.errors = function(failures, { error, state }) {
      if (!failures.length) {
        return { errors: error("alternatives.any") };
      }
      if (failures.length === 1) {
        return { errors: failures[0].reports };
      }
      const valids = /* @__PURE__ */ new Set();
      const complex = [];
      for (const { reports, schema } of failures) {
        if (reports.length > 1) {
          return internals.unmatched(failures, error);
        }
        const report = reports[0];
        if (report instanceof Errors.Report === false) {
          return internals.unmatched(failures, error);
        }
        if (report.state.path.length !== state.path.length) {
          complex.push({ type: schema.type, report });
          continue;
        }
        if (report.code === "any.only") {
          for (const valid of report.local.valids) {
            valids.add(valid);
          }
          continue;
        }
        const [type, code] = report.code.split(".");
        if (code !== "base") {
          complex.push({ type: schema.type, report });
          continue;
        }
        valids.add(type);
      }
      if (!complex.length) {
        return { errors: error("alternatives.types", { types: [...valids] }) };
      }
      if (complex.length === 1) {
        return { errors: complex[0].report };
      }
      return internals.unmatched(failures, error);
    };
    internals.unmatched = function(failures, error) {
      const errors = [];
      for (const failure of failures) {
        errors.push(...failure.reports);
      }
      return { errors: error("alternatives.match", Errors.details(errors, { override: false })) };
    };
  }
});

// node_modules/@hapi/joi/lib/types/array.js
var require_array2 = __commonJS({
  "node_modules/@hapi/joi/lib/types/array.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var DeepEqual = require_deepEqual();
    var Reach = require_reach();
    var Any = require_any2();
    var Common = require_common2();
    var Compile = require_compile2();
    var internals = {};
    module2.exports = Any.extend({
      type: "array",
      flags: {
        single: { default: false },
        sparse: { default: false }
      },
      terms: {
        items: { init: [], manifest: "schema" },
        ordered: { init: [], manifest: "schema" },
        _exclusions: { init: [] },
        _inclusions: { init: [] },
        _requireds: { init: [] }
      },
      coerce: {
        from: "object",
        method(value, { schema, state, prefs }) {
          if (!Array.isArray(value)) {
            return;
          }
          const sort = schema.$_getRule("sort");
          if (!sort) {
            return;
          }
          return internals.sort(schema, value, sort.args.options, state, prefs);
        }
      },
      validate(value, { schema, error }) {
        if (!Array.isArray(value)) {
          if (schema._flags.single) {
            const single = [value];
            single[Common.symbols.arraySingle] = true;
            return { value: single };
          }
          return { errors: error("array.base") };
        }
        if (!schema.$_getRule("items") && !schema.$_terms.externals) {
          return;
        }
        return { value: value.slice() };
      },
      rules: {
        has: {
          method(schema) {
            schema = this.$_compile(schema, { appendPath: true });
            const obj = this.$_addRule({ name: "has", args: { schema } });
            obj.$_mutateRegister(schema);
            return obj;
          },
          validate(value, { state, prefs, error }, { schema: has }) {
            const ancestors = [value, ...state.ancestors];
            for (let i = 0; i < value.length; ++i) {
              const localState = state.localize([...state.path, i], ancestors, has);
              if (has.$_match(value[i], localState, prefs)) {
                return value;
              }
            }
            const patternLabel = has._flags.label;
            if (patternLabel) {
              return error("array.hasKnown", { patternLabel });
            }
            return error("array.hasUnknown", null);
          },
          multi: true
        },
        items: {
          method(...schemas) {
            Common.verifyFlat(schemas, "items");
            const obj = this.$_addRule("items");
            for (let i = 0; i < schemas.length; ++i) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
              obj.$_terms.items.push(type);
            }
            return obj.$_mutateRebuild();
          },
          validate(value, { schema, error, state, prefs }) {
            const requireds = schema.$_terms._requireds.slice();
            const ordereds = schema.$_terms.ordered.slice();
            const inclusions = [...schema.$_terms._inclusions, ...requireds];
            const wasArray = !value[Common.symbols.arraySingle];
            delete value[Common.symbols.arraySingle];
            const errors = [];
            let il = value.length;
            for (let i = 0; i < il; ++i) {
              const item = value[i];
              let errored = false;
              let isValid = false;
              const key = wasArray ? i : new Number(i);
              const path = [...state.path, key];
              if (!schema._flags.sparse && item === void 0) {
                errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
                ordereds.shift();
                continue;
              }
              const ancestors = [value, ...state.ancestors];
              for (const exclusion of schema.$_terms._exclusions) {
                if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, { presence: "ignore" })) {
                  continue;
                }
                errors.push(error("array.excludes", { pos: i, value: item }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
                errored = true;
                ordereds.shift();
                break;
              }
              if (errored) {
                continue;
              }
              if (schema.$_terms.ordered.length) {
                if (ordereds.length) {
                  const ordered = ordereds.shift();
                  const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);
                  if (!res.errors) {
                    if (ordered._flags.result === "strip") {
                      internals.fastSplice(value, i);
                      --i;
                      --il;
                    } else if (!schema._flags.sparse && res.value === void 0) {
                      errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                      if (prefs.abortEarly) {
                        return errors;
                      }
                      continue;
                    } else {
                      value[i] = res.value;
                    }
                  } else {
                    errors.push(...res.errors);
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  continue;
                } else if (!schema.$_terms.items.length) {
                  errors.push(error("array.orderedLength", { pos: i, limit: schema.$_terms.ordered.length }));
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  break;
                }
              }
              const requiredChecks = [];
              let jl = requireds.length;
              for (let j = 0; j < jl; ++j) {
                const localState = state.localize(path, ancestors, requireds[j]);
                localState.snapshot();
                const res = requireds[j].$_validate(item, localState, prefs);
                requiredChecks[j] = res;
                if (!res.errors) {
                  value[i] = res.value;
                  isValid = true;
                  internals.fastSplice(requireds, j);
                  --j;
                  --jl;
                  if (!schema._flags.sparse && res.value === void 0) {
                    errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                    if (prefs.abortEarly) {
                      return errors;
                    }
                  }
                  break;
                }
                localState.restore();
              }
              if (isValid) {
                continue;
              }
              const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;
              jl = inclusions.length;
              for (const inclusion of inclusions) {
                let res;
                const previousCheck = requireds.indexOf(inclusion);
                if (previousCheck !== -1) {
                  res = requiredChecks[previousCheck];
                } else {
                  const localState = state.localize(path, ancestors, inclusion);
                  localState.snapshot();
                  res = inclusion.$_validate(item, localState, prefs);
                  if (!res.errors) {
                    if (inclusion._flags.result === "strip") {
                      internals.fastSplice(value, i);
                      --i;
                      --il;
                    } else if (!schema._flags.sparse && res.value === void 0) {
                      errors.push(error("array.sparse", { key, path, pos: i, value: void 0 }, state.localize(path)));
                      errored = true;
                    } else {
                      value[i] = res.value;
                    }
                    isValid = true;
                    break;
                  }
                  localState.restore();
                }
                if (jl === 1) {
                  if (stripUnknown) {
                    internals.fastSplice(value, i);
                    --i;
                    --il;
                    isValid = true;
                    break;
                  }
                  errors.push(...res.errors);
                  if (prefs.abortEarly) {
                    return errors;
                  }
                  errored = true;
                  break;
                }
              }
              if (errored) {
                continue;
              }
              if (schema.$_terms._inclusions.length && !isValid) {
                if (stripUnknown) {
                  internals.fastSplice(value, i);
                  --i;
                  --il;
                  continue;
                }
                errors.push(error("array.includes", { pos: i, value: item }, state.localize(path)));
                if (prefs.abortEarly) {
                  return errors;
                }
              }
            }
            if (requireds.length) {
              internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);
            }
            if (ordereds.length) {
              internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);
            }
            return errors.length ? errors : value;
          },
          priority: true,
          manifest: false
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("array." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        },
        ordered: {
          method(...schemas) {
            Common.verifyFlat(schemas, "ordered");
            const obj = this.$_addRule("items");
            for (let i = 0; i < schemas.length; ++i) {
              const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
              internals.validateSingle(type, obj);
              obj.$_mutateRegister(type);
              obj.$_terms.ordered.push(type);
            }
            return obj.$_mutateRebuild();
          }
        },
        single: {
          method(enabled) {
            const value = enabled === void 0 ? true : !!enabled;
            Assert(!value || !this._flags._arrayItems, "Cannot specify single rule when array has array items");
            return this.$_setFlag("single", value);
          }
        },
        sort: {
          method(options = {}) {
            Common.assertOptions(options, ["by", "order"]);
            const settings = {
              order: options.order || "ascending"
            };
            if (options.by) {
              settings.by = Compile.ref(options.by, { ancestor: 0 });
              Assert(!settings.by.ancestor, "Cannot sort by ancestor");
            }
            return this.$_addRule({ name: "sort", args: { options: settings } });
          },
          validate(value, { error, state, prefs, schema }, { options }) {
            const { value: sorted, errors } = internals.sort(schema, value, options, state, prefs);
            if (errors) {
              return errors;
            }
            for (let i = 0; i < value.length; ++i) {
              if (value[i] !== sorted[i]) {
                return error("array.sort", { order: options.order, by: options.by ? options.by.key : "value" });
              }
            }
            return value;
          },
          convert: true
        },
        sparse: {
          method(enabled) {
            const value = enabled === void 0 ? true : !!enabled;
            if (this._flags.sparse === value) {
              return this;
            }
            const obj = value ? this.clone() : this.$_addRule("items");
            return obj.$_setFlag("sparse", value, { clone: false });
          }
        },
        unique: {
          method(comparator, options = {}) {
            Assert(!comparator || typeof comparator === "function" || typeof comparator === "string", "comparator must be a function or a string");
            Common.assertOptions(options, ["ignoreUndefined", "separator"]);
            const rule = { name: "unique", args: { options, comparator } };
            if (comparator) {
              if (typeof comparator === "string") {
                const separator = Common.default(options.separator, ".");
                rule.path = separator ? comparator.split(separator) : [comparator];
              } else {
                rule.comparator = comparator;
              }
            }
            return this.$_addRule(rule);
          },
          validate(value, { state, error, schema }, { comparator: raw, options }, { comparator, path }) {
            const found = {
              string: /* @__PURE__ */ Object.create(null),
              number: /* @__PURE__ */ Object.create(null),
              undefined: /* @__PURE__ */ Object.create(null),
              boolean: /* @__PURE__ */ Object.create(null),
              object: /* @__PURE__ */ new Map(),
              function: /* @__PURE__ */ new Map(),
              custom: /* @__PURE__ */ new Map()
            };
            const compare = comparator || DeepEqual;
            const ignoreUndefined = options.ignoreUndefined;
            for (let i = 0; i < value.length; ++i) {
              const item = path ? Reach(value[i], path) : value[i];
              const records = comparator ? found.custom : found[typeof item];
              Assert(records, "Failed to find unique map container for type", typeof item);
              if (records instanceof Map) {
                const entries = records.entries();
                let current;
                while (!(current = entries.next()).done) {
                  if (compare(current.value[0], item)) {
                    const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                    const context = {
                      pos: i,
                      value: value[i],
                      dupePos: current.value[1],
                      dupeValue: value[current.value[1]]
                    };
                    if (path) {
                      context.path = raw;
                    }
                    return error("array.unique", context, localState);
                  }
                }
                records.set(item, i);
              } else {
                if ((!ignoreUndefined || item !== void 0) && records[item] !== void 0) {
                  const context = {
                    pos: i,
                    value: value[i],
                    dupePos: records[item],
                    dupeValue: value[records[item]]
                  };
                  if (path) {
                    context.path = raw;
                  }
                  const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                  return error("array.unique", context, localState);
                }
                records[item] = i;
              }
            }
            return value;
          },
          args: ["comparator", "options"],
          multi: true
        }
      },
      cast: {
        set: {
          from: Array.isArray,
          to(value, helpers) {
            return new Set(value);
          }
        }
      },
      rebuild(schema) {
        schema.$_terms._inclusions = [];
        schema.$_terms._exclusions = [];
        schema.$_terms._requireds = [];
        for (const type of schema.$_terms.items) {
          internals.validateSingle(type, schema);
          if (type._flags.presence === "required") {
            schema.$_terms._requireds.push(type);
          } else if (type._flags.presence === "forbidden") {
            schema.$_terms._exclusions.push(type);
          } else {
            schema.$_terms._inclusions.push(type);
          }
        }
        for (const type of schema.$_terms.ordered) {
          internals.validateSingle(type, schema);
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.items) {
            obj = obj.items(...desc.items);
          }
          if (desc.ordered) {
            obj = obj.ordered(...desc.ordered);
          }
          return obj;
        }
      },
      messages: {
        "array.base": "{{#label}} must be an array",
        "array.excludes": "{{#label}} contains an excluded value",
        "array.hasKnown": '{{#label}} does not contain at least one required match for type "{#patternLabel}"',
        "array.hasUnknown": "{{#label}} does not contain at least one required match",
        "array.includes": "{{#label}} does not match any of the allowed types",
        "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)",
        "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}",
        "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)",
        "array.length": "{{#label}} must contain {{#limit}} items",
        "array.max": "{{#label}} must contain less than or equal to {{#limit}} items",
        "array.min": "{{#label}} must contain at least {{#limit}} items",
        "array.orderedLength": "{{#label}} must contain at most {{#limit}} items",
        "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}",
        "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types",
        "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}",
        "array.sparse": "{{#label}} must not be a sparse array item",
        "array.unique": "{{#label}} contains a duplicate value"
      }
    });
    internals.fillMissedErrors = function(schema, errors, requireds, value, state, prefs) {
      const knownMisses = [];
      let unknownMisses = 0;
      for (const required of requireds) {
        const label = required._flags.label;
        if (label) {
          knownMisses.push(label);
        } else {
          ++unknownMisses;
        }
      }
      if (knownMisses.length) {
        if (unknownMisses) {
          errors.push(schema.$_createError("array.includesRequiredBoth", value, { knownMisses, unknownMisses }, state, prefs));
        } else {
          errors.push(schema.$_createError("array.includesRequiredKnowns", value, { knownMisses }, state, prefs));
        }
      } else {
        errors.push(schema.$_createError("array.includesRequiredUnknowns", value, { unknownMisses }, state, prefs));
      }
    };
    internals.fillOrderedErrors = function(schema, errors, ordereds, value, state, prefs) {
      const requiredOrdereds = [];
      for (const ordered of ordereds) {
        if (ordered._flags.presence === "required") {
          requiredOrdereds.push(ordered);
        }
      }
      if (requiredOrdereds.length) {
        internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);
      }
    };
    internals.fastSplice = function(arr, i) {
      let pos = i;
      while (pos < arr.length) {
        arr[pos++] = arr[pos];
      }
      --arr.length;
    };
    internals.validateSingle = function(type, obj) {
      if (type.type === "array" || type._flags._arrayItems) {
        Assert(!obj._flags.single, "Cannot specify array item with single rule enabled");
        obj.$_setFlag("_arrayItems", true, { clone: false });
      }
    };
    internals.sort = function(schema, value, settings, state, prefs) {
      const order = settings.order === "ascending" ? 1 : -1;
      const aFirst = -1 * order;
      const bFirst = order;
      const sort = (a, b) => {
        let compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        if (settings.by) {
          a = settings.by.resolve(a, state, prefs);
          b = settings.by.resolve(b, state, prefs);
        }
        compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
          return compare;
        }
        const type = typeof a;
        if (type !== typeof b) {
          throw schema.$_createError("array.sort.mismatching", value, null, state, prefs);
        }
        if (type !== "number" && type !== "string") {
          throw schema.$_createError("array.sort.unsupported", value, { type }, state, prefs);
        }
        if (type === "number") {
          return (a - b) * order;
        }
        return a < b ? aFirst : bFirst;
      };
      try {
        return { value: value.slice().sort(sort) };
      } catch (err) {
        return { errors: err };
      }
    };
    internals.compare = function(a, b, aFirst, bFirst) {
      if (a === b) {
        return 0;
      }
      if (a === void 0) {
        return 1;
      }
      if (b === void 0) {
        return -1;
      }
      if (a === null) {
        return bFirst;
      }
      if (b === null) {
        return aFirst;
      }
      return null;
    };
  }
});

// node_modules/@hapi/joi/lib/types/boolean.js
var require_boolean2 = __commonJS({
  "node_modules/@hapi/joi/lib/types/boolean.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any2();
    var Common = require_common2();
    var Values = require_values2();
    var internals = {};
    internals.isBool = function(value) {
      return typeof value === "boolean";
    };
    module2.exports = Any.extend({
      type: "boolean",
      flags: {
        sensitive: { default: false }
      },
      terms: {
        falsy: {
          init: null,
          manifest: "values"
        },
        truthy: {
          init: null,
          manifest: "values"
        }
      },
      coerce(value, { schema }) {
        if (typeof value === "boolean") {
          return;
        }
        if (typeof value === "string") {
          const normalized = schema._flags.sensitive ? value : value.toLowerCase();
          value = normalized === "true" ? true : normalized === "false" ? false : value;
        }
        if (typeof value !== "boolean") {
          value = schema.$_terms.truthy && schema.$_terms.truthy.has(value, null, null, !schema._flags.sensitive) || (schema.$_terms.falsy && schema.$_terms.falsy.has(value, null, null, !schema._flags.sensitive) ? false : value);
        }
        return { value };
      },
      validate(value, { error }) {
        if (typeof value !== "boolean") {
          return { value, errors: error("boolean.base") };
        }
      },
      rules: {
        truthy: {
          method(...values) {
            Common.verifyFlat(values, "truthy");
            const obj = this.clone();
            obj.$_terms.truthy = obj.$_terms.truthy || new Values();
            for (let i = 0; i < values.length; ++i) {
              const value = values[i];
              Assert(value !== void 0, "Cannot call truthy with undefined");
              obj.$_terms.truthy.add(value);
            }
            return obj;
          }
        },
        falsy: {
          method(...values) {
            Common.verifyFlat(values, "falsy");
            const obj = this.clone();
            obj.$_terms.falsy = obj.$_terms.falsy || new Values();
            for (let i = 0; i < values.length; ++i) {
              const value = values[i];
              Assert(value !== void 0, "Cannot call falsy with undefined");
              obj.$_terms.falsy.add(value);
            }
            return obj;
          }
        },
        sensitive: {
          method(enabled = true) {
            return this.$_setFlag("sensitive", enabled);
          }
        }
      },
      cast: {
        number: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? 1 : 0;
          }
        },
        string: {
          from: internals.isBool,
          to(value, helpers) {
            return value ? "true" : "false";
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.truthy) {
            obj = obj.truthy(...desc.truthy);
          }
          if (desc.falsy) {
            obj = obj.falsy(...desc.falsy);
          }
          return obj;
        }
      },
      messages: {
        "boolean.base": "{{#label}} must be a boolean"
      }
    });
  }
});

// node_modules/@hapi/joi/lib/types/date.js
var require_date2 = __commonJS({
  "node_modules/@hapi/joi/lib/types/date.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any2();
    var Common = require_common2();
    var Template = require_template2();
    var internals = {};
    internals.isDate = function(value) {
      return value instanceof Date;
    };
    module2.exports = Any.extend({
      type: "date",
      coerce: {
        from: ["number", "string"],
        method(value, { schema }) {
          return { value: internals.parse(value, schema._flags.format) || value };
        }
      },
      validate(value, { schema, error, prefs }) {
        if (value instanceof Date && !isNaN(value.getTime())) {
          return;
        }
        const format = schema._flags.format;
        if (!prefs.convert || !format || typeof value !== "string") {
          return { value, errors: error("date.base") };
        }
        return { value, errors: error("date.format", { format }) };
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { date }, { name, operator, args }) {
            const to = date === "now" ? Date.now() : date.getTime();
            if (Common.compare(value.getTime(), to, operator)) {
              return value;
            }
            return helpers.error("date." + name, { limit: args.date, value });
          },
          args: [
            {
              name: "date",
              ref: true,
              normalize: (date) => {
                return date === "now" ? date : internals.parse(date);
              },
              assert: (date) => date !== null,
              message: "must have a valid date format"
            }
          ]
        },
        format: {
          method(format) {
            Assert(["iso", "javascript", "unix"].includes(format), "Unknown date format", format);
            return this.$_setFlag("format", format);
          }
        },
        greater: {
          method(date) {
            return this.$_addRule({ name: "greater", method: "compare", args: { date }, operator: ">" });
          }
        },
        iso: {
          method() {
            return this.format("iso");
          }
        },
        less: {
          method(date) {
            return this.$_addRule({ name: "less", method: "compare", args: { date }, operator: "<" });
          }
        },
        max: {
          method(date) {
            return this.$_addRule({ name: "max", method: "compare", args: { date }, operator: "<=" });
          }
        },
        min: {
          method(date) {
            return this.$_addRule({ name: "min", method: "compare", args: { date }, operator: ">=" });
          }
        },
        timestamp: {
          method(type = "javascript") {
            Assert(["javascript", "unix"].includes(type), '"type" must be one of "javascript, unix"');
            return this.format(type);
          }
        }
      },
      cast: {
        number: {
          from: internals.isDate,
          to(value, helpers) {
            return value.getTime();
          }
        },
        string: {
          from: internals.isDate,
          to(value, { prefs }) {
            return Template.date(value, prefs);
          }
        }
      },
      messages: {
        "date.base": "{{#label}} must be a valid date",
        "date.format": '{{#label}} must be in {msg("date.format." + #format) || #format} format',
        "date.greater": '{{#label}} must be greater than "{{#limit}}"',
        "date.less": '{{#label}} must be less than "{{#limit}}"',
        "date.max": '{{#label}} must be less than or equal to "{{#limit}}"',
        "date.min": '{{#label}} must be larger than or equal to "{{#limit}}"',
        "date.format.iso": "ISO 8601 date",
        "date.format.javascript": "timestamp or number of milliseconds",
        "date.format.unix": "timestamp or number of seconds"
      }
    });
    internals.parse = function(value, format) {
      if (value instanceof Date) {
        return value;
      }
      if (typeof value !== "string" && (isNaN(value) || !isFinite(value))) {
        return null;
      }
      if (/^\s*$/.test(value)) {
        return null;
      }
      if (format === "iso") {
        if (!Common.isIsoDate(value)) {
          return null;
        }
        return internals.date(value.toString());
      }
      const original = value;
      if (typeof value === "string" && /^[+-]?\d+(\.\d+)?$/.test(value)) {
        value = parseFloat(value);
      }
      if (format) {
        if (format === "javascript") {
          return internals.date(1 * value);
        }
        if (format === "unix") {
          return internals.date(1e3 * value);
        }
        if (typeof original === "string") {
          return null;
        }
      }
      return internals.date(value);
    };
    internals.date = function(value) {
      const date = new Date(value);
      if (!isNaN(date.getTime())) {
        return date;
      }
      return null;
    };
  }
});

// node_modules/@hapi/joi/lib/types/keys.js
var require_keys2 = __commonJS({
  "node_modules/@hapi/joi/lib/types/keys.js"(exports, module2) {
    "use strict";
    var ApplyToDefaults = require_applyToDefaults();
    var Assert = require_assert();
    var Clone = require_clone();
    var Topo = require_lib2();
    var Any = require_any2();
    var Common = require_common2();
    var Compile = require_compile2();
    var Errors = require_errors2();
    var Ref = require_ref2();
    var Template = require_template2();
    var internals = {
      renameDefaults: {
        alias: false,
        multiple: false,
        override: false
      }
    };
    module2.exports = Any.extend({
      type: "_keys",
      properties: {
        typeof: "object"
      },
      flags: {
        unknown: { default: false }
      },
      terms: {
        dependencies: { init: null },
        keys: { init: null, manifest: { mapped: { from: "schema", to: "key" } } },
        patterns: { init: null },
        renames: { init: null }
      },
      args(schema, keys) {
        return schema.keys(keys);
      },
      validate(value, { schema, error, state, prefs }) {
        if (!value || typeof value !== schema.$_property("typeof") || Array.isArray(value)) {
          return { value, errors: error("object.base", { type: schema.$_property("typeof") }) };
        }
        if (!schema.$_terms.renames && !schema.$_terms.dependencies && !schema.$_terms.keys && !schema.$_terms.patterns && !schema.$_terms.externals) {
          return;
        }
        value = internals.clone(value, prefs);
        const errors = [];
        if (schema.$_terms.renames && !internals.rename(schema, value, state, prefs, errors)) {
          return { value, errors };
        }
        if (!schema.$_terms.keys && !schema.$_terms.patterns && !schema.$_terms.dependencies) {
          return { value, errors };
        }
        const unprocessed = new Set(Object.keys(value));
        if (schema.$_terms.keys) {
          const ancestors = [value, ...state.ancestors];
          for (const child of schema.$_terms.keys) {
            const key = child.key;
            const item = value[key];
            unprocessed.delete(key);
            const localState = state.localize([...state.path, key], ancestors, child);
            const result = child.schema.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return { value, errors: result.errors };
              }
              errors.push(...result.errors);
            } else if (child.schema._flags.result === "strip" || result.value === void 0 && item !== void 0) {
              delete value[key];
            } else if (result.value !== void 0) {
              value[key] = result.value;
            }
          }
        }
        if (unprocessed.size || schema._flags._hasPatternMatch) {
          const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);
          if (early) {
            return early;
          }
        }
        if (schema.$_terms.dependencies) {
          for (const dep of schema.$_terms.dependencies) {
            if (dep.key && dep.key.resolve(value, state, prefs, null, { shadow: false }) === void 0) {
              continue;
            }
            const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);
            if (failed) {
              const report = schema.$_createError(failed.code, value, failed.context, state, prefs);
              if (prefs.abortEarly) {
                return { value, errors: report };
              }
              errors.push(report);
            }
          }
        }
        return { value, errors };
      },
      rules: {
        and: {
          method(...peers) {
            Common.verifyFlat(peers, "and");
            return internals.dependency(this, "and", null, peers);
          }
        },
        append: {
          method(schema) {
            if (schema === null || schema === void 0 || Object.keys(schema).length === 0) {
              return this;
            }
            return this.keys(schema);
          }
        },
        assert: {
          method(subject, schema, message) {
            if (!Template.isTemplate(subject)) {
              subject = Compile.ref(subject);
            }
            Assert(message === void 0 || typeof message === "string", "Message must be a string");
            schema = this.$_compile(schema, { appendPath: true });
            const obj = this.$_addRule({ name: "assert", args: { subject, schema, message } });
            obj.$_mutateRegister(subject);
            obj.$_mutateRegister(schema);
            return obj;
          },
          validate(value, { error, prefs, state }, { subject, schema, message }) {
            const about = subject.resolve(value, state, prefs);
            const path = Ref.isRef(subject) ? subject.absolute(state) : [];
            if (schema.$_match(about, state.localize(path, [value, ...state.ancestors], schema), prefs)) {
              return value;
            }
            return error("object.assert", { subject, message });
          },
          args: ["subject", "schema", "message"],
          multi: true
        },
        instance: {
          method(constructor, name) {
            Assert(typeof constructor === "function", "constructor must be a function");
            name = name || constructor.name;
            return this.$_addRule({ name: "instance", args: { constructor, name } });
          },
          validate(value, helpers, { constructor, name }) {
            if (value instanceof constructor) {
              return value;
            }
            return helpers.error("object.instance", { type: name, value });
          },
          args: ["constructor", "name"]
        },
        keys: {
          method(schema) {
            Assert(schema === void 0 || typeof schema === "object", "Object schema must be a valid object");
            Assert(!Common.isSchema(schema), "Object schema cannot be a joi schema");
            const obj = this.clone();
            if (!schema) {
              obj.$_terms.keys = null;
            } else if (!Object.keys(schema).length) {
              obj.$_terms.keys = new internals.Keys();
            } else {
              obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : new internals.Keys();
              for (const key in schema) {
                Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema[key]) }), key);
              }
            }
            return obj.$_mutateRebuild();
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(Object.keys(value).length, limit, operator)) {
              return value;
            }
            return helpers.error("object." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        },
        nand: {
          method(...peers) {
            Common.verifyFlat(peers, "nand");
            return internals.dependency(this, "nand", null, peers);
          }
        },
        or: {
          method(...peers) {
            Common.verifyFlat(peers, "or");
            return internals.dependency(this, "or", null, peers);
          }
        },
        oxor: {
          method(...peers) {
            return internals.dependency(this, "oxor", null, peers);
          }
        },
        pattern: {
          method(pattern, schema, options = {}) {
            const isRegExp = pattern instanceof RegExp;
            if (!isRegExp) {
              pattern = this.$_compile(pattern, { appendPath: true });
            }
            Assert(schema !== void 0, "Invalid rule");
            Common.assertOptions(options, ["fallthrough", "matches"]);
            if (isRegExp) {
              Assert(!pattern.flags.includes("g") && !pattern.flags.includes("y"), "pattern should not use global or sticky mode");
            }
            schema = this.$_compile(schema, { appendPath: true });
            const obj = this.clone();
            obj.$_terms.patterns = obj.$_terms.patterns || [];
            const config = { [isRegExp ? "regex" : "schema"]: pattern, rule: schema };
            if (options.matches) {
              config.matches = this.$_compile(options.matches);
              if (config.matches.type !== "array") {
                config.matches = config.matches.$_root.array().items(config.matches);
              }
              obj.$_mutateRegister(config.matches);
              obj.$_setFlag("_hasPatternMatch", true, { clone: false });
            }
            if (options.fallthrough) {
              config.fallthrough = true;
            }
            obj.$_terms.patterns.push(config);
            obj.$_mutateRegister(schema);
            return obj;
          }
        },
        ref: {
          method() {
            return this.$_addRule("ref");
          },
          validate(value, helpers) {
            if (Ref.isRef(value)) {
              return value;
            }
            return helpers.error("object.refType", { value });
          }
        },
        regex: {
          method() {
            return this.$_addRule("regex");
          },
          validate(value, helpers) {
            if (value instanceof RegExp) {
              return value;
            }
            return helpers.error("object.regex", { value });
          }
        },
        rename: {
          method(from, to, options = {}) {
            Assert(typeof from === "string" || from instanceof RegExp, "Rename missing the from argument");
            Assert(typeof to === "string" || to instanceof Template, "Invalid rename to argument");
            Assert(to !== from, "Cannot rename key to same name:", from);
            Common.assertOptions(options, ["alias", "ignoreUndefined", "override", "multiple"]);
            const obj = this.clone();
            obj.$_terms.renames = obj.$_terms.renames || [];
            for (const rename of obj.$_terms.renames) {
              Assert(rename.from !== from, "Cannot rename the same key multiple times");
            }
            if (to instanceof Template) {
              obj.$_mutateRegister(to);
            }
            obj.$_terms.renames.push({
              from,
              to,
              options: ApplyToDefaults(internals.renameDefaults, options)
            });
            return obj;
          }
        },
        schema: {
          method(type = "any") {
            return this.$_addRule({ name: "schema", args: { type } });
          },
          validate(value, helpers, { type }) {
            if (Common.isSchema(value) && (type === "any" || value.type === type)) {
              return value;
            }
            return helpers.error("object.schema", { type });
          }
        },
        unknown: {
          method(allow) {
            return this.$_setFlag("unknown", allow !== false);
          }
        },
        with: {
          method(key, peers, options = {}) {
            return internals.dependency(this, "with", key, peers, options);
          }
        },
        without: {
          method(key, peers, options = {}) {
            return internals.dependency(this, "without", key, peers, options);
          }
        },
        xor: {
          method(...peers) {
            Common.verifyFlat(peers, "xor");
            return internals.dependency(this, "xor", null, peers);
          }
        }
      },
      overrides: {
        default(value, options) {
          if (value === void 0) {
            value = Common.symbols.deepDefault;
          }
          return this.$_super.default(value, options);
        }
      },
      rebuild(schema) {
        if (schema.$_terms.keys) {
          const topo = new Topo.Sorter();
          for (const child of schema.$_terms.keys) {
            Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);
          }
          schema.$_terms.keys = new internals.Keys(...topo.nodes);
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.keys) {
            obj = obj.keys(desc.keys);
          }
          if (desc.dependencies) {
            for (const { rel, key = null, peers, options } of desc.dependencies) {
              obj = internals.dependency(obj, rel, key, peers, options);
            }
          }
          if (desc.patterns) {
            for (const { regex, schema, rule, fallthrough, matches } of desc.patterns) {
              obj = obj.pattern(regex || schema, rule, { fallthrough, matches });
            }
          }
          if (desc.renames) {
            for (const { from, to, options } of desc.renames) {
              obj = obj.rename(from, to, options);
            }
          }
          return obj;
        }
      },
      messages: {
        "object.and": "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}",
        "object.assert": '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
        "object.base": "{{#label}} must be of type {{#type}}",
        "object.instance": '{{#label}} must be an instance of "{{#type}}"',
        "object.length": '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.max": '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.min": '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
        "object.missing": "{{#label}} must contain at least one of {{#peersWithLabels}}",
        "object.nand": '"{{#mainWithLabel}}" must not exist simultaneously with {{#peersWithLabels}}',
        "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}",
        "object.pattern.match": "{{#label}} keys failed to match pattern requirements",
        "object.refType": "{{#label}} must be a Joi reference",
        "object.regex": "{{#label}} must be a RegExp object",
        "object.rename.multiple": '{{#label}} cannot rename "{{#from}}" because multiple renames are disabled and another key was already renamed to "{{#to}}"',
        "object.rename.override": '{{#label}} cannot rename "{{#from}}" because override is disabled and target "{{#to}}" exists',
        "object.schema": "{{#label}} must be a Joi schema of {{#type}} type",
        "object.unknown": "{{#label}} is not allowed",
        "object.with": '"{{#mainWithLabel}}" missing required peer "{{#peerWithLabel}}"',
        "object.without": '"{{#mainWithLabel}}" conflict with forbidden peer "{{#peerWithLabel}}"',
        "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"
      }
    });
    internals.clone = function(value, prefs) {
      if (typeof value === "object") {
        if (prefs.nonEnumerables) {
          return Clone(value, { shallow: true });
        }
        const clone2 = Object.create(Object.getPrototypeOf(value));
        Object.assign(clone2, value);
        return clone2;
      }
      const clone = function(...args) {
        return value.apply(this, args);
      };
      clone.prototype = Clone(value.prototype);
      Object.defineProperty(clone, "name", { value: value.name, writable: false });
      Object.defineProperty(clone, "length", { value: value.length, writable: false });
      Object.assign(clone, value);
      return clone;
    };
    internals.dependency = function(schema, rel, key, peers, options) {
      Assert(key === null || typeof key === "string", rel, "key must be a strings");
      if (!options) {
        options = peers.length > 1 && typeof peers[peers.length - 1] === "object" ? peers.pop() : {};
      }
      Common.assertOptions(options, ["separator"]);
      peers = [].concat(peers);
      const separator = Common.default(options.separator, ".");
      const paths = [];
      for (const peer of peers) {
        Assert(typeof peer === "string", rel, "peers must be a string or a reference");
        paths.push(Compile.ref(peer, { separator, ancestor: 0, prefix: false }));
      }
      if (key !== null) {
        key = Compile.ref(key, { separator, ancestor: 0, prefix: false });
      }
      const obj = schema.clone();
      obj.$_terms.dependencies = obj.$_terms.dependencies || [];
      obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers));
      return obj;
    };
    internals.dependencies = {
      and(schema, dep, value, state, prefs) {
        const missing = [];
        const present = [];
        const count = dep.peers.length;
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) === void 0) {
            missing.push(peer.key);
          } else {
            present.push(peer.key);
          }
        }
        if (missing.length !== count && present.length !== count) {
          return {
            code: "object.and",
            context: {
              present,
              presentWithLabels: internals.keysToLabels(schema, present),
              missing,
              missingWithLabels: internals.keysToLabels(schema, missing)
            }
          };
        }
      },
      nand(schema, dep, value, state, prefs) {
        const present = [];
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) !== void 0) {
            present.push(peer.key);
          }
        }
        if (present.length !== dep.peers.length) {
          return;
        }
        const main = dep.paths[0];
        const values = dep.paths.slice(1);
        return {
          code: "object.nand",
          context: {
            main,
            mainWithLabel: internals.keysToLabels(schema, main),
            peers: values,
            peersWithLabels: internals.keysToLabels(schema, values)
          }
        };
      },
      or(schema, dep, value, state, prefs) {
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) !== void 0) {
            return;
          }
        }
        return {
          code: "object.missing",
          context: {
            peers: dep.paths,
            peersWithLabels: internals.keysToLabels(schema, dep.paths)
          }
        };
      },
      oxor(schema, dep, value, state, prefs) {
        const present = [];
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) !== void 0) {
            present.push(peer.key);
          }
        }
        if (!present.length || present.length === 1) {
          return;
        }
        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema, present);
        return { code: "object.oxor", context };
      },
      with(schema, dep, value, state, prefs) {
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) === void 0) {
            return {
              code: "object.with",
              context: {
                main: dep.key.key,
                mainWithLabel: internals.keysToLabels(schema, dep.key.key),
                peer: peer.key,
                peerWithLabel: internals.keysToLabels(schema, peer.key)
              }
            };
          }
        }
      },
      without(schema, dep, value, state, prefs) {
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) !== void 0) {
            return {
              code: "object.without",
              context: {
                main: dep.key.key,
                mainWithLabel: internals.keysToLabels(schema, dep.key.key),
                peer: peer.key,
                peerWithLabel: internals.keysToLabels(schema, peer.key)
              }
            };
          }
        }
      },
      xor(schema, dep, value, state, prefs) {
        const present = [];
        for (const peer of dep.peers) {
          if (peer.resolve(value, state, prefs, null, { shadow: false }) !== void 0) {
            present.push(peer.key);
          }
        }
        if (present.length === 1) {
          return;
        }
        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
        if (present.length === 0) {
          return { code: "object.missing", context };
        }
        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema, present);
        return { code: "object.xor", context };
      }
    };
    internals.keysToLabels = function(schema, keys) {
      if (Array.isArray(keys)) {
        return keys.map((key) => schema.$_mapLabels(key));
      }
      return schema.$_mapLabels(keys);
    };
    internals.rename = function(schema, value, state, prefs, errors) {
      const renamed = {};
      for (const rename of schema.$_terms.renames) {
        const matches = [];
        const pattern = typeof rename.from !== "string";
        if (!pattern) {
          if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== void 0 || !rename.options.ignoreUndefined)) {
            matches.push(rename);
          }
        } else {
          for (const from in value) {
            if (value[from] === void 0 && rename.options.ignoreUndefined) {
              continue;
            }
            if (from === rename.to) {
              continue;
            }
            const match = rename.from.exec(from);
            if (!match) {
              continue;
            }
            matches.push({ from, to: rename.to, match });
          }
        }
        for (const match of matches) {
          const from = match.from;
          let to = match.to;
          if (to instanceof Template) {
            to = to.render(value, state, prefs, match.match);
          }
          if (from === to) {
            continue;
          }
          if (!rename.options.multiple && renamed[to]) {
            errors.push(schema.$_createError("object.rename.multiple", value, { from, to, pattern }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {
            errors.push(schema.$_createError("object.rename.override", value, { from, to, pattern }, state, prefs));
            if (prefs.abortEarly) {
              return false;
            }
          }
          if (value[from] === void 0) {
            delete value[to];
          } else {
            value[to] = value[from];
          }
          renamed[to] = true;
          if (!rename.options.alias) {
            delete value[from];
          }
        }
      }
      return true;
    };
    internals.unknown = function(schema, value, unprocessed, errors, state, prefs) {
      if (schema.$_terms.patterns) {
        let hasMatches = false;
        const matches = schema.$_terms.patterns.map((pattern) => {
          if (pattern.matches) {
            hasMatches = true;
            return [];
          }
        });
        const ancestors = [value, ...state.ancestors];
        for (const key of unprocessed) {
          const item = value[key];
          const path = [...state.path, key];
          for (let i = 0; i < schema.$_terms.patterns.length; ++i) {
            const pattern = schema.$_terms.patterns[i];
            if (pattern.regex) {
              const match = pattern.regex.test(key);
              state.mainstay.tracer.debug(state, "rule", `pattern.${i}`, match ? "pass" : "error");
              if (!match) {
                continue;
              }
            } else {
              if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {
                continue;
              }
            }
            unprocessed.delete(key);
            const localState = state.localize(path, ancestors, { schema: pattern.rule, key });
            const result = pattern.rule.$_validate(item, localState, prefs);
            if (result.errors) {
              if (prefs.abortEarly) {
                return { value, errors: result.errors };
              }
              errors.push(...result.errors);
            }
            if (pattern.matches) {
              matches[i].push(key);
            }
            value[key] = result.value;
            if (!pattern.fallthrough) {
              break;
            }
          }
        }
        if (hasMatches) {
          for (let i = 0; i < matches.length; ++i) {
            const match = matches[i];
            if (!match) {
              continue;
            }
            const stpm = schema.$_terms.patterns[i].matches;
            const localState = state.localize(state.path, ancestors, stpm);
            const result = stpm.$_validate(match, localState, prefs);
            if (result.errors) {
              const details = Errors.details(result.errors, { override: false });
              details.matches = match;
              const report = schema.$_createError("object.pattern.match", value, details, state, prefs);
              if (prefs.abortEarly) {
                return { value, errors: report };
              }
              errors.push(report);
            }
          }
        }
      }
      if (!unprocessed.size || !schema.$_terms.keys && !schema.$_terms.patterns) {
        return;
      }
      if (prefs.stripUnknown && !schema._flags.unknown || prefs.skipFunctions) {
        const stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;
        for (const key of unprocessed) {
          if (stripUnknown) {
            delete value[key];
            unprocessed.delete(key);
          } else if (typeof value[key] === "function") {
            unprocessed.delete(key);
          }
        }
      }
      const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);
      if (forbidUnknown) {
        for (const unprocessedKey of unprocessed) {
          const localState = state.localize([...state.path, unprocessedKey], []);
          const report = schema.$_createError("object.unknown", value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });
          if (prefs.abortEarly) {
            return { value, errors: report };
          }
          errors.push(report);
        }
      }
    };
    internals.Dependency = class {
      constructor(rel, key, peers, paths) {
        this.rel = rel;
        this.key = key;
        this.peers = peers;
        this.paths = paths;
      }
      describe() {
        const desc = {
          rel: this.rel,
          peers: this.paths
        };
        if (this.key !== null) {
          desc.key = this.key.key;
        }
        if (this.peers[0].separator !== ".") {
          desc.options = { separator: this.peers[0].separator };
        }
        return desc;
      }
    };
    internals.Keys = class extends Array {
      concat(source) {
        const result = this.slice();
        const keys = /* @__PURE__ */ new Map();
        for (let i = 0; i < result.length; ++i) {
          keys.set(result[i].key, i);
        }
        for (const item of source) {
          const key = item.key;
          const pos = keys.get(key);
          if (pos !== void 0) {
            result[pos] = { key, schema: result[pos].schema.concat(item.schema) };
          } else {
            result.push(item);
          }
        }
        return result;
      }
    };
  }
});

// node_modules/@hapi/joi/lib/types/function.js
var require_function2 = __commonJS({
  "node_modules/@hapi/joi/lib/types/function.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Keys = require_keys2();
    module2.exports = Keys.extend({
      type: "function",
      properties: {
        typeof: "function"
      },
      rules: {
        arity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({ name: "arity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length === n) {
              return value;
            }
            return helpers.error("function.arity", { n });
          }
        },
        class: {
          method() {
            return this.$_addRule("class");
          },
          validate(value, helpers) {
            if (/^\s*class\s/.test(value.toString())) {
              return value;
            }
            return helpers.error("function.class", { value });
          }
        },
        minArity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n > 0, "n must be a strict positive integer");
            return this.$_addRule({ name: "minArity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length >= n) {
              return value;
            }
            return helpers.error("function.minArity", { n });
          }
        },
        maxArity: {
          method(n) {
            Assert(Number.isSafeInteger(n) && n >= 0, "n must be a positive integer");
            return this.$_addRule({ name: "maxArity", args: { n } });
          },
          validate(value, helpers, { n }) {
            if (value.length <= n) {
              return value;
            }
            return helpers.error("function.maxArity", { n });
          }
        }
      },
      messages: {
        "function.arity": "{{#label}} must have an arity of {{#n}}",
        "function.class": "{{#label}} must be a class",
        "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}",
        "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}"
      }
    });
  }
});

// node_modules/@hapi/joi/lib/types/link.js
var require_link2 = __commonJS({
  "node_modules/@hapi/joi/lib/types/link.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any2();
    var Common = require_common2();
    var Compile = require_compile2();
    var Errors = require_errors2();
    var internals = {};
    module2.exports = Any.extend({
      type: "link",
      properties: {
        schemaChain: true
      },
      terms: {
        link: { init: null, manifest: "single", register: false }
      },
      args(schema, ref) {
        return schema.ref(ref);
      },
      validate(value, { schema, state, prefs }) {
        Assert(schema.$_terms.link, "Uninitialized link schema");
        const linked = internals.generate(schema, value, state, prefs);
        const ref = schema.$_terms.link[0].ref;
        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);
      },
      generate(schema, value, state, prefs) {
        return internals.generate(schema, value, state, prefs);
      },
      rules: {
        ref: {
          method(ref) {
            Assert(!this.$_terms.link, "Cannot reinitialize schema");
            ref = Compile.ref(ref);
            Assert(ref.type === "value" || ref.type === "local", "Invalid reference type:", ref.type);
            Assert(ref.type === "local" || ref.ancestor === "root" || ref.ancestor > 0, "Link cannot reference itself");
            const obj = this.clone();
            obj.$_terms.link = [{ ref }];
            return obj;
          }
        },
        relative: {
          method(enabled = true) {
            return this.$_setFlag("relative", enabled);
          }
        }
      },
      overrides: {
        concat(source) {
          Assert(this.$_terms.link, "Uninitialized link schema");
          Assert(Common.isSchema(source), "Invalid schema object");
          Assert(source.type !== "link", "Cannot merge type link with another link");
          const obj = this.clone();
          if (!obj.$_terms.whens) {
            obj.$_terms.whens = [];
          }
          obj.$_terms.whens.push({ concat: source });
          return obj.$_mutateRebuild();
        }
      },
      manifest: {
        build(obj, desc) {
          Assert(desc.link, "Invalid link description missing link");
          return obj.ref(desc.link);
        }
      }
    });
    internals.generate = function(schema, value, state, prefs) {
      let linked = state.mainstay.links.get(schema);
      if (linked) {
        return linked._generate(value, state, prefs).schema;
      }
      const ref = schema.$_terms.link[0].ref;
      const { perspective, path } = internals.perspective(ref, state);
      internals.assert(perspective, "which is outside of schema boundaries", ref, schema, state, prefs);
      try {
        linked = path.length ? perspective.$_reach(path) : perspective;
      } catch (ignoreErr) {
        internals.assert(false, "to non-existing schema", ref, schema, state, prefs);
      }
      internals.assert(linked.type !== "link", "which is another link", ref, schema, state, prefs);
      if (!schema._flags.relative) {
        state.mainstay.links.set(schema, linked);
      }
      return linked._generate(value, state, prefs).schema;
    };
    internals.perspective = function(ref, state) {
      if (ref.type === "local") {
        for (const { schema, key } of state.schemas) {
          const id = schema._flags.id || key;
          if (id === ref.path[0]) {
            return { perspective: schema, path: ref.path.slice(1) };
          }
          if (schema.$_terms.shared) {
            for (const shared of schema.$_terms.shared) {
              if (shared._flags.id === ref.path[0]) {
                return { perspective: shared, path: ref.path.slice(1) };
              }
            }
          }
        }
        return { perspective: null, path: null };
      }
      if (ref.ancestor === "root") {
        return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };
      }
      return { perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema, path: ref.path };
    };
    internals.assert = function(condition, message, ref, schema, state, prefs) {
      if (condition) {
        return;
      }
      Assert(false, `"${Errors.label(schema._flags, state, prefs)}" contains link reference "${ref.display}" ${message}`);
    };
  }
});

// node_modules/@hapi/joi/lib/types/number.js
var require_number2 = __commonJS({
  "node_modules/@hapi/joi/lib/types/number.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any2();
    var Common = require_common2();
    var internals = {
      numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
      precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/
    };
    module2.exports = Any.extend({
      type: "number",
      flags: {
        unsafe: { default: false }
      },
      coerce: {
        from: "string",
        method(value, { schema, error }) {
          const matches = value.match(internals.numberRx);
          if (!matches) {
            return;
          }
          value = value.trim();
          const result = { value: parseFloat(value) };
          if (result.value === 0) {
            result.value = 0;
          }
          if (!schema._flags.unsafe) {
            if (value.match(/e/i)) {
              const constructed = internals.normalizeExponent(`${result.value / Math.pow(10, matches[1])}e${matches[1]}`);
              if (constructed !== internals.normalizeExponent(value)) {
                result.errors = error("number.unsafe");
                return result;
              }
            } else {
              const string = result.value.toString();
              if (string.match(/e/i)) {
                return result;
              }
              if (string !== internals.normalizeDecimal(value)) {
                result.errors = error("number.unsafe");
                return result;
              }
            }
          }
          return result;
        }
      },
      validate(value, { schema, error, prefs }) {
        if (value === Infinity || value === -Infinity) {
          return { value, errors: error("number.infinity") };
        }
        if (!Common.isNumber(value)) {
          return { value, errors: error("number.base") };
        }
        const result = { value };
        if (prefs.convert) {
          const rule = schema.$_getRule("precision");
          if (rule) {
            const precision = Math.pow(10, rule.args.limit);
            result.value = Math.round(result.value * precision) / precision;
          }
        }
        if (result.value === 0) {
          result.value = 0;
        }
        if (!schema._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
          result.errors = error("number.unsafe");
        }
        return result;
      },
      rules: {
        compare: {
          method: false,
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value, limit, operator)) {
              return value;
            }
            return helpers.error("number." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.isNumber,
              message: "must be a number"
            }
          ]
        },
        greater: {
          method(limit) {
            return this.$_addRule({ name: "greater", method: "compare", args: { limit }, operator: ">" });
          }
        },
        integer: {
          method() {
            return this.$_addRule("integer");
          },
          validate(value, helpers) {
            if (Math.trunc(value) - value === 0) {
              return value;
            }
            return helpers.error("number.integer");
          }
        },
        less: {
          method(limit) {
            return this.$_addRule({ name: "less", method: "compare", args: { limit }, operator: "<" });
          }
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "compare", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "compare", args: { limit }, operator: ">=" });
          }
        },
        multiple: {
          method(base) {
            return this.$_addRule({ name: "multiple", args: { base } });
          },
          validate(value, helpers, { base }, options) {
            if (value % base === 0) {
              return value;
            }
            return helpers.error("number.multiple", { multiple: options.args.base, value });
          },
          args: [
            {
              name: "base",
              ref: true,
              assert: (value) => typeof value === "number" && isFinite(value) && value > 0,
              message: "must be a positive number"
            }
          ],
          multi: true
        },
        negative: {
          method() {
            return this.sign("negative");
          }
        },
        port: {
          method() {
            return this.$_addRule("port");
          },
          validate(value, helpers) {
            if (Number.isSafeInteger(value) && value >= 0 && value <= 65535) {
              return value;
            }
            return helpers.error("number.port");
          }
        },
        positive: {
          method() {
            return this.sign("positive");
          }
        },
        precision: {
          method(limit) {
            Assert(Number.isSafeInteger(limit), "limit must be an integer");
            return this.$_addRule({ name: "precision", args: { limit } });
          },
          validate(value, helpers, { limit }) {
            const places = value.toString().match(internals.precisionRx);
            const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
            if (decimals <= limit) {
              return value;
            }
            return helpers.error("number.precision", { limit, value });
          },
          convert: true
        },
        sign: {
          method(sign) {
            Assert(["negative", "positive"].includes(sign), "Invalid sign", sign);
            return this.$_addRule({ name: "sign", args: { sign } });
          },
          validate(value, helpers, { sign }) {
            if (sign === "negative" && value < 0 || sign === "positive" && value > 0) {
              return value;
            }
            return helpers.error(`number.${sign}`);
          }
        },
        unsafe: {
          method(enabled = true) {
            Assert(typeof enabled === "boolean", "enabled must be a boolean");
            return this.$_setFlag("unsafe", enabled);
          }
        }
      },
      cast: {
        string: {
          from: (value) => typeof value === "number",
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "number.base": "{{#label}} must be a number",
        "number.greater": "{{#label}} must be greater than {{#limit}}",
        "number.infinity": "{{#label}} cannot be infinity",
        "number.integer": "{{#label}} must be an integer",
        "number.less": "{{#label}} must be less than {{#limit}}",
        "number.max": "{{#label}} must be less than or equal to {{#limit}}",
        "number.min": "{{#label}} must be larger than or equal to {{#limit}}",
        "number.multiple": "{{#label}} must be a multiple of {{#multiple}}",
        "number.negative": "{{#label}} must be a negative number",
        "number.port": "{{#label}} must be a valid port",
        "number.positive": "{{#label}} must be a positive number",
        "number.precision": "{{#label}} must have no more than {{#limit}} decimal places",
        "number.unsafe": "{{#label}} must be a safe number"
      }
    });
    internals.normalizeExponent = function(str) {
      return str.replace(/E/, "e").replace(/\.(\d*[1-9])?0+e/, ".$1e").replace(/\.e/, "e").replace(/e\+/, "e").replace(/^\+/, "").replace(/^(-?)0+([1-9])/, "$1$2");
    };
    internals.normalizeDecimal = function(str) {
      str = str.replace(/^\+/, "").replace(/\.0+$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([1-9])/, "$1$2");
      if (str.includes(".") && str.endsWith("0")) {
        str = str.replace(/0+$/, "");
      }
      if (str === "-0") {
        return "0";
      }
      return str;
    };
  }
});

// node_modules/@hapi/joi/lib/types/object.js
var require_object2 = __commonJS({
  "node_modules/@hapi/joi/lib/types/object.js"(exports, module2) {
    "use strict";
    var Keys = require_keys2();
    module2.exports = Keys.extend({
      type: "object",
      cast: {
        map: {
          from: (value) => value && typeof value === "object",
          to(value, helpers) {
            return new Map(Object.entries(value));
          }
        }
      }
    });
  }
});

// node_modules/@hapi/address/lib/errors.js
var require_errors3 = __commonJS({
  "node_modules/@hapi/address/lib/errors.js"(exports) {
    "use strict";
    exports.codes = {
      EMPTY_STRING: "Address must be a non-empty string",
      FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters",
      MULTIPLE_AT_CHAR: "Address cannot contain more than one @ character",
      MISSING_AT_CHAR: "Address must contain one @ character",
      EMPTY_LOCAL: "Address local part cannot be empty",
      ADDRESS_TOO_LONG: "Address too long",
      LOCAL_TOO_LONG: "Address local part too long",
      EMPTY_LOCAL_SEGMENT: "Address local part contains empty dot-separated segment",
      INVALID_LOCAL_CHARS: "Address local part contains invalid character",
      DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string",
      DOMAIN_TOO_LONG: "Domain too long",
      DOMAIN_INVALID_UNICODE_CHARS: "Domain contains forbidden Unicode characters",
      DOMAIN_INVALID_CHARS: "Domain contains invalid character",
      DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character",
      DOMAIN_SEGMENTS_COUNT: "Domain lacks the minimum required number of segments",
      DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments",
      DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD",
      DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment",
      DOMAIN_LONG_SEGMENT: "Domain contains dot-separated segment that is too long"
    };
    exports.code = function(code) {
      return { code, error: exports.codes[code] };
    };
  }
});

// node_modules/@hapi/address/lib/domain.js
var require_domain = __commonJS({
  "node_modules/@hapi/address/lib/domain.js"(exports) {
    "use strict";
    var Url = require("url");
    var Errors = require_errors3();
    var internals = {
      minDomainSegments: 2,
      nonAsciiRx: /[^\x00-\x7f]/,
      domainControlRx: /[\x00-\x20@\:\/]/,
      tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
      domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
      URL: Url.URL || URL
    };
    exports.analyze = function(domain, options = {}) {
      if (typeof domain !== "string") {
        throw new Error("Invalid input: domain must be a string");
      }
      if (!domain) {
        return Errors.code("DOMAIN_NON_EMPTY_STRING");
      }
      if (domain.length > 256) {
        return Errors.code("DOMAIN_TOO_LONG");
      }
      const ascii = !internals.nonAsciiRx.test(domain);
      if (!ascii) {
        if (options.allowUnicode === false) {
          return Errors.code("DOMAIN_INVALID_UNICODE_CHARS");
        }
        domain = domain.normalize("NFC");
      }
      if (internals.domainControlRx.test(domain)) {
        return Errors.code("DOMAIN_INVALID_CHARS");
      }
      domain = internals.punycode(domain);
      const minDomainSegments = options.minDomainSegments || internals.minDomainSegments;
      const segments = domain.split(".");
      if (segments.length < minDomainSegments) {
        return Errors.code("DOMAIN_SEGMENTS_COUNT");
      }
      if (options.maxDomainSegments) {
        if (segments.length > options.maxDomainSegments) {
          return Errors.code("DOMAIN_SEGMENTS_COUNT_MAX");
        }
      }
      const tlds = options.tlds;
      if (tlds) {
        const tld = segments[segments.length - 1].toLowerCase();
        if (tlds.deny && tlds.deny.has(tld) || tlds.allow && !tlds.allow.has(tld)) {
          return Errors.code("DOMAIN_FORBIDDEN_TLDS");
        }
      }
      for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];
        if (!segment.length) {
          return Errors.code("DOMAIN_EMPTY_SEGMENT");
        }
        if (segment.length > 63) {
          return Errors.code("DOMAIN_LONG_SEGMENT");
        }
        if (i < segments.length - 1) {
          if (!internals.domainSegmentRx.test(segment)) {
            return Errors.code("DOMAIN_INVALID_CHARS");
          }
        } else {
          if (!internals.tldSegmentRx.test(segment)) {
            return Errors.code("DOMAIN_INVALID_TLDS_CHARS");
          }
        }
      }
      return null;
    };
    exports.isValid = function(domain, options) {
      return !exports.analyze(domain, options);
    };
    internals.punycode = function(domain) {
      try {
        return new internals.URL(`http://${domain}`).host;
      } catch (err) {
        return domain;
      }
    };
  }
});

// node_modules/@hapi/address/lib/email.js
var require_email = __commonJS({
  "node_modules/@hapi/address/lib/email.js"(exports) {
    "use strict";
    var Util = require("util");
    var Domain = require_domain();
    var Errors = require_errors3();
    var internals = {
      nonAsciiRx: /[^\x00-\x7f]/,
      encoder: new (Util.TextEncoder || TextEncoder)()
    };
    exports.analyze = function(email, options) {
      return internals.email(email, options);
    };
    exports.isValid = function(email, options) {
      return !internals.email(email, options);
    };
    internals.email = function(email, options = {}) {
      if (typeof email !== "string") {
        throw new Error("Invalid input: email must be a string");
      }
      if (!email) {
        return Errors.code("EMPTY_STRING");
      }
      const ascii = !internals.nonAsciiRx.test(email);
      if (!ascii) {
        if (options.allowUnicode === false) {
          return Errors.code("FORBIDDEN_UNICODE");
        }
        email = email.normalize("NFC");
      }
      const parts = email.split("@");
      if (parts.length !== 2) {
        return parts.length > 2 ? Errors.code("MULTIPLE_AT_CHAR") : Errors.code("MISSING_AT_CHAR");
      }
      const [local2, domain] = parts;
      if (!local2) {
        return Errors.code("EMPTY_LOCAL");
      }
      if (!options.ignoreLength) {
        if (email.length > 254) {
          return Errors.code("ADDRESS_TOO_LONG");
        }
        if (internals.encoder.encode(local2).length > 64) {
          return Errors.code("LOCAL_TOO_LONG");
        }
      }
      return internals.local(local2, ascii) || Domain.analyze(domain, options);
    };
    internals.local = function(local2, ascii) {
      const segments = local2.split(".");
      for (const segment of segments) {
        if (!segment.length) {
          return Errors.code("EMPTY_LOCAL_SEGMENT");
        }
        if (ascii) {
          if (!internals.atextRx.test(segment)) {
            return Errors.code("INVALID_LOCAL_CHARS");
          }
          continue;
        }
        for (const char of segment) {
          if (internals.atextRx.test(char)) {
            continue;
          }
          const binary = internals.binary(char);
          if (!internals.atomRx.test(binary)) {
            return Errors.code("INVALID_LOCAL_CHARS");
          }
        }
      }
    };
    internals.binary = function(char) {
      return Array.from(internals.encoder.encode(char)).map((v) => String.fromCharCode(v)).join("");
    };
    internals.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/;
    internals.atomRx = new RegExp([
      "(?:[\\xc2-\\xdf][\\x80-\\xbf])",
      "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})",
      "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"
    ].join("|"));
  }
});

// node_modules/@hapi/address/lib/uri.js
var require_uri = __commonJS({
  "node_modules/@hapi/address/lib/uri.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var EscapeRegex = require_escapeRegex();
    var internals = {};
    internals.generate = function() {
      const rfc3986 = {};
      const hexDigit = "\\dA-Fa-f";
      const hexDigitOnly = "[" + hexDigit + "]";
      const unreserved = "\\w-\\.~";
      const subDelims = "!\\$&'\\(\\)\\*\\+,;=";
      const pctEncoded = "%" + hexDigit;
      const pchar = unreserved + pctEncoded + subDelims + ":@";
      const pcharOnly = "[" + pchar + "]";
      const decOctect = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
      rfc3986.ipv4address = "(?:" + decOctect + "\\.){3}" + decOctect;
      const h16 = hexDigitOnly + "{1,4}";
      const ls32 = "(?:" + h16 + ":" + h16 + "|" + rfc3986.ipv4address + ")";
      const IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
      const IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
      const IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
      const IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
      const IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
      const IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
      const IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
      const IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
      const IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
      rfc3986.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])";
      rfc3986.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])";
      rfc3986.ipv6address = "(?:" + IPv6SixHex + "|" + IPv6FiveHex + "|" + IPv6FourHex + "|" + IPv6ThreeHex + "|" + IPv6TwoHex + "|" + IPv6OneHex + "|" + IPv6NoneHex + "|" + IPv6NoneHex2 + "|" + IPv6NoneHex3 + ")";
      rfc3986.ipvFuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
      rfc3986.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*";
      rfc3986.schemeRegex = new RegExp(rfc3986.scheme);
      const userinfo = "[" + unreserved + pctEncoded + subDelims + ":]*";
      const IPLiteral = "\\[(?:" + rfc3986.ipv6address + "|" + rfc3986.ipvFuture + ")\\]";
      const regName = "[" + unreserved + pctEncoded + subDelims + "]{1,255}";
      const host = "(?:" + IPLiteral + "|" + rfc3986.ipv4address + "|" + regName + ")";
      const port = "\\d*";
      const authority = "(?:" + userinfo + "@)?" + host + "(?::" + port + ")?";
      const authorityCapture = "(?:" + userinfo + "@)?(" + host + ")(?::" + port + ")?";
      const segment = pcharOnly + "*";
      const segmentNz = pcharOnly + "+";
      const segmentNzNc = "[" + unreserved + pctEncoded + subDelims + "@]+";
      const pathEmpty = "";
      const pathAbEmpty = "(?:\\/" + segment + ")*";
      const pathAbsolute = "\\/(?:" + segmentNz + pathAbEmpty + ")?";
      const pathRootless = segmentNz + pathAbEmpty;
      const pathNoScheme = segmentNzNc + pathAbEmpty;
      const pathAbNoAuthority = "(?:\\/\\/\\/" + segment + pathAbEmpty + ")";
      rfc3986.hierPart = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")|" + pathAbsolute + "|" + pathRootless + "|" + pathAbNoAuthority + ")";
      rfc3986.hierPartCapture = "(?:(?:\\/\\/" + authorityCapture + pathAbEmpty + ")|" + pathAbsolute + "|" + pathRootless + ")";
      rfc3986.relativeRef = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
      rfc3986.relativeRefCapture = "(?:(?:\\/\\/" + authorityCapture + pathAbEmpty + ")|" + pathAbsolute + "|" + pathNoScheme + "|" + pathEmpty + ")";
      rfc3986.query = "[" + pchar + "\\/\\?]*(?=#|$)";
      rfc3986.queryWithSquareBrackets = "[" + pchar + "\\[\\]\\/\\?]*(?=#|$)";
      rfc3986.fragment = "[" + pchar + "\\/\\?]*";
      return rfc3986;
    };
    internals.rfc3986 = internals.generate();
    exports.ip = {
      v4Cidr: internals.rfc3986.ipv4Cidr,
      v6Cidr: internals.rfc3986.ipv6Cidr,
      ipv4: internals.rfc3986.ipv4address,
      ipv6: internals.rfc3986.ipv6address,
      ipvfuture: internals.rfc3986.ipvFuture
    };
    internals.createRegex = function(options) {
      const rfc = internals.rfc3986;
      const query = options.allowQuerySquareBrackets ? rfc.queryWithSquareBrackets : rfc.query;
      const suffix = "(?:\\?" + query + ")?(?:#" + rfc.fragment + ")?";
      const relative = options.domain ? rfc.relativeRefCapture : rfc.relativeRef;
      if (options.relativeOnly) {
        return internals.wrap(relative + suffix);
      }
      let customScheme = "";
      if (options.scheme) {
        Assert(options.scheme instanceof RegExp || typeof options.scheme === "string" || Array.isArray(options.scheme), "scheme must be a RegExp, String, or Array");
        const schemes = [].concat(options.scheme);
        Assert(schemes.length >= 1, "scheme must have at least 1 scheme specified");
        const selections = [];
        for (let i = 0; i < schemes.length; ++i) {
          const scheme2 = schemes[i];
          Assert(scheme2 instanceof RegExp || typeof scheme2 === "string", "scheme at position " + i + " must be a RegExp or String");
          if (scheme2 instanceof RegExp) {
            selections.push(scheme2.source.toString());
          } else {
            Assert(rfc.schemeRegex.test(scheme2), "scheme at position " + i + " must be a valid scheme");
            selections.push(EscapeRegex(scheme2));
          }
        }
        customScheme = selections.join("|");
      }
      const scheme = customScheme ? "(?:" + customScheme + ")" : rfc.scheme;
      const absolute = "(?:" + scheme + ":" + (options.domain ? rfc.hierPartCapture : rfc.hierPart) + ")";
      const prefix = options.allowRelative ? "(?:" + absolute + "|" + relative + ")" : absolute;
      return internals.wrap(prefix + suffix, customScheme);
    };
    internals.wrap = function(raw, scheme) {
      raw = `(?=.)(?!https?:/$)${raw}`;
      return {
        raw,
        regex: new RegExp(`^${raw}$`),
        scheme
      };
    };
    internals.uriRegex = internals.createRegex({});
    exports.regex = function(options = {}) {
      if (options.scheme || options.allowRelative || options.relativeOnly || options.allowQuerySquareBrackets || options.domain) {
        return internals.createRegex(options);
      }
      return internals.uriRegex;
    };
  }
});

// node_modules/@hapi/address/lib/ip.js
var require_ip = __commonJS({
  "node_modules/@hapi/address/lib/ip.js"(exports) {
    "use strict";
    var Assert = require_assert();
    var Uri = require_uri();
    exports.regex = function(options = {}) {
      Assert(options.cidr === void 0 || typeof options.cidr === "string", "options.cidr must be a string");
      const cidr = options.cidr ? options.cidr.toLowerCase() : "optional";
      Assert(["required", "optional", "forbidden"].includes(cidr), "options.cidr must be one of required, optional, forbidden");
      Assert(options.version === void 0 || typeof options.version === "string" || Array.isArray(options.version), "options.version must be a string or an array of string");
      let versions = options.version || ["ipv4", "ipv6", "ipvfuture"];
      if (!Array.isArray(versions)) {
        versions = [versions];
      }
      Assert(versions.length >= 1, "options.version must have at least 1 version specified");
      for (let i = 0; i < versions.length; ++i) {
        Assert(typeof versions[i] === "string", "options.version must only contain strings");
        versions[i] = versions[i].toLowerCase();
        Assert(["ipv4", "ipv6", "ipvfuture"].includes(versions[i]), "options.version contains unknown version " + versions[i] + " - must be one of ipv4, ipv6, ipvfuture");
      }
      versions = Array.from(new Set(versions));
      const parts = versions.map((version) => {
        if (cidr === "forbidden") {
          return Uri.ip[version];
        }
        const cidrpart = `\\/${version === "ipv4" ? Uri.ip.v4Cidr : Uri.ip.v6Cidr}`;
        if (cidr === "required") {
          return `${Uri.ip[version]}${cidrpart}`;
        }
        return `${Uri.ip[version]}(?:${cidrpart})?`;
      });
      const raw = `(?:${parts.join("|")})`;
      const regex = new RegExp(`^${raw}$`);
      return { cidr, versions, regex, raw };
    };
  }
});

// node_modules/@hapi/address/lib/tlds.js
var require_tlds = __commonJS({
  "node_modules/@hapi/address/lib/tlds.js"(exports, module2) {
    "use strict";
    var internals = {};
    internals.tlds = [
      "AAA",
      "AARP",
      "ABARTH",
      "ABB",
      "ABBOTT",
      "ABBVIE",
      "ABC",
      "ABLE",
      "ABOGADO",
      "ABUDHABI",
      "AC",
      "ACADEMY",
      "ACCENTURE",
      "ACCOUNTANT",
      "ACCOUNTANTS",
      "ACO",
      "ACTOR",
      "AD",
      "ADAC",
      "ADS",
      "ADULT",
      "AE",
      "AEG",
      "AERO",
      "AETNA",
      "AF",
      "AFAMILYCOMPANY",
      "AFL",
      "AFRICA",
      "AG",
      "AGAKHAN",
      "AGENCY",
      "AI",
      "AIG",
      "AIGO",
      "AIRBUS",
      "AIRFORCE",
      "AIRTEL",
      "AKDN",
      "AL",
      "ALFAROMEO",
      "ALIBABA",
      "ALIPAY",
      "ALLFINANZ",
      "ALLSTATE",
      "ALLY",
      "ALSACE",
      "ALSTOM",
      "AM",
      "AMERICANEXPRESS",
      "AMERICANFAMILY",
      "AMEX",
      "AMFAM",
      "AMICA",
      "AMSTERDAM",
      "ANALYTICS",
      "ANDROID",
      "ANQUAN",
      "ANZ",
      "AO",
      "AOL",
      "APARTMENTS",
      "APP",
      "APPLE",
      "AQ",
      "AQUARELLE",
      "AR",
      "ARAB",
      "ARAMCO",
      "ARCHI",
      "ARMY",
      "ARPA",
      "ART",
      "ARTE",
      "AS",
      "ASDA",
      "ASIA",
      "ASSOCIATES",
      "AT",
      "ATHLETA",
      "ATTORNEY",
      "AU",
      "AUCTION",
      "AUDI",
      "AUDIBLE",
      "AUDIO",
      "AUSPOST",
      "AUTHOR",
      "AUTO",
      "AUTOS",
      "AVIANCA",
      "AW",
      "AWS",
      "AX",
      "AXA",
      "AZ",
      "AZURE",
      "BA",
      "BABY",
      "BAIDU",
      "BANAMEX",
      "BANANAREPUBLIC",
      "BAND",
      "BANK",
      "BAR",
      "BARCELONA",
      "BARCLAYCARD",
      "BARCLAYS",
      "BAREFOOT",
      "BARGAINS",
      "BASEBALL",
      "BASKETBALL",
      "BAUHAUS",
      "BAYERN",
      "BB",
      "BBC",
      "BBT",
      "BBVA",
      "BCG",
      "BCN",
      "BD",
      "BE",
      "BEATS",
      "BEAUTY",
      "BEER",
      "BENTLEY",
      "BERLIN",
      "BEST",
      "BESTBUY",
      "BET",
      "BF",
      "BG",
      "BH",
      "BHARTI",
      "BI",
      "BIBLE",
      "BID",
      "BIKE",
      "BING",
      "BINGO",
      "BIO",
      "BIZ",
      "BJ",
      "BLACK",
      "BLACKFRIDAY",
      "BLOCKBUSTER",
      "BLOG",
      "BLOOMBERG",
      "BLUE",
      "BM",
      "BMS",
      "BMW",
      "BN",
      "BNPPARIBAS",
      "BO",
      "BOATS",
      "BOEHRINGER",
      "BOFA",
      "BOM",
      "BOND",
      "BOO",
      "BOOK",
      "BOOKING",
      "BOSCH",
      "BOSTIK",
      "BOSTON",
      "BOT",
      "BOUTIQUE",
      "BOX",
      "BR",
      "BRADESCO",
      "BRIDGESTONE",
      "BROADWAY",
      "BROKER",
      "BROTHER",
      "BRUSSELS",
      "BS",
      "BT",
      "BUDAPEST",
      "BUGATTI",
      "BUILD",
      "BUILDERS",
      "BUSINESS",
      "BUY",
      "BUZZ",
      "BV",
      "BW",
      "BY",
      "BZ",
      "BZH",
      "CA",
      "CAB",
      "CAFE",
      "CAL",
      "CALL",
      "CALVINKLEIN",
      "CAM",
      "CAMERA",
      "CAMP",
      "CANCERRESEARCH",
      "CANON",
      "CAPETOWN",
      "CAPITAL",
      "CAPITALONE",
      "CAR",
      "CARAVAN",
      "CARDS",
      "CARE",
      "CAREER",
      "CAREERS",
      "CARS",
      "CARTIER",
      "CASA",
      "CASE",
      "CASEIH",
      "CASH",
      "CASINO",
      "CAT",
      "CATERING",
      "CATHOLIC",
      "CBA",
      "CBN",
      "CBRE",
      "CBS",
      "CC",
      "CD",
      "CEB",
      "CENTER",
      "CEO",
      "CERN",
      "CF",
      "CFA",
      "CFD",
      "CG",
      "CH",
      "CHANEL",
      "CHANNEL",
      "CHARITY",
      "CHASE",
      "CHAT",
      "CHEAP",
      "CHINTAI",
      "CHRISTMAS",
      "CHROME",
      "CHRYSLER",
      "CHURCH",
      "CI",
      "CIPRIANI",
      "CIRCLE",
      "CISCO",
      "CITADEL",
      "CITI",
      "CITIC",
      "CITY",
      "CITYEATS",
      "CK",
      "CL",
      "CLAIMS",
      "CLEANING",
      "CLICK",
      "CLINIC",
      "CLINIQUE",
      "CLOTHING",
      "CLOUD",
      "CLUB",
      "CLUBMED",
      "CM",
      "CN",
      "CO",
      "COACH",
      "CODES",
      "COFFEE",
      "COLLEGE",
      "COLOGNE",
      "COM",
      "COMCAST",
      "COMMBANK",
      "COMMUNITY",
      "COMPANY",
      "COMPARE",
      "COMPUTER",
      "COMSEC",
      "CONDOS",
      "CONSTRUCTION",
      "CONSULTING",
      "CONTACT",
      "CONTRACTORS",
      "COOKING",
      "COOKINGCHANNEL",
      "COOL",
      "COOP",
      "CORSICA",
      "COUNTRY",
      "COUPON",
      "COUPONS",
      "COURSES",
      "CR",
      "CREDIT",
      "CREDITCARD",
      "CREDITUNION",
      "CRICKET",
      "CROWN",
      "CRS",
      "CRUISE",
      "CRUISES",
      "CSC",
      "CU",
      "CUISINELLA",
      "CV",
      "CW",
      "CX",
      "CY",
      "CYMRU",
      "CYOU",
      "CZ",
      "DABUR",
      "DAD",
      "DANCE",
      "DATA",
      "DATE",
      "DATING",
      "DATSUN",
      "DAY",
      "DCLK",
      "DDS",
      "DE",
      "DEAL",
      "DEALER",
      "DEALS",
      "DEGREE",
      "DELIVERY",
      "DELL",
      "DELOITTE",
      "DELTA",
      "DEMOCRAT",
      "DENTAL",
      "DENTIST",
      "DESI",
      "DESIGN",
      "DEV",
      "DHL",
      "DIAMONDS",
      "DIET",
      "DIGITAL",
      "DIRECT",
      "DIRECTORY",
      "DISCOUNT",
      "DISCOVER",
      "DISH",
      "DIY",
      "DJ",
      "DK",
      "DM",
      "DNP",
      "DO",
      "DOCS",
      "DOCTOR",
      "DODGE",
      "DOG",
      "DOMAINS",
      "DOT",
      "DOWNLOAD",
      "DRIVE",
      "DTV",
      "DUBAI",
      "DUCK",
      "DUNLOP",
      "DUPONT",
      "DURBAN",
      "DVAG",
      "DVR",
      "DZ",
      "EARTH",
      "EAT",
      "EC",
      "ECO",
      "EDEKA",
      "EDU",
      "EDUCATION",
      "EE",
      "EG",
      "EMAIL",
      "EMERCK",
      "ENERGY",
      "ENGINEER",
      "ENGINEERING",
      "ENTERPRISES",
      "EPSON",
      "EQUIPMENT",
      "ER",
      "ERICSSON",
      "ERNI",
      "ES",
      "ESQ",
      "ESTATE",
      "ESURANCE",
      "ET",
      "ETISALAT",
      "EU",
      "EUROVISION",
      "EUS",
      "EVENTS",
      "EVERBANK",
      "EXCHANGE",
      "EXPERT",
      "EXPOSED",
      "EXPRESS",
      "EXTRASPACE",
      "FAGE",
      "FAIL",
      "FAIRWINDS",
      "FAITH",
      "FAMILY",
      "FAN",
      "FANS",
      "FARM",
      "FARMERS",
      "FASHION",
      "FAST",
      "FEDEX",
      "FEEDBACK",
      "FERRARI",
      "FERRERO",
      "FI",
      "FIAT",
      "FIDELITY",
      "FIDO",
      "FILM",
      "FINAL",
      "FINANCE",
      "FINANCIAL",
      "FIRE",
      "FIRESTONE",
      "FIRMDALE",
      "FISH",
      "FISHING",
      "FIT",
      "FITNESS",
      "FJ",
      "FK",
      "FLICKR",
      "FLIGHTS",
      "FLIR",
      "FLORIST",
      "FLOWERS",
      "FLY",
      "FM",
      "FO",
      "FOO",
      "FOOD",
      "FOODNETWORK",
      "FOOTBALL",
      "FORD",
      "FOREX",
      "FORSALE",
      "FORUM",
      "FOUNDATION",
      "FOX",
      "FR",
      "FREE",
      "FRESENIUS",
      "FRL",
      "FROGANS",
      "FRONTDOOR",
      "FRONTIER",
      "FTR",
      "FUJITSU",
      "FUJIXEROX",
      "FUN",
      "FUND",
      "FURNITURE",
      "FUTBOL",
      "FYI",
      "GA",
      "GAL",
      "GALLERY",
      "GALLO",
      "GALLUP",
      "GAME",
      "GAMES",
      "GAP",
      "GARDEN",
      "GAY",
      "GB",
      "GBIZ",
      "GD",
      "GDN",
      "GE",
      "GEA",
      "GENT",
      "GENTING",
      "GEORGE",
      "GF",
      "GG",
      "GGEE",
      "GH",
      "GI",
      "GIFT",
      "GIFTS",
      "GIVES",
      "GIVING",
      "GL",
      "GLADE",
      "GLASS",
      "GLE",
      "GLOBAL",
      "GLOBO",
      "GM",
      "GMAIL",
      "GMBH",
      "GMO",
      "GMX",
      "GN",
      "GODADDY",
      "GOLD",
      "GOLDPOINT",
      "GOLF",
      "GOO",
      "GOODYEAR",
      "GOOG",
      "GOOGLE",
      "GOP",
      "GOT",
      "GOV",
      "GP",
      "GQ",
      "GR",
      "GRAINGER",
      "GRAPHICS",
      "GRATIS",
      "GREEN",
      "GRIPE",
      "GROCERY",
      "GROUP",
      "GS",
      "GT",
      "GU",
      "GUARDIAN",
      "GUCCI",
      "GUGE",
      "GUIDE",
      "GUITARS",
      "GURU",
      "GW",
      "GY",
      "HAIR",
      "HAMBURG",
      "HANGOUT",
      "HAUS",
      "HBO",
      "HDFC",
      "HDFCBANK",
      "HEALTH",
      "HEALTHCARE",
      "HELP",
      "HELSINKI",
      "HERE",
      "HERMES",
      "HGTV",
      "HIPHOP",
      "HISAMITSU",
      "HITACHI",
      "HIV",
      "HK",
      "HKT",
      "HM",
      "HN",
      "HOCKEY",
      "HOLDINGS",
      "HOLIDAY",
      "HOMEDEPOT",
      "HOMEGOODS",
      "HOMES",
      "HOMESENSE",
      "HONDA",
      "HORSE",
      "HOSPITAL",
      "HOST",
      "HOSTING",
      "HOT",
      "HOTELES",
      "HOTELS",
      "HOTMAIL",
      "HOUSE",
      "HOW",
      "HR",
      "HSBC",
      "HT",
      "HU",
      "HUGHES",
      "HYATT",
      "HYUNDAI",
      "IBM",
      "ICBC",
      "ICE",
      "ICU",
      "ID",
      "IE",
      "IEEE",
      "IFM",
      "IKANO",
      "IL",
      "IM",
      "IMAMAT",
      "IMDB",
      "IMMO",
      "IMMOBILIEN",
      "IN",
      "INC",
      "INDUSTRIES",
      "INFINITI",
      "INFO",
      "ING",
      "INK",
      "INSTITUTE",
      "INSURANCE",
      "INSURE",
      "INT",
      "INTEL",
      "INTERNATIONAL",
      "INTUIT",
      "INVESTMENTS",
      "IO",
      "IPIRANGA",
      "IQ",
      "IR",
      "IRISH",
      "IS",
      "ISMAILI",
      "IST",
      "ISTANBUL",
      "IT",
      "ITAU",
      "ITV",
      "IVECO",
      "JAGUAR",
      "JAVA",
      "JCB",
      "JCP",
      "JE",
      "JEEP",
      "JETZT",
      "JEWELRY",
      "JIO",
      "JLL",
      "JM",
      "JMP",
      "JNJ",
      "JO",
      "JOBS",
      "JOBURG",
      "JOT",
      "JOY",
      "JP",
      "JPMORGAN",
      "JPRS",
      "JUEGOS",
      "JUNIPER",
      "KAUFEN",
      "KDDI",
      "KE",
      "KERRYHOTELS",
      "KERRYLOGISTICS",
      "KERRYPROPERTIES",
      "KFH",
      "KG",
      "KH",
      "KI",
      "KIA",
      "KIM",
      "KINDER",
      "KINDLE",
      "KITCHEN",
      "KIWI",
      "KM",
      "KN",
      "KOELN",
      "KOMATSU",
      "KOSHER",
      "KP",
      "KPMG",
      "KPN",
      "KR",
      "KRD",
      "KRED",
      "KUOKGROUP",
      "KW",
      "KY",
      "KYOTO",
      "KZ",
      "LA",
      "LACAIXA",
      "LADBROKES",
      "LAMBORGHINI",
      "LAMER",
      "LANCASTER",
      "LANCIA",
      "LANCOME",
      "LAND",
      "LANDROVER",
      "LANXESS",
      "LASALLE",
      "LAT",
      "LATINO",
      "LATROBE",
      "LAW",
      "LAWYER",
      "LB",
      "LC",
      "LDS",
      "LEASE",
      "LECLERC",
      "LEFRAK",
      "LEGAL",
      "LEGO",
      "LEXUS",
      "LGBT",
      "LI",
      "LIAISON",
      "LIDL",
      "LIFE",
      "LIFEINSURANCE",
      "LIFESTYLE",
      "LIGHTING",
      "LIKE",
      "LILLY",
      "LIMITED",
      "LIMO",
      "LINCOLN",
      "LINDE",
      "LINK",
      "LIPSY",
      "LIVE",
      "LIVING",
      "LIXIL",
      "LK",
      "LLC",
      "LOAN",
      "LOANS",
      "LOCKER",
      "LOCUS",
      "LOFT",
      "LOL",
      "LONDON",
      "LOTTE",
      "LOTTO",
      "LOVE",
      "LPL",
      "LPLFINANCIAL",
      "LR",
      "LS",
      "LT",
      "LTD",
      "LTDA",
      "LU",
      "LUNDBECK",
      "LUPIN",
      "LUXE",
      "LUXURY",
      "LV",
      "LY",
      "MA",
      "MACYS",
      "MADRID",
      "MAIF",
      "MAISON",
      "MAKEUP",
      "MAN",
      "MANAGEMENT",
      "MANGO",
      "MAP",
      "MARKET",
      "MARKETING",
      "MARKETS",
      "MARRIOTT",
      "MARSHALLS",
      "MASERATI",
      "MATTEL",
      "MBA",
      "MC",
      "MCKINSEY",
      "MD",
      "ME",
      "MED",
      "MEDIA",
      "MEET",
      "MELBOURNE",
      "MEME",
      "MEMORIAL",
      "MEN",
      "MENU",
      "MERCKMSD",
      "METLIFE",
      "MG",
      "MH",
      "MIAMI",
      "MICROSOFT",
      "MIL",
      "MINI",
      "MINT",
      "MIT",
      "MITSUBISHI",
      "MK",
      "ML",
      "MLB",
      "MLS",
      "MM",
      "MMA",
      "MN",
      "MO",
      "MOBI",
      "MOBILE",
      "MODA",
      "MOE",
      "MOI",
      "MOM",
      "MONASH",
      "MONEY",
      "MONSTER",
      "MOPAR",
      "MORMON",
      "MORTGAGE",
      "MOSCOW",
      "MOTO",
      "MOTORCYCLES",
      "MOV",
      "MOVIE",
      "MOVISTAR",
      "MP",
      "MQ",
      "MR",
      "MS",
      "MSD",
      "MT",
      "MTN",
      "MTR",
      "MU",
      "MUSEUM",
      "MUTUAL",
      "MV",
      "MW",
      "MX",
      "MY",
      "MZ",
      "NA",
      "NAB",
      "NADEX",
      "NAGOYA",
      "NAME",
      "NATIONWIDE",
      "NATURA",
      "NAVY",
      "NBA",
      "NC",
      "NE",
      "NEC",
      "NET",
      "NETBANK",
      "NETFLIX",
      "NETWORK",
      "NEUSTAR",
      "NEW",
      "NEWHOLLAND",
      "NEWS",
      "NEXT",
      "NEXTDIRECT",
      "NEXUS",
      "NF",
      "NFL",
      "NG",
      "NGO",
      "NHK",
      "NI",
      "NICO",
      "NIKE",
      "NIKON",
      "NINJA",
      "NISSAN",
      "NISSAY",
      "NL",
      "NO",
      "NOKIA",
      "NORTHWESTERNMUTUAL",
      "NORTON",
      "NOW",
      "NOWRUZ",
      "NOWTV",
      "NP",
      "NR",
      "NRA",
      "NRW",
      "NTT",
      "NU",
      "NYC",
      "NZ",
      "OBI",
      "OBSERVER",
      "OFF",
      "OFFICE",
      "OKINAWA",
      "OLAYAN",
      "OLAYANGROUP",
      "OLDNAVY",
      "OLLO",
      "OM",
      "OMEGA",
      "ONE",
      "ONG",
      "ONL",
      "ONLINE",
      "ONYOURSIDE",
      "OOO",
      "OPEN",
      "ORACLE",
      "ORANGE",
      "ORG",
      "ORGANIC",
      "ORIGINS",
      "OSAKA",
      "OTSUKA",
      "OTT",
      "OVH",
      "PA",
      "PAGE",
      "PANASONIC",
      "PARIS",
      "PARS",
      "PARTNERS",
      "PARTS",
      "PARTY",
      "PASSAGENS",
      "PAY",
      "PCCW",
      "PE",
      "PET",
      "PF",
      "PFIZER",
      "PG",
      "PH",
      "PHARMACY",
      "PHD",
      "PHILIPS",
      "PHONE",
      "PHOTO",
      "PHOTOGRAPHY",
      "PHOTOS",
      "PHYSIO",
      "PIAGET",
      "PICS",
      "PICTET",
      "PICTURES",
      "PID",
      "PIN",
      "PING",
      "PINK",
      "PIONEER",
      "PIZZA",
      "PK",
      "PL",
      "PLACE",
      "PLAY",
      "PLAYSTATION",
      "PLUMBING",
      "PLUS",
      "PM",
      "PN",
      "PNC",
      "POHL",
      "POKER",
      "POLITIE",
      "PORN",
      "POST",
      "PR",
      "PRAMERICA",
      "PRAXI",
      "PRESS",
      "PRIME",
      "PRO",
      "PROD",
      "PRODUCTIONS",
      "PROF",
      "PROGRESSIVE",
      "PROMO",
      "PROPERTIES",
      "PROPERTY",
      "PROTECTION",
      "PRU",
      "PRUDENTIAL",
      "PS",
      "PT",
      "PUB",
      "PW",
      "PWC",
      "PY",
      "QA",
      "QPON",
      "QUEBEC",
      "QUEST",
      "QVC",
      "RACING",
      "RADIO",
      "RAID",
      "RE",
      "READ",
      "REALESTATE",
      "REALTOR",
      "REALTY",
      "RECIPES",
      "RED",
      "REDSTONE",
      "REDUMBRELLA",
      "REHAB",
      "REISE",
      "REISEN",
      "REIT",
      "RELIANCE",
      "REN",
      "RENT",
      "RENTALS",
      "REPAIR",
      "REPORT",
      "REPUBLICAN",
      "REST",
      "RESTAURANT",
      "REVIEW",
      "REVIEWS",
      "REXROTH",
      "RICH",
      "RICHARDLI",
      "RICOH",
      "RIGHTATHOME",
      "RIL",
      "RIO",
      "RIP",
      "RMIT",
      "RO",
      "ROCHER",
      "ROCKS",
      "RODEO",
      "ROGERS",
      "ROOM",
      "RS",
      "RSVP",
      "RU",
      "RUGBY",
      "RUHR",
      "RUN",
      "RW",
      "RWE",
      "RYUKYU",
      "SA",
      "SAARLAND",
      "SAFE",
      "SAFETY",
      "SAKURA",
      "SALE",
      "SALON",
      "SAMSCLUB",
      "SAMSUNG",
      "SANDVIK",
      "SANDVIKCOROMANT",
      "SANOFI",
      "SAP",
      "SARL",
      "SAS",
      "SAVE",
      "SAXO",
      "SB",
      "SBI",
      "SBS",
      "SC",
      "SCA",
      "SCB",
      "SCHAEFFLER",
      "SCHMIDT",
      "SCHOLARSHIPS",
      "SCHOOL",
      "SCHULE",
      "SCHWARZ",
      "SCIENCE",
      "SCJOHNSON",
      "SCOR",
      "SCOT",
      "SD",
      "SE",
      "SEARCH",
      "SEAT",
      "SECURE",
      "SECURITY",
      "SEEK",
      "SELECT",
      "SENER",
      "SERVICES",
      "SES",
      "SEVEN",
      "SEW",
      "SEX",
      "SEXY",
      "SFR",
      "SG",
      "SH",
      "SHANGRILA",
      "SHARP",
      "SHAW",
      "SHELL",
      "SHIA",
      "SHIKSHA",
      "SHOES",
      "SHOP",
      "SHOPPING",
      "SHOUJI",
      "SHOW",
      "SHOWTIME",
      "SHRIRAM",
      "SI",
      "SILK",
      "SINA",
      "SINGLES",
      "SITE",
      "SJ",
      "SK",
      "SKI",
      "SKIN",
      "SKY",
      "SKYPE",
      "SL",
      "SLING",
      "SM",
      "SMART",
      "SMILE",
      "SN",
      "SNCF",
      "SO",
      "SOCCER",
      "SOCIAL",
      "SOFTBANK",
      "SOFTWARE",
      "SOHU",
      "SOLAR",
      "SOLUTIONS",
      "SONG",
      "SONY",
      "SOY",
      "SPACE",
      "SPORT",
      "SPOT",
      "SPREADBETTING",
      "SR",
      "SRL",
      "SRT",
      "SS",
      "ST",
      "STADA",
      "STAPLES",
      "STAR",
      "STATEBANK",
      "STATEFARM",
      "STC",
      "STCGROUP",
      "STOCKHOLM",
      "STORAGE",
      "STORE",
      "STREAM",
      "STUDIO",
      "STUDY",
      "STYLE",
      "SU",
      "SUCKS",
      "SUPPLIES",
      "SUPPLY",
      "SUPPORT",
      "SURF",
      "SURGERY",
      "SUZUKI",
      "SV",
      "SWATCH",
      "SWIFTCOVER",
      "SWISS",
      "SX",
      "SY",
      "SYDNEY",
      "SYMANTEC",
      "SYSTEMS",
      "SZ",
      "TAB",
      "TAIPEI",
      "TALK",
      "TAOBAO",
      "TARGET",
      "TATAMOTORS",
      "TATAR",
      "TATTOO",
      "TAX",
      "TAXI",
      "TC",
      "TCI",
      "TD",
      "TDK",
      "TEAM",
      "TECH",
      "TECHNOLOGY",
      "TEL",
      "TELEFONICA",
      "TEMASEK",
      "TENNIS",
      "TEVA",
      "TF",
      "TG",
      "TH",
      "THD",
      "THEATER",
      "THEATRE",
      "TIAA",
      "TICKETS",
      "TIENDA",
      "TIFFANY",
      "TIPS",
      "TIRES",
      "TIROL",
      "TJ",
      "TJMAXX",
      "TJX",
      "TK",
      "TKMAXX",
      "TL",
      "TM",
      "TMALL",
      "TN",
      "TO",
      "TODAY",
      "TOKYO",
      "TOOLS",
      "TOP",
      "TORAY",
      "TOSHIBA",
      "TOTAL",
      "TOURS",
      "TOWN",
      "TOYOTA",
      "TOYS",
      "TR",
      "TRADE",
      "TRADING",
      "TRAINING",
      "TRAVEL",
      "TRAVELCHANNEL",
      "TRAVELERS",
      "TRAVELERSINSURANCE",
      "TRUST",
      "TRV",
      "TT",
      "TUBE",
      "TUI",
      "TUNES",
      "TUSHU",
      "TV",
      "TVS",
      "TW",
      "TZ",
      "UA",
      "UBANK",
      "UBS",
      "UCONNECT",
      "UG",
      "UK",
      "UNICOM",
      "UNIVERSITY",
      "UNO",
      "UOL",
      "UPS",
      "US",
      "UY",
      "UZ",
      "VA",
      "VACATIONS",
      "VANA",
      "VANGUARD",
      "VC",
      "VE",
      "VEGAS",
      "VENTURES",
      "VERISIGN",
      "VERSICHERUNG",
      "VET",
      "VG",
      "VI",
      "VIAJES",
      "VIDEO",
      "VIG",
      "VIKING",
      "VILLAS",
      "VIN",
      "VIP",
      "VIRGIN",
      "VISA",
      "VISION",
      "VISTAPRINT",
      "VIVA",
      "VIVO",
      "VLAANDEREN",
      "VN",
      "VODKA",
      "VOLKSWAGEN",
      "VOLVO",
      "VOTE",
      "VOTING",
      "VOTO",
      "VOYAGE",
      "VU",
      "VUELOS",
      "WALES",
      "WALMART",
      "WALTER",
      "WANG",
      "WANGGOU",
      "WARMAN",
      "WATCH",
      "WATCHES",
      "WEATHER",
      "WEATHERCHANNEL",
      "WEBCAM",
      "WEBER",
      "WEBSITE",
      "WED",
      "WEDDING",
      "WEIBO",
      "WEIR",
      "WF",
      "WHOSWHO",
      "WIEN",
      "WIKI",
      "WILLIAMHILL",
      "WIN",
      "WINDOWS",
      "WINE",
      "WINNERS",
      "WME",
      "WOLTERSKLUWER",
      "WOODSIDE",
      "WORK",
      "WORKS",
      "WORLD",
      "WOW",
      "WS",
      "WTC",
      "WTF",
      "XBOX",
      "XEROX",
      "XFINITY",
      "XIHUAN",
      "XIN",
      "XN--11B4C3D",
      "XN--1CK2E1B",
      "XN--1QQW23A",
      "XN--2SCRJ9C",
      "XN--30RR7Y",
      "XN--3BST00M",
      "XN--3DS443G",
      "XN--3E0B707E",
      "XN--3HCRJ9C",
      "XN--3OQ18VL8PN36A",
      "XN--3PXU8K",
      "XN--42C2D9A",
      "XN--45BR5CYL",
      "XN--45BRJ9C",
      "XN--45Q11C",
      "XN--4GBRIM",
      "XN--54B7FTA0CC",
      "XN--55QW42G",
      "XN--55QX5D",
      "XN--5SU34J936BGSG",
      "XN--5TZM5G",
      "XN--6FRZ82G",
      "XN--6QQ986B3XL",
      "XN--80ADXHKS",
      "XN--80AO21A",
      "XN--80AQECDR1A",
      "XN--80ASEHDB",
      "XN--80ASWG",
      "XN--8Y0A063A",
      "XN--90A3AC",
      "XN--90AE",
      "XN--90AIS",
      "XN--9DBQ2A",
      "XN--9ET52U",
      "XN--9KRT00A",
      "XN--B4W605FERD",
      "XN--BCK1B9A5DRE4C",
      "XN--C1AVG",
      "XN--C2BR7G",
      "XN--CCK2B3B",
      "XN--CG4BKI",
      "XN--CLCHC0EA0B2G2A9GCD",
      "XN--CZR694B",
      "XN--CZRS0T",
      "XN--CZRU2D",
      "XN--D1ACJ3B",
      "XN--D1ALF",
      "XN--E1A4C",
      "XN--ECKVDTC9D",
      "XN--EFVY88H",
      "XN--ESTV75G",
      "XN--FCT429K",
      "XN--FHBEI",
      "XN--FIQ228C5HS",
      "XN--FIQ64B",
      "XN--FIQS8S",
      "XN--FIQZ9S",
      "XN--FJQ720A",
      "XN--FLW351E",
      "XN--FPCRJ9C3D",
      "XN--FZC2C9E2C",
      "XN--FZYS8D69UVGM",
      "XN--G2XX48C",
      "XN--GCKR3F0F",
      "XN--GECRJ9C",
      "XN--GK3AT1E",
      "XN--H2BREG3EVE",
      "XN--H2BRJ9C",
      "XN--H2BRJ9C8C",
      "XN--HXT814E",
      "XN--I1B6B1A6A2E",
      "XN--IMR513N",
      "XN--IO0A7I",
      "XN--J1AEF",
      "XN--J1AMH",
      "XN--J6W193G",
      "XN--JLQ61U9W7B",
      "XN--JVR189M",
      "XN--KCRX77D1X4A",
      "XN--KPRW13D",
      "XN--KPRY57D",
      "XN--KPU716F",
      "XN--KPUT3I",
      "XN--L1ACC",
      "XN--LGBBAT1AD8J",
      "XN--MGB9AWBF",
      "XN--MGBA3A3EJT",
      "XN--MGBA3A4F16A",
      "XN--MGBA7C0BBN0A",
      "XN--MGBAAKC7DVF",
      "XN--MGBAAM7A8H",
      "XN--MGBAB2BD",
      "XN--MGBAH1A3HJKRD",
      "XN--MGBAI9AZGQP6J",
      "XN--MGBAYH7GPA",
      "XN--MGBBH1A",
      "XN--MGBBH1A71E",
      "XN--MGBC0A9AZCG",
      "XN--MGBCA7DZDO",
      "XN--MGBERP4A5D4AR",
      "XN--MGBGU82A",
      "XN--MGBI4ECEXP",
      "XN--MGBPL2FH",
      "XN--MGBT3DHD",
      "XN--MGBTX2B",
      "XN--MGBX4CD0AB",
      "XN--MIX891F",
      "XN--MK1BU44C",
      "XN--MXTQ1M",
      "XN--NGBC5AZD",
      "XN--NGBE9E0A",
      "XN--NGBRX",
      "XN--NODE",
      "XN--NQV7F",
      "XN--NQV7FS00EMA",
      "XN--NYQY26A",
      "XN--O3CW4H",
      "XN--OGBPF8FL",
      "XN--OTU796D",
      "XN--P1ACF",
      "XN--P1AI",
      "XN--PBT977C",
      "XN--PGBS0DH",
      "XN--PSSY2U",
      "XN--Q9JYB4C",
      "XN--QCKA1PMC",
      "XN--QXA6A",
      "XN--QXAM",
      "XN--RHQV96G",
      "XN--ROVU88B",
      "XN--RVC1E0AM3E",
      "XN--S9BRJ9C",
      "XN--SES554G",
      "XN--T60B56A",
      "XN--TCKWE",
      "XN--TIQ49XQYJ",
      "XN--UNUP4Y",
      "XN--VERMGENSBERATER-CTB",
      "XN--VERMGENSBERATUNG-PWB",
      "XN--VHQUV",
      "XN--VUQ861B",
      "XN--W4R85EL8FHU5DNRA",
      "XN--W4RS40L",
      "XN--WGBH1C",
      "XN--WGBL6A",
      "XN--XHQ521B",
      "XN--XKC2AL3HYE2A",
      "XN--XKC2DL3A5EE0H",
      "XN--Y9A3AQ",
      "XN--YFRO4I67O",
      "XN--YGBI2AMMX",
      "XN--ZFR164B",
      "XXX",
      "XYZ",
      "YACHTS",
      "YAHOO",
      "YAMAXUN",
      "YANDEX",
      "YE",
      "YODOBASHI",
      "YOGA",
      "YOKOHAMA",
      "YOU",
      "YOUTUBE",
      "YT",
      "YUN",
      "ZA",
      "ZAPPOS",
      "ZARA",
      "ZERO",
      "ZIP",
      "ZM",
      "ZONE",
      "ZUERICH",
      "ZW"
    ];
    module2.exports = new Set(internals.tlds.map((tld) => tld.toLowerCase()));
  }
});

// node_modules/@hapi/joi/lib/types/string.js
var require_string2 = __commonJS({
  "node_modules/@hapi/joi/lib/types/string.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Domain = require_domain();
    var Email = require_email();
    var Ip = require_ip();
    var EscapeRegex = require_escapeRegex();
    var Tlds = require_tlds();
    var Uri = require_uri();
    var Any = require_any2();
    var Common = require_common2();
    var internals = {
      tlds: Tlds instanceof Set ? { tlds: { allow: Tlds, deny: null } } : false,
      base64Regex: {
        true: {
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
        },
        false: {
          true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
          false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
        }
      },
      dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
      hexRegex: /^[a-f0-9]+$/i,
      ipRegex: Ip.regex().regex,
      isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,
      guidBrackets: {
        "{": "}",
        "[": "]",
        "(": ")",
        "": ""
      },
      guidVersions: {
        uuidv1: "1",
        uuidv2: "2",
        uuidv3: "3",
        uuidv4: "4",
        uuidv5: "5"
      },
      cidrPresences: ["required", "optional", "forbidden"],
      normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"]
    };
    module2.exports = Any.extend({
      type: "string",
      flags: {
        insensitive: { default: false },
        truncate: { default: false }
      },
      terms: {
        replacements: { init: null }
      },
      coerce: {
        from: "string",
        method(value, { schema, state, prefs }) {
          const normalize = schema.$_getRule("normalize");
          if (normalize) {
            value = value.normalize(normalize.args.form);
          }
          const casing = schema.$_getRule("case");
          if (casing) {
            value = casing.args.direction === "upper" ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
          }
          const trim = schema.$_getRule("trim");
          if (trim && trim.args.enabled) {
            value = value.trim();
          }
          if (schema.$_terms.replacements) {
            for (const replacement of schema.$_terms.replacements) {
              value = value.replace(replacement.pattern, replacement.replacement);
            }
          }
          const hex = schema.$_getRule("hex");
          if (hex && hex.args.options.byteAligned && value.length % 2 !== 0) {
            value = `0${value}`;
          }
          if (schema.$_getRule("isoDate")) {
            const iso = internals.isoDate(value);
            if (iso) {
              value = iso;
            }
          }
          if (schema._flags.truncate) {
            const rule = schema.$_getRule("max");
            if (rule) {
              let limit = rule.args.limit;
              if (Common.isResolvable(limit)) {
                limit = limit.resolve(value, state, prefs);
                if (!Common.limit(limit)) {
                  return { value, errors: schema.$_createError("any.ref", limit, { ref: rule.args.limit, arg: "limit", reason: "must be a positive integer" }, state, prefs) };
                }
              }
              value = value.slice(0, limit);
            }
          }
          return { value };
        }
      },
      validate(value, { error }) {
        if (typeof value !== "string") {
          return { value, errors: error("string.base") };
        }
        if (value === "") {
          return { value, errors: error("string.empty") };
        }
      },
      rules: {
        alphanum: {
          method() {
            return this.$_addRule("alphanum");
          },
          validate(value, helpers) {
            if (/^[a-zA-Z0-9]+$/.test(value)) {
              return value;
            }
            return helpers.error("string.alphanum");
          }
        },
        base64: {
          method(options = {}) {
            Common.assertOptions(options, ["paddingRequired", "urlSafe"]);
            options = { urlSafe: false, paddingRequired: true, ...options };
            Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
            Assert(typeof options.urlSafe === "boolean", "urlSafe must be boolean");
            return this.$_addRule({ name: "base64", args: { options } });
          },
          validate(value, helpers, { options }) {
            const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];
            if (regex.test(value)) {
              return value;
            }
            return helpers.error("string.base64");
          }
        },
        case: {
          method(direction) {
            Assert(["lower", "upper"].includes(direction), "Invalid case:", direction);
            return this.$_addRule({ name: "case", args: { direction } });
          },
          validate(value, helpers, { direction }) {
            if (direction === "lower" && value === value.toLocaleLowerCase() || direction === "upper" && value === value.toLocaleUpperCase()) {
              return value;
            }
            return helpers.error(`string.${direction}case`);
          },
          convert: true
        },
        creditCard: {
          method() {
            return this.$_addRule("creditCard");
          },
          validate(value, helpers) {
            let i = value.length;
            let sum = 0;
            let mul = 1;
            while (i--) {
              const char = value.charAt(i) * mul;
              sum = sum + (char - (char > 9) * 9);
              mul = mul ^ 3;
            }
            if (sum > 0 && sum % 10 === 0) {
              return value;
            }
            return helpers.error("string.creditCard");
          }
        },
        dataUri: {
          method(options = {}) {
            Common.assertOptions(options, ["paddingRequired"]);
            options = { paddingRequired: true, ...options };
            Assert(typeof options.paddingRequired === "boolean", "paddingRequired must be boolean");
            return this.$_addRule({ name: "dataUri", args: { options } });
          },
          validate(value, helpers, { options }) {
            const matches = value.match(internals.dataUriRegex);
            if (matches) {
              if (!matches[2]) {
                return value;
              }
              if (matches[2] !== "base64") {
                return value;
              }
              const base64regex = internals.base64Regex[options.paddingRequired].false;
              if (base64regex.test(matches[3])) {
                return value;
              }
            }
            return helpers.error("string.dataUri");
          }
        },
        domain: {
          method(options) {
            if (options) {
              Common.assertOptions(options, ["allowUnicode", "minDomainSegments", "tlds"]);
            }
            const address = internals.addressOptions(options);
            return this.$_addRule({ name: "domain", args: { options }, address });
          },
          validate(value, helpers, args, { address }) {
            if (Domain.isValid(value, address)) {
              return value;
            }
            return helpers.error("string.domain");
          }
        },
        email: {
          method(options = {}) {
            Common.assertOptions(options, ["allowUnicode", "ignoreLength", "minDomainSegments", "multiple", "separator", "tlds"]);
            Assert(options.multiple === void 0 || typeof options.multiple === "boolean", "multiple option must be an boolean");
            const address = internals.addressOptions(options);
            const regex = new RegExp(`\\s*[${options.separator ? EscapeRegex(options.separator) : ","}]\\s*`);
            return this.$_addRule({ name: "email", args: { options }, regex, address });
          },
          validate(value, helpers, { options }, { regex, address }) {
            const emails = options.multiple ? value.split(regex) : [value];
            const invalids = [];
            for (const email of emails) {
              if (!Email.isValid(email, address)) {
                invalids.push(email);
              }
            }
            if (!invalids.length) {
              return value;
            }
            return helpers.error("string.email", { value, invalids });
          }
        },
        guid: {
          alias: "uuid",
          method(options = {}) {
            Common.assertOptions(options, ["version"]);
            let versionNumbers = "";
            if (options.version) {
              const versions = [].concat(options.version);
              Assert(versions.length >= 1, "version must have at least 1 valid version specified");
              const set = /* @__PURE__ */ new Set();
              for (let i = 0; i < versions.length; ++i) {
                const version = versions[i];
                Assert(typeof version === "string", "version at position " + i + " must be a string");
                const versionNumber = internals.guidVersions[version.toLowerCase()];
                Assert(versionNumber, "version at position " + i + " must be one of " + Object.keys(internals.guidVersions).join(", "));
                Assert(!set.has(versionNumber), "version at position " + i + " must not be a duplicate");
                versionNumbers += versionNumber;
                set.add(versionNumber);
              }
            }
            const regex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\2?[${versionNumbers || "0-9A-F"}][0-9A-F]{3}\\2?[${versionNumbers ? "89AB" : "0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, "i");
            return this.$_addRule({ name: "guid", args: { options }, regex });
          },
          validate(value, helpers, args, { regex }) {
            const results = regex.exec(value);
            if (!results) {
              return helpers.error("string.guid");
            }
            if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
              return helpers.error("string.guid");
            }
            return value;
          }
        },
        hex: {
          method(options = {}) {
            Common.assertOptions(options, ["byteAligned"]);
            options = { byteAligned: false, ...options };
            Assert(typeof options.byteAligned === "boolean", "byteAligned must be boolean");
            return this.$_addRule({ name: "hex", args: { options } });
          },
          validate(value, helpers, { options }) {
            if (!internals.hexRegex.test(value)) {
              return helpers.error("string.hex");
            }
            if (options.byteAligned && value.length % 2 !== 0) {
              return helpers.error("string.hexAlign");
            }
            return value;
          }
        },
        hostname: {
          method() {
            return this.$_addRule("hostname");
          },
          validate(value, helpers) {
            if (Domain.isValid(value, { minDomainSegments: 1 }) || internals.ipRegex.test(value)) {
              return value;
            }
            return helpers.error("string.hostname");
          }
        },
        insensitive: {
          method() {
            return this.$_setFlag("insensitive", true);
          }
        },
        ip: {
          method(options = {}) {
            Common.assertOptions(options, ["cidr", "version"]);
            const { cidr, versions, regex } = Ip.regex(options);
            const version = options.version ? versions : void 0;
            return this.$_addRule({ name: "ip", args: { options: { cidr, version } }, regex });
          },
          validate(value, helpers, { options }, { regex }) {
            if (regex.test(value)) {
              return value;
            }
            if (options.version) {
              return helpers.error("string.ipVersion", { value, cidr: options.cidr, version: options.version });
            }
            return helpers.error("string.ip", { value, cidr: options.cidr });
          }
        },
        isoDate: {
          method() {
            return this.$_addRule("isoDate");
          },
          validate(value, { error }) {
            if (internals.isoDate(value)) {
              return value;
            }
            return error("string.isoDate");
          }
        },
        isoDuration: {
          method() {
            return this.$_addRule("isoDuration");
          },
          validate(value, helpers) {
            if (internals.isoDurationRegex.test(value)) {
              return value;
            }
            return helpers.error("string.isoDuration");
          }
        },
        length: {
          method(limit, encoding) {
            return internals.length(this, "length", limit, "=", encoding);
          },
          validate(value, helpers, { limit, encoding }, { name, operator, args }) {
            const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;
            if (Common.compare(length, limit, operator)) {
              return value;
            }
            return helpers.error("string." + name, { limit: args.limit, value, encoding });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            },
            "encoding"
          ]
        },
        lowercase: {
          method() {
            return this.case("lower");
          }
        },
        max: {
          method(limit, encoding) {
            return internals.length(this, "max", limit, "<=", encoding);
          },
          args: ["limit", "encoding"]
        },
        min: {
          method(limit, encoding) {
            return internals.length(this, "min", limit, ">=", encoding);
          },
          args: ["limit", "encoding"]
        },
        normalize: {
          method(form = "NFC") {
            Assert(internals.normalizationForms.includes(form), "normalization form must be one of " + internals.normalizationForms.join(", "));
            return this.$_addRule({ name: "normalize", args: { form } });
          },
          validate(value, { error }, { form }) {
            if (value === value.normalize(form)) {
              return value;
            }
            return error("string.normalize", { value, form });
          },
          convert: true
        },
        pattern: {
          alias: "regex",
          method(regex, options = {}) {
            Assert(regex instanceof RegExp, "regex must be a RegExp");
            Assert(!regex.flags.includes("g") && !regex.flags.includes("y"), "regex should not use global or sticky mode");
            if (typeof options === "string") {
              options = { name: options };
            }
            Common.assertOptions(options, ["invert", "name"]);
            const errorCode = ["string.pattern", options.invert ? ".invert" : "", options.name ? ".name" : ".base"].join("");
            return this.$_addRule({ name: "pattern", args: { regex, options }, errorCode });
          },
          validate(value, helpers, { regex, options }, { errorCode }) {
            const patternMatch = regex.test(value);
            if (patternMatch ^ options.invert) {
              return value;
            }
            return helpers.error(errorCode, { name: options.name, regex, value });
          },
          args: ["regex", "options"],
          multi: true
        },
        replace: {
          method(pattern, replacement) {
            if (typeof pattern === "string") {
              pattern = new RegExp(EscapeRegex(pattern), "g");
            }
            Assert(pattern instanceof RegExp, "pattern must be a RegExp");
            Assert(typeof replacement === "string", "replacement must be a String");
            const obj = this.clone();
            if (!obj.$_terms.replacements) {
              obj.$_terms.replacements = [];
            }
            obj.$_terms.replacements.push({ pattern, replacement });
            return obj;
          }
        },
        token: {
          method() {
            return this.$_addRule("token");
          },
          validate(value, helpers) {
            if (/^\w+$/.test(value)) {
              return value;
            }
            return helpers.error("string.token");
          }
        },
        trim: {
          method(enabled = true) {
            Assert(typeof enabled === "boolean", "enabled must be a boolean");
            return this.$_addRule({ name: "trim", args: { enabled } });
          },
          validate(value, helpers, { enabled }) {
            if (!enabled || value === value.trim()) {
              return value;
            }
            return helpers.error("string.trim");
          },
          convert: true
        },
        truncate: {
          method(enabled = true) {
            Assert(typeof enabled === "boolean", "enabled must be a boolean");
            return this.$_setFlag("truncate", enabled);
          }
        },
        uppercase: {
          method() {
            return this.case("upper");
          }
        },
        uri: {
          method(options = {}) {
            Common.assertOptions(options, ["allowRelative", "allowQuerySquareBrackets", "domain", "relativeOnly", "scheme"]);
            if (options.domain) {
              Common.assertOptions(options.domain, ["allowUnicode", "minDomainSegments", "tlds"]);
            }
            const { regex, scheme } = Uri.regex(options);
            const domain = options.domain ? internals.addressOptions(options.domain) : null;
            return this.$_addRule({ name: "uri", args: { options }, regex, domain, scheme });
          },
          validate(value, helpers, { options }, { regex, domain, scheme }) {
            if (["http:/", "https:/"].includes(value)) {
              return helpers.error("string.uri");
            }
            const match = regex.exec(value);
            if (match) {
              if (domain) {
                const matched = match[1] || match[2];
                if (!Domain.isValid(matched, domain)) {
                  return helpers.error("string.domain", { value: matched });
                }
              }
              return value;
            }
            if (options.relativeOnly) {
              return helpers.error("string.uriRelativeOnly");
            }
            if (options.scheme) {
              return helpers.error("string.uriCustomScheme", { scheme, value });
            }
            return helpers.error("string.uri");
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.replacements) {
            for (const { pattern, replacement } of desc.replacements) {
              obj = obj.replace(pattern, replacement);
            }
          }
          return obj;
        }
      },
      messages: {
        "string.alphanum": "{{#label}} must only contain alpha-numeric characters",
        "string.base": "{{#label}} must be a string",
        "string.base64": "{{#label}} must be a valid base64 string",
        "string.creditCard": "{{#label}} must be a credit card",
        "string.dataUri": "{{#label}} must be a valid dataUri string",
        "string.domain": "{{#label}} must contain a valid domain name",
        "string.email": "{{#label}} must be a valid email",
        "string.empty": "{{#label}} is not allowed to be empty",
        "string.guid": "{{#label}} must be a valid GUID",
        "string.hex": "{{#label}} must only contain hexadecimal characters",
        "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned",
        "string.hostname": "{{#label}} must be a valid hostname",
        "string.ip": "{{#label}} must be a valid ip address with a {{#cidr}} CIDR",
        "string.ipVersion": "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR",
        "string.isoDate": "{{#label}} must be in iso format",
        "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration",
        "string.length": "{{#label}} length must be {{#limit}} characters long",
        "string.lowercase": "{{#label}} must only contain lowercase characters",
        "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long",
        "string.min": "{{#label}} length must be at least {{#limit}} characters long",
        "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form",
        "string.token": "{{#label}} must only contain alpha-numeric and underscore characters",
        "string.pattern.base": '{{#label}} with value "{[.]}" fails to match the required pattern: {{#regex}}',
        "string.pattern.name": '{{#label}} with value "{[.]}" fails to match the {{#name}} pattern',
        "string.pattern.invert.base": '{{#label}} with value "{[.]}" matches the inverted pattern: {{#regex}}',
        "string.pattern.invert.name": '{{#label}} with value "{[.]}" matches the inverted {{#name}} pattern',
        "string.trim": "{{#label}} must not have leading or trailing whitespace",
        "string.uri": "{{#label}} must be a valid uri",
        "string.uriCustomScheme": "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern",
        "string.uriRelativeOnly": "{{#label}} must be a valid relative uri",
        "string.uppercase": "{{#label}} must only contain uppercase characters"
      }
    });
    internals.addressOptions = function(options) {
      if (!options) {
        return options;
      }
      Assert(options.minDomainSegments === void 0 || Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, "minDomainSegments must be a positive integer");
      if (options.tlds === false) {
        return options;
      }
      if (options.tlds === true || options.tlds === void 0) {
        Assert(internals.tlds, "Built-in TLD list disabled");
        return Object.assign({}, options, internals.tlds);
      }
      Assert(typeof options.tlds === "object", "tlds must be true, false, or an object");
      const deny = options.tlds.deny;
      if (deny) {
        if (Array.isArray(deny)) {
          options = Object.assign({}, options, { tlds: { deny: new Set(deny) } });
        }
        Assert(options.tlds.deny instanceof Set, "tlds.deny must be an array, Set, or boolean");
        Assert(!options.tlds.allow, "Cannot specify both tlds.allow and tlds.deny lists");
        return options;
      }
      const allow = options.tlds.allow;
      if (!allow) {
        return options;
      }
      if (allow === true) {
        Assert(internals.tlds, "Built-in TLD list disabled");
        return Object.assign({}, options, internals.tlds);
      }
      if (Array.isArray(allow)) {
        options = Object.assign({}, options, { tlds: { allow: new Set(allow) } });
      }
      Assert(options.tlds.allow instanceof Set, "tlds.allow must be an array, Set, or boolean");
      return options;
    };
    internals.isoDate = function(value) {
      if (!Common.isIsoDate(value)) {
        return null;
      }
      const date = new Date(value);
      if (isNaN(date.getTime())) {
        return null;
      }
      return date.toISOString();
    };
    internals.length = function(schema, name, limit, operator, encoding) {
      Assert(!encoding || Buffer && Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
      return schema.$_addRule({ name, method: "length", args: { limit, encoding }, operator });
    };
  }
});

// node_modules/@hapi/joi/lib/types/symbol.js
var require_symbol2 = __commonJS({
  "node_modules/@hapi/joi/lib/types/symbol.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any2();
    var internals = {};
    internals.Map = class extends Map {
      slice() {
        return new internals.Map(this);
      }
    };
    module2.exports = Any.extend({
      type: "symbol",
      terms: {
        map: { init: new internals.Map() }
      },
      coerce: {
        method(value, { schema, error }) {
          const lookup = schema.$_terms.map.get(value);
          if (lookup) {
            value = lookup;
          }
          if (!schema._flags.only || typeof value === "symbol") {
            return { value };
          }
          return { value, errors: error("symbol.map", { map: schema.$_terms.map }) };
        }
      },
      validate(value, { error }) {
        if (typeof value !== "symbol") {
          return { value, errors: error("symbol.base") };
        }
      },
      rules: {
        map: {
          method(iterable) {
            if (iterable && !iterable[Symbol.iterator] && typeof iterable === "object") {
              iterable = Object.entries(iterable);
            }
            Assert(iterable && iterable[Symbol.iterator], "Iterable must be an iterable or object");
            const obj = this.clone();
            const symbols = [];
            for (const entry of iterable) {
              Assert(entry && entry[Symbol.iterator], "Entry must be an iterable");
              const [key, value] = entry;
              Assert(typeof key !== "object" && typeof key !== "function" && typeof key !== "symbol", "Key must not be of type object, function, or Symbol");
              Assert(typeof value === "symbol", "Value must be a Symbol");
              obj.$_terms.map.set(key, value);
              symbols.push(value);
            }
            return obj.valid(...symbols);
          }
        }
      },
      manifest: {
        build(obj, desc) {
          if (desc.map) {
            obj = obj.map(desc.map);
          }
          return obj;
        }
      },
      messages: {
        "symbol.base": "{{#label}} must be a symbol",
        "symbol.map": "{{#label}} must be one of {{#map}}"
      }
    });
  }
});

// node_modules/@hapi/joi/lib/types/binary.js
var require_binary2 = __commonJS({
  "node_modules/@hapi/joi/lib/types/binary.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Any = require_any2();
    var Common = require_common2();
    module2.exports = Any.extend({
      type: "binary",
      coerce: {
        from: "string",
        method(value, { schema }) {
          try {
            return { value: Buffer.from(value, schema._flags.encoding) };
          } catch (ignoreErr) {
          }
        }
      },
      validate(value, { error }) {
        if (!Buffer.isBuffer(value)) {
          return { value, errors: error("binary.base") };
        }
      },
      rules: {
        encoding: {
          method(encoding) {
            Assert(Buffer.isEncoding(encoding), "Invalid encoding:", encoding);
            return this.$_setFlag("encoding", encoding);
          }
        },
        length: {
          method(limit) {
            return this.$_addRule({ name: "length", method: "length", args: { limit }, operator: "=" });
          },
          validate(value, helpers, { limit }, { name, operator, args }) {
            if (Common.compare(value.length, limit, operator)) {
              return value;
            }
            return helpers.error("binary." + name, { limit: args.limit, value });
          },
          args: [
            {
              name: "limit",
              ref: true,
              assert: Common.limit,
              message: "must be a positive integer"
            }
          ]
        },
        max: {
          method(limit) {
            return this.$_addRule({ name: "max", method: "length", args: { limit }, operator: "<=" });
          }
        },
        min: {
          method(limit) {
            return this.$_addRule({ name: "min", method: "length", args: { limit }, operator: ">=" });
          }
        }
      },
      cast: {
        string: {
          from: (value) => Buffer.isBuffer(value),
          to(value, helpers) {
            return value.toString();
          }
        }
      },
      messages: {
        "binary.base": "{{#label}} must be a buffer or a string",
        "binary.length": "{{#label}} must be {{#limit}} bytes",
        "binary.max": "{{#label}} must be less than or equal to {{#limit}} bytes",
        "binary.min": "{{#label}} must be at least {{#limit}} bytes"
      }
    });
  }
});

// node_modules/@hapi/joi/lib/index.js
var require_lib32 = __commonJS({
  "node_modules/@hapi/joi/lib/index.js"(exports, module2) {
    "use strict";
    var Assert = require_assert();
    var Clone = require_clone();
    var Cache = require_cache();
    var Common = require_common2();
    var Compile = require_compile2();
    var Errors = require_errors2();
    var Extend = require_extend2();
    var Manifest = require_manifest();
    var Ref = require_ref2();
    var Template = require_template2();
    var Trace = require_trace();
    var Schemas;
    var internals = {
      types: {
        alternatives: require_alternatives2(),
        any: require_any2(),
        array: require_array2(),
        boolean: require_boolean2(),
        date: require_date2(),
        function: require_function2(),
        link: require_link2(),
        number: require_number2(),
        object: require_object2(),
        string: require_string2(),
        symbol: require_symbol2()
      },
      aliases: {
        alt: "alternatives",
        bool: "boolean",
        func: "function"
      }
    };
    if (Buffer) {
      internals.types.binary = require_binary2();
    }
    internals.root = function() {
      const root = {
        _types: new Set(Object.keys(internals.types))
      };
      for (const type of root._types) {
        root[type] = function(...args) {
          Assert(!args.length || ["alternatives", "link", "object"].includes(type), "The", type, "type does not allow arguments");
          return internals.generate(this, internals.types[type], args);
        };
      }
      for (const method of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"]) {
        root[method] = function(...args) {
          return this.any()[method](...args);
        };
      }
      Object.assign(root, internals.methods);
      for (const alias in internals.aliases) {
        const target = internals.aliases[alias];
        root[alias] = root[target];
      }
      root.x = root.expression;
      if (Trace.setup) {
        Trace.setup(root);
      }
      return root;
    };
    internals.methods = {
      ValidationError: Errors.ValidationError,
      version: Common.version,
      cache: Cache.provider,
      assert(value, schema, ...args) {
        internals.assert(value, schema, true, args);
      },
      attempt(value, schema, ...args) {
        return internals.assert(value, schema, false, args);
      },
      build(desc) {
        Assert(typeof Manifest.build === "function", "Manifest functionality disabled");
        return Manifest.build(this, desc);
      },
      checkPreferences(prefs) {
        Common.checkPreferences(prefs);
      },
      compile(schema, options) {
        return Compile.compile(this, schema, options);
      },
      defaults(modifier) {
        Assert(typeof modifier === "function", "modifier must be a function");
        const joi = Object.assign({}, this);
        for (const type of joi._types) {
          const schema = modifier(joi[type]());
          Assert(Common.isSchema(schema), "modifier must return a valid schema object");
          joi[type] = function(...args) {
            return internals.generate(this, schema, args);
          };
        }
        return joi;
      },
      expression(...args) {
        return new Template(...args);
      },
      extend(...extensions) {
        Common.verifyFlat(extensions, "extend");
        Schemas = Schemas || require_schemas2();
        Assert(extensions.length, "You need to provide at least one extension");
        this.assert(extensions, Schemas.extensions);
        const joi = Object.assign({}, this);
        joi._types = new Set(joi._types);
        for (let extension of extensions) {
          if (typeof extension === "function") {
            extension = extension(joi);
          }
          this.assert(extension, Schemas.extension);
          const expanded = internals.expandExtension(extension, joi);
          for (const item of expanded) {
            Assert(joi[item.type] === void 0 || joi._types.has(item.type), "Cannot override name", item.type);
            const base = item.base || this.any();
            const schema = Extend.type(base, item);
            joi._types.add(item.type);
            joi[item.type] = function(...args) {
              return internals.generate(this, schema, args);
            };
          }
        }
        return joi;
      },
      isError: Errors.ValidationError.isError,
      isExpression: Template.isTemplate,
      isRef: Ref.isRef,
      isSchema: Common.isSchema,
      in(...args) {
        return Ref.in(...args);
      },
      override: Common.symbols.override,
      ref(...args) {
        return Ref.create(...args);
      },
      types() {
        const types = {};
        for (const type of this._types) {
          types[type] = this[type]();
        }
        for (const target in internals.aliases) {
          types[target] = this[target]();
        }
        return types;
      }
    };
    internals.assert = function(value, schema, annotate, args) {
      const message = args[0] instanceof Error || typeof args[0] === "string" ? args[0] : null;
      const options = message ? args[1] : args[0];
      const result = schema.validate(value, Common.preferences({ errors: { stack: true } }, options || {}));
      let error = result.error;
      if (!error) {
        return result.value;
      }
      if (message instanceof Error) {
        throw message;
      }
      const display = annotate && typeof error.annotate === "function" ? error.annotate() : error.message;
      if (error instanceof Errors.ValidationError === false) {
        error = Clone(error);
      }
      error.message = message ? `${message} ${display}` : display;
      throw error;
    };
    internals.generate = function(root, schema, args) {
      Assert(root, "Must be invoked on a Joi instance.");
      schema.$_root = root;
      if (!schema._definition.args || !args.length) {
        return schema;
      }
      return schema._definition.args(schema, ...args);
    };
    internals.expandExtension = function(extension, joi) {
      if (typeof extension.type === "string") {
        return [extension];
      }
      const extended = [];
      for (const type of joi._types) {
        if (extension.type.test(type)) {
          const item = Object.assign({}, extension);
          item.type = type;
          item.base = joi[type]();
          extended.push(item);
        }
      }
      return extended;
    };
    module2.exports = internals.root();
  }
});

// node_modules/@aws-lambda-powertools/logger/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/@aws-lambda-powertools/logger/lib/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createLogger = void 0;
    var _1 = require_lib34();
    var createLogger2 = (options = {}) => new _1.Logger(options);
    exports.createLogger = createLogger2;
  }
});

// node_modules/@aws-lambda-powertools/commons/lib/utils/lambda/LambdaInterface.js
var require_LambdaInterface = __commonJS({
  "node_modules/@aws-lambda-powertools/commons/lib/utils/lambda/LambdaInterface.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aws-lambda-powertools/commons/lib/utils/lambda/index.js
var require_lambda = __commonJS({
  "node_modules/@aws-lambda-powertools/commons/lib/utils/lambda/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_LambdaInterface(), exports);
  }
});

// node_modules/@aws-lambda-powertools/commons/lib/Utility.js
var require_Utility = __commonJS({
  "node_modules/@aws-lambda-powertools/commons/lib/Utility.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Utility = void 0;
    var Utility = class {
      constructor() {
        this.coldStart = true;
      }
      getColdStart() {
        if (this.coldStart) {
          this.coldStart = false;
          return true;
        }
        return false;
      }
      isColdStart() {
        return this.getColdStart();
      }
    };
    exports.Utility = Utility;
  }
});

// node_modules/@aws-lambda-powertools/commons/lib/config/ConfigService.js
var require_ConfigService = __commonJS({
  "node_modules/@aws-lambda-powertools/commons/lib/config/ConfigService.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigService = void 0;
    var ConfigService = class {
    };
    exports.ConfigService = ConfigService;
  }
});

// node_modules/@aws-lambda-powertools/commons/lib/config/EnvironmentVariablesService.js
var require_EnvironmentVariablesService = __commonJS({
  "node_modules/@aws-lambda-powertools/commons/lib/config/EnvironmentVariablesService.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EnvironmentVariablesService = void 0;
    var _1 = require_config2();
    var EnvironmentVariablesService = class extends _1.ConfigService {
      constructor() {
        super(...arguments);
        this.serviceNameVariable = "POWERTOOLS_SERVICE_NAME";
        this.xRayTraceIdVariable = "_X_AMZN_TRACE_ID";
      }
      get(name) {
        var _a;
        return ((_a = process.env[name]) === null || _a === void 0 ? void 0 : _a.trim()) || "";
      }
      getServiceName() {
        return this.get(this.serviceNameVariable);
      }
      getXrayTraceId() {
        const xRayTraceId = this.get(this.xRayTraceIdVariable);
        if (xRayTraceId === "")
          return void 0;
        return xRayTraceId.split(";")[0].replace("Root=", "");
      }
    };
    exports.EnvironmentVariablesService = EnvironmentVariablesService;
  }
});

// node_modules/@aws-lambda-powertools/commons/lib/config/index.js
var require_config2 = __commonJS({
  "node_modules/@aws-lambda-powertools/commons/lib/config/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ConfigService(), exports);
    __exportStar(require_EnvironmentVariablesService(), exports);
  }
});

// node_modules/@aws-lambda-powertools/commons/lib/samples/resources/contexts/hello-world.js
var require_hello_world = __commonJS({
  "node_modules/@aws-lambda-powertools/commons/lib/samples/resources/contexts/hello-world.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.helloworldContext = void 0;
    var helloworldContext = {
      callbackWaitsForEmptyEventLoop: true,
      functionVersion: "$LATEST",
      functionName: "foo-bar-function",
      memoryLimitInMB: "128",
      logGroupName: "/aws/lambda/foo-bar-function-123456abcdef",
      logStreamName: "2021/03/09/[$LATEST]abcdef123456abcdef123456abcdef123456",
      invokedFunctionArn: "arn:aws:lambda:eu-west-1:123456789012:function:Example",
      awsRequestId: "c6af9ac6-7b61-11e6-9a41-93e8deadbeef",
      getRemainingTimeInMillis: () => 1234,
      done: () => console.log("Done!"),
      fail: () => console.log("Failed!"),
      succeed: () => console.log("Succeeded!")
    };
    exports.helloworldContext = helloworldContext;
  }
});

// node_modules/@aws-lambda-powertools/commons/lib/samples/resources/contexts/index.js
var require_contexts = __commonJS({
  "node_modules/@aws-lambda-powertools/commons/lib/samples/resources/contexts/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_hello_world(), exports);
  }
});

// node_modules/@aws-lambda-powertools/commons/lib/samples/resources/events/custom/index.js
var require_custom = __commonJS({
  "node_modules/@aws-lambda-powertools/commons/lib/samples/resources/events/custom/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CustomEvent = void 0;
    exports.CustomEvent = {
      key1: "value1",
      key2: "value2",
      key3: "value3"
    };
  }
});

// node_modules/@aws-lambda-powertools/commons/lib/samples/resources/events/index.js
var require_events = __commonJS({
  "node_modules/@aws-lambda-powertools/commons/lib/samples/resources/events/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Custom = void 0;
    exports.Custom = require_custom();
  }
});

// node_modules/@aws-lambda-powertools/commons/lib/index.js
var require_lib33 = __commonJS({
  "node_modules/@aws-lambda-powertools/commons/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Events = exports.ContextExamples = void 0;
    __exportStar(require_lambda(), exports);
    __exportStar(require_Utility(), exports);
    __exportStar(require_config2(), exports);
    exports.ContextExamples = require_contexts();
    exports.Events = require_events();
  }
});

// node_modules/@aws-lambda-powertools/logger/lib/formatter/LogFormatter.js
var require_LogFormatter = __commonJS({
  "node_modules/@aws-lambda-powertools/logger/lib/formatter/LogFormatter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LogFormatter = void 0;
    var LogFormatter = class {
      formatError(error) {
        return {
          name: error.name,
          location: this.getCodeLocation(error.stack),
          message: error.message,
          stack: error.stack
        };
      }
      formatTimestamp(now) {
        return now.toISOString();
      }
      getCodeLocation(stack) {
        if (!stack) {
          return "";
        }
        const stackLines = stack.split("\n");
        const regex = /\((.*):(\d+):(\d+)\)\\?$/;
        let i;
        for (i = 0; i < stackLines.length; i++) {
          const match = regex.exec(stackLines[i]);
          if (Array.isArray(match)) {
            return `${match[1]}:${Number(match[2])}`;
          }
        }
        return "";
      }
    };
    exports.LogFormatter = LogFormatter;
  }
});

// node_modules/@aws-lambda-powertools/logger/lib/formatter/LogFormatterInterface.js
var require_LogFormatterInterface = __commonJS({
  "node_modules/@aws-lambda-powertools/logger/lib/formatter/LogFormatterInterface.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aws-lambda-powertools/logger/lib/formatter/PowertoolLogFormatter.js
var require_PowertoolLogFormatter = __commonJS({
  "node_modules/@aws-lambda-powertools/logger/lib/formatter/PowertoolLogFormatter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PowertoolLogFormatter = void 0;
    var _1 = require_formatter();
    var PowertoolLogFormatter = class extends _1.LogFormatter {
      formatAttributes(attributes) {
        var _a, _b, _c, _d, _e;
        return {
          cold_start: (_a = attributes.lambdaContext) === null || _a === void 0 ? void 0 : _a.coldStart,
          function_arn: (_b = attributes.lambdaContext) === null || _b === void 0 ? void 0 : _b.invokedFunctionArn,
          function_memory_size: (_c = attributes.lambdaContext) === null || _c === void 0 ? void 0 : _c.memoryLimitInMB,
          function_name: (_d = attributes.lambdaContext) === null || _d === void 0 ? void 0 : _d.functionName,
          function_request_id: (_e = attributes.lambdaContext) === null || _e === void 0 ? void 0 : _e.awsRequestId,
          level: attributes.logLevel,
          message: attributes.message,
          sampling_rate: attributes.sampleRateValue,
          service: attributes.serviceName,
          timestamp: this.formatTimestamp(attributes.timestamp),
          xray_trace_id: attributes.xRayTraceId
        };
      }
    };
    exports.PowertoolLogFormatter = PowertoolLogFormatter;
  }
});

// node_modules/@aws-lambda-powertools/logger/lib/formatter/index.js
var require_formatter = __commonJS({
  "node_modules/@aws-lambda-powertools/logger/lib/formatter/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_LogFormatter(), exports);
    __exportStar(require_LogFormatterInterface(), exports);
    __exportStar(require_PowertoolLogFormatter(), exports);
  }
});

// node_modules/lodash.pickby/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.pickby/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function basePickBy(object, props, predicate) {
      var index = -1, length = props.length, result = {};
      while (++index < length) {
        var key = props[index], value = object[key];
        if (predicate(value, key)) {
          result[key] = value;
        }
      }
      return result;
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    function pickBy(object, predicate) {
      return object == null ? {} : basePickBy(object, getAllKeysIn(object), baseIteratee(predicate));
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    function stubArray() {
      return [];
    }
    module2.exports = pickBy;
  }
});

// node_modules/lodash.merge/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.merge/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module2.exports = merge;
  }
});

// node_modules/@aws-lambda-powertools/logger/lib/log/LogItem.js
var require_LogItem = __commonJS({
  "node_modules/@aws-lambda-powertools/logger/lib/log/LogItem.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LogItem = void 0;
    var lodash_pickby_1 = __importDefault(require_lodash());
    var lodash_merge_1 = __importDefault(require_lodash2());
    var LogItem = class {
      constructor(params) {
        this.attributes = {};
        this.addAttributes(params.baseAttributes);
        this.addAttributes(params.persistentAttributes);
      }
      addAttributes(attributes) {
        this.attributes = (0, lodash_merge_1.default)(this.attributes, attributes);
        return this;
      }
      getAttributes() {
        return this.attributes;
      }
      prepareForPrint() {
        this.setAttributes(this.removeEmptyKeys(this.getAttributes()));
      }
      removeEmptyKeys(attributes) {
        return (0, lodash_pickby_1.default)(attributes, (value) => value !== void 0 && value !== "" && value !== null);
      }
      setAttributes(attributes) {
        this.attributes = attributes;
      }
    };
    exports.LogItem = LogItem;
  }
});

// node_modules/@aws-lambda-powertools/logger/lib/log/LogItemInterface.js
var require_LogItemInterface = __commonJS({
  "node_modules/@aws-lambda-powertools/logger/lib/log/LogItemInterface.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aws-lambda-powertools/logger/lib/log/index.js
var require_log = __commonJS({
  "node_modules/@aws-lambda-powertools/logger/lib/log/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_LogItem(), exports);
    __exportStar(require_LogItemInterface(), exports);
  }
});

// node_modules/lodash.clonedeep/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.clonedeep/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function cloneDeep(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module2.exports = cloneDeep;
  }
});

// node_modules/@aws-lambda-powertools/logger/lib/config/ConfigServiceInterface.js
var require_ConfigServiceInterface = __commonJS({
  "node_modules/@aws-lambda-powertools/logger/lib/config/ConfigServiceInterface.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@aws-lambda-powertools/logger/lib/config/EnvironmentVariablesService.js
var require_EnvironmentVariablesService2 = __commonJS({
  "node_modules/@aws-lambda-powertools/logger/lib/config/EnvironmentVariablesService.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EnvironmentVariablesService = void 0;
    var commons_1 = require_lib33();
    var EnvironmentVariablesService = class extends commons_1.EnvironmentVariablesService {
      constructor() {
        super(...arguments);
        this.awsRegionVariable = "AWS_REGION";
        this.currentEnvironmentVariable = "ENVIRONMENT";
        this.functionNameVariable = "AWS_LAMBDA_FUNCTION_NAME";
        this.functionVersionVariable = "AWS_LAMBDA_FUNCTION_VERSION";
        this.logEventVariable = "POWERTOOLS_LOGGER_LOG_EVENT";
        this.logLevelVariable = "LOG_LEVEL";
        this.memoryLimitInMBVariable = "AWS_LAMBDA_FUNCTION_MEMORY_SIZE";
        this.sampleRateValueVariable = "POWERTOOLS_LOGGER_SAMPLE_RATE";
      }
      getAwsRegion() {
        return this.get(this.awsRegionVariable);
      }
      getCurrentEnvironment() {
        return this.get(this.currentEnvironmentVariable);
      }
      getFunctionMemory() {
        const value = this.get(this.memoryLimitInMBVariable);
        return Number(value);
      }
      getFunctionName() {
        return this.get(this.functionNameVariable);
      }
      getFunctionVersion() {
        return this.get(this.functionVersionVariable);
      }
      getLogEvent() {
        const value = this.get(this.logEventVariable);
        return value.toLowerCase() === "true" || value === "1";
      }
      getLogLevel() {
        return this.get(this.logLevelVariable);
      }
      getSampleRateValue() {
        const value = this.get(this.sampleRateValueVariable);
        return value && value.length > 0 ? Number(value) : void 0;
      }
    };
    exports.EnvironmentVariablesService = EnvironmentVariablesService;
  }
});

// node_modules/@aws-lambda-powertools/logger/lib/config/index.js
var require_config3 = __commonJS({
  "node_modules/@aws-lambda-powertools/logger/lib/config/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_ConfigServiceInterface(), exports);
    __exportStar(require_EnvironmentVariablesService2(), exports);
  }
});

// node_modules/@aws-lambda-powertools/logger/lib/Logger.js
var require_Logger = __commonJS({
  "node_modules/@aws-lambda-powertools/logger/lib/Logger.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Logger = void 0;
    var console_1 = require("console");
    var commons_1 = require_lib33();
    var formatter_1 = require_formatter();
    var log_1 = require_log();
    var lodash_clonedeep_1 = __importDefault(require_lodash3());
    var lodash_merge_1 = __importDefault(require_lodash2());
    var config_1 = require_config3();
    var Logger2 = class extends commons_1.Utility {
      constructor(options = {}) {
        super();
        this.console = new console_1.Console({ stdout: process.stdout, stderr: process.stderr });
        this.logEvent = false;
        this.logLevelThresholds = {
          DEBUG: 8,
          INFO: 12,
          WARN: 16,
          ERROR: 20
        };
        this.logsSampled = false;
        this.persistentLogAttributes = {};
        this.powertoolLogData = {};
        this.setOptions(options);
      }
      addContext(context) {
        const lambdaContext = {
          invokedFunctionArn: context.invokedFunctionArn,
          coldStart: this.getColdStart(),
          awsRequestId: context.awsRequestId,
          memoryLimitInMB: Number(context.memoryLimitInMB),
          functionName: context.functionName,
          functionVersion: context.functionVersion
        };
        this.addToPowertoolLogData({
          lambdaContext
        });
      }
      addPersistentLogAttributes(attributes) {
        (0, lodash_merge_1.default)(this.persistentLogAttributes, attributes);
      }
      appendKeys(attributes) {
        this.addPersistentLogAttributes(attributes);
      }
      createChild(options = {}) {
        return (0, lodash_clonedeep_1.default)(this).setOptions(options);
      }
      debug(input, ...extraInput) {
        this.processLogItem("DEBUG", input, extraInput);
      }
      error(input, ...extraInput) {
        this.processLogItem("ERROR", input, extraInput);
      }
      getLogEvent() {
        return this.logEvent;
      }
      getLogsSampled() {
        return this.logsSampled;
      }
      getPersistentLogAttributes() {
        return this.persistentLogAttributes;
      }
      info(input, ...extraInput) {
        this.processLogItem("INFO", input, extraInput);
      }
      injectLambdaContext(options) {
        return (_target, _propertyKey, descriptor) => {
          const originalMethod = descriptor.value;
          const loggerRef = this;
          descriptor.value = async function(event, context, callback) {
            let initialPersistentAttributes = {};
            if (options && options.clearState === true) {
              initialPersistentAttributes = { ...loggerRef.getPersistentLogAttributes() };
            }
            Logger2.injectLambdaContextBefore(loggerRef, event, context, options);
            let result;
            try {
              result = await originalMethod.apply(this, [event, context, callback]);
            } catch (error) {
              throw error;
            } finally {
              Logger2.injectLambdaContextAfterOrOnError(loggerRef, initialPersistentAttributes, options);
            }
            return result;
          };
        };
      }
      static injectLambdaContextAfterOrOnError(logger2, initialPersistentAttributes, options) {
        if (options && options.clearState === true) {
          logger2.setPersistentLogAttributes(initialPersistentAttributes);
        }
      }
      static injectLambdaContextBefore(logger2, event, context, options) {
        logger2.addContext(context);
        let shouldLogEvent = void 0;
        if (options && options.hasOwnProperty("logEvent")) {
          shouldLogEvent = options.logEvent;
        }
        logger2.logEventIfEnabled(event, shouldLogEvent);
      }
      logEventIfEnabled(event, overwriteValue) {
        if (!this.shouldLogEvent(overwriteValue)) {
          return;
        }
        this.info("Lambda invocation event", { event });
      }
      refreshSampleRateCalculation() {
        this.setLogsSampled();
      }
      removeKeys(keys) {
        this.removePersistentLogAttributes(keys);
      }
      removePersistentLogAttributes(keys) {
        keys.forEach((key) => {
          if (this.persistentLogAttributes && key in this.persistentLogAttributes) {
            delete this.persistentLogAttributes[key];
          }
        });
      }
      setPersistentLogAttributes(attributes) {
        this.persistentLogAttributes = attributes;
      }
      setSampleRateValue(sampleRateValue) {
        var _a;
        this.powertoolLogData.sampleRateValue = sampleRateValue || ((_a = this.getCustomConfigService()) === null || _a === void 0 ? void 0 : _a.getSampleRateValue()) || this.getEnvVarsService().getSampleRateValue();
      }
      shouldLogEvent(overwriteValue) {
        if (typeof overwriteValue === "boolean") {
          return overwriteValue;
        }
        return this.getLogEvent();
      }
      warn(input, ...extraInput) {
        this.processLogItem("WARN", input, extraInput);
      }
      addToPowertoolLogData(...attributesArray) {
        attributesArray.forEach((attributes) => {
          (0, lodash_merge_1.default)(this.powertoolLogData, attributes);
        });
      }
      createAndPopulateLogItem(logLevel, input, extraInput) {
        const unformattedBaseAttributes = (0, lodash_merge_1.default)({
          logLevel,
          timestamp: new Date(),
          message: typeof input === "string" ? input : input.message,
          xRayTraceId: this.envVarsService.getXrayTraceId()
        }, this.getPowertoolLogData());
        const logItem = new log_1.LogItem({
          baseAttributes: this.getLogFormatter().formatAttributes(unformattedBaseAttributes),
          persistentAttributes: this.getPersistentLogAttributes()
        });
        if (typeof input !== "string") {
          logItem.addAttributes(input);
        }
        extraInput.forEach((item) => {
          const attributes = item instanceof Error ? { error: item } : typeof item === "string" ? { extra: item } : item;
          logItem.addAttributes(attributes);
        });
        return logItem;
      }
      getCustomConfigService() {
        return this.customConfigService;
      }
      getEnvVarsService() {
        return this.envVarsService;
      }
      getLogFormatter() {
        return this.logFormatter;
      }
      getLogLevel() {
        return this.logLevel;
      }
      getPowertoolLogData() {
        return this.powertoolLogData;
      }
      getSampleRateValue() {
        if (!this.powertoolLogData.sampleRateValue) {
          this.setSampleRateValue();
        }
        return this.powertoolLogData.sampleRateValue;
      }
      isValidLogLevel(logLevel) {
        return typeof logLevel === "string" && logLevel.toUpperCase() in this.logLevelThresholds;
      }
      printLog(logLevel, log) {
        log.prepareForPrint();
        const consoleMethod = logLevel.toLowerCase();
        this.console[consoleMethod](JSON.stringify(log.getAttributes(), this.removeCircularDependencies()));
      }
      processLogItem(logLevel, input, extraInput) {
        if (!this.shouldPrint(logLevel)) {
          return;
        }
        this.printLog(logLevel, this.createAndPopulateLogItem(logLevel, input, extraInput));
      }
      removeCircularDependencies() {
        const references = /* @__PURE__ */ new WeakSet();
        return (key, value) => {
          let item = value;
          if (item instanceof Error) {
            item = this.getLogFormatter().formatError(item);
          }
          if (typeof item === "object" && value !== null) {
            if (references.has(item)) {
              return;
            }
            references.add(item);
          }
          return item;
        };
      }
      setCustomConfigService(customConfigService) {
        this.customConfigService = customConfigService ? customConfigService : void 0;
      }
      setEnvVarsService() {
        this.envVarsService = new config_1.EnvironmentVariablesService();
      }
      setLogEvent() {
        if (this.getEnvVarsService().getLogEvent()) {
          this.logEvent = true;
        }
      }
      setLogFormatter(logFormatter) {
        this.logFormatter = logFormatter || new formatter_1.PowertoolLogFormatter();
      }
      setLogLevel(logLevel) {
        var _a;
        if (this.isValidLogLevel(logLevel)) {
          this.logLevel = logLevel.toUpperCase();
          return;
        }
        const customConfigValue = (_a = this.getCustomConfigService()) === null || _a === void 0 ? void 0 : _a.getLogLevel();
        if (this.isValidLogLevel(customConfigValue)) {
          this.logLevel = customConfigValue.toUpperCase();
          return;
        }
        const envVarsValue = this.getEnvVarsService().getLogLevel();
        if (this.isValidLogLevel(envVarsValue)) {
          this.logLevel = envVarsValue.toUpperCase();
          return;
        }
        this.logLevel = Logger2.defaultLogLevel;
      }
      setLogsSampled() {
        const sampleRateValue = this.getSampleRateValue();
        this.logsSampled = sampleRateValue !== void 0 && (sampleRateValue === 1 || Math.random() < sampleRateValue);
      }
      setOptions(options) {
        const { logLevel, serviceName, sampleRateValue, logFormatter, customConfigService, persistentLogAttributes, environment } = options;
        this.setEnvVarsService();
        this.setCustomConfigService(customConfigService);
        this.setLogLevel(logLevel);
        this.setSampleRateValue(sampleRateValue);
        this.setLogsSampled();
        this.setLogFormatter(logFormatter);
        this.setPowertoolLogData(serviceName, environment);
        this.setLogEvent();
        this.addPersistentLogAttributes(persistentLogAttributes);
        return this;
      }
      setPowertoolLogData(serviceName, environment, persistentLogAttributes = {}) {
        var _a, _b;
        this.addToPowertoolLogData({
          awsRegion: this.getEnvVarsService().getAwsRegion(),
          environment: environment || ((_a = this.getCustomConfigService()) === null || _a === void 0 ? void 0 : _a.getCurrentEnvironment()) || this.getEnvVarsService().getCurrentEnvironment(),
          sampleRateValue: this.getSampleRateValue(),
          serviceName: serviceName || ((_b = this.getCustomConfigService()) === null || _b === void 0 ? void 0 : _b.getServiceName()) || this.getEnvVarsService().getServiceName() || Logger2.defaultServiceName
        }, persistentLogAttributes);
      }
      shouldPrint(logLevel) {
        if (this.logLevelThresholds[logLevel] >= this.logLevelThresholds[this.getLogLevel()]) {
          return true;
        }
        return this.getLogsSampled();
      }
    };
    exports.Logger = Logger2;
    Logger2.defaultLogLevel = "INFO";
    Logger2.defaultServiceName = "service_undefined";
  }
});

// node_modules/@aws-lambda-powertools/logger/lib/middleware/middy.js
var require_middy = __commonJS({
  "node_modules/@aws-lambda-powertools/logger/lib/middleware/middy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.injectLambdaContext = void 0;
    var Logger_1 = require_Logger();
    var injectLambdaContext = (target, options) => {
      const loggers = target instanceof Array ? target : [target];
      const persistentAttributes = [];
      const injectLambdaContextBefore = async (request) => {
        loggers.forEach((logger2) => {
          if (options && options.clearState === true) {
            persistentAttributes.push({ ...logger2.getPersistentLogAttributes() });
          }
          Logger_1.Logger.injectLambdaContextBefore(logger2, request.event, request.context, options);
        });
      };
      const injectLambdaContextAfterOrOnError = async () => {
        if (options && options.clearState === true) {
          loggers.forEach((logger2, index) => {
            Logger_1.Logger.injectLambdaContextAfterOrOnError(logger2, persistentAttributes[index], options);
          });
        }
      };
      return {
        before: injectLambdaContextBefore,
        after: injectLambdaContextAfterOrOnError,
        onError: injectLambdaContextAfterOrOnError
      };
    };
    exports.injectLambdaContext = injectLambdaContext;
  }
});

// node_modules/@aws-lambda-powertools/logger/lib/middleware/index.js
var require_middleware = __commonJS({
  "node_modules/@aws-lambda-powertools/logger/lib/middleware/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_middy(), exports);
  }
});

// node_modules/@aws-lambda-powertools/logger/lib/index.js
var require_lib34 = __commonJS({
  "node_modules/@aws-lambda-powertools/logger/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_helpers(), exports);
    __exportStar(require_Logger(), exports);
    __exportStar(require_middleware(), exports);
    __exportStar(require_formatter(), exports);
  }
});

// src/lambdas/index.ts
var lambdas_exports = {};
__export(lambdas_exports, {
  handler: () => handler
});
module.exports = __toCommonJS(lambdas_exports);

// src/utils/server.ts
var Hapi = __toESM(require_lib29());

// src/routes/resource/schemas.ts
var import_joi = __toESM(require_lib32());
var getResourceByIdRequestSchema = import_joi.default.object({
  id: import_joi.default.string().uuid().required()
});
var getResourceResponseSchema = import_joi.default.object({
  code: import_joi.default.number(),
  payload: import_joi.default.object()
});
var errorResponseSchema = import_joi.default.object({
  correlationId: import_joi.default.string(),
  timestamp: import_joi.default.string(),
  results: import_joi.default.array().items({
    statusSet: import_joi.default.array().items({
      errorCode: import_joi.default.alternatives(import_joi.default.string(), import_joi.default.number()),
      moreInfo: import_joi.default.string(),
      details: import_joi.default.string()
    })
  })
});

// src/controllers/base.ts
var BaseController = class {
  request;
  corellationId;
  logger;
  constructor(request) {
    this.request = request;
    this.corellationId = request.headers["s37-correlation-id"] || request.correlationId;
  }
  response(payload, responseCode = 200) {
    return {
      payload,
      code: responseCode
    };
  }
};

// src/services/database.ts
var DatabaseService = class {
  tenantConfig;
  request;
  corellationId;
  constructor(request) {
    this.request = request;
  }
  async getPool() {
  }
  async withTransaction(connection, callback) {
    try {
      connection.beginTransaction();
      await callback();
      connection.commit();
    } catch (err) {
      connection.rollback();
    }
  }
};

// src/services/resource.ts
var ResourceService = class extends DatabaseService {
  query;
  params;
  payload;
  input;
  client;
  constructor(request) {
    var _a, _b, _c;
    super(request);
    this.query = (_a = request.pre) == null ? void 0 : _a.query;
    this.payload = (_b = request.pre) == null ? void 0 : _b.payload;
    this.params = request.params;
    this.input = (_c = request.pre) == null ? void 0 : _c.input;
  }
  parseResults(results) {
    const payload = {
      data: results,
      limit: 1,
      start: 1,
      total: 1
    };
    return payload;
  }
  async getResources() {
    return new Promise((resolve, reject) => {
      const err = "";
      if (err)
        reject(err);
      const payload = this.parseResults(["resource1", "resource2"]);
      resolve({ payload, code: 200 });
    });
  }
  async getResourceById() {
    return new Promise((resolve, reject) => {
      const err = "";
      if (err)
        reject(err);
      const payload = this.parseResults([this.params || "resource1"]);
      resolve({ payload, code: 200 });
    });
  }
};

// src/controllers/resource.ts
var ResourceController = class extends BaseController {
  query;
  params;
  payload;
  service;
  constructor(request) {
    var _a, _b, _c;
    super(request);
    this.query = (_a = request.pre) == null ? void 0 : _a.query;
    this.params = (_b = request.pre) == null ? void 0 : _b.params;
    this.payload = (_c = request.pre) == null ? void 0 : _c.payload;
    this.service = new ResourceService(request);
  }
  async getResources() {
    const { payload, code } = await this.service.getResources();
    return this.response(payload, code);
  }
  async getResourceById() {
    const { payload, code } = await this.service.getResourceById();
    return this.response(payload, code);
  }
};

// src/errors/apiError.ts
var ApiError = class {
  correlationId;
  details;
  httpCode;
  message;
  timestamp;
  constructor(status, message, correlationId, details = "") {
    this.timestamp = new Date().toISOString();
    this.httpCode = status;
    this.message = message;
    this.correlationId = correlationId;
    this.details = details;
  }
  getHttpCode() {
    return this.httpCode;
  }
  getLogMessage() {
    return `${this.details} | ${this.message}`;
  }
  getResponseData() {
    return {
      correlationId: this.correlationId,
      timestamp: this.timestamp,
      results: [
        {
          statusSet: [
            {
              errorCode: this.httpCode,
              moreInfo: this.message,
              details: this.details
            }
          ]
        }
      ]
    };
  }
};
var apiError_default = ApiError;

// src/errors/exceptionHandler.ts
var ExceptionHandler = class {
  correlationId;
  request;
  constructor(request) {
    const { headers = {}, pre = {} } = request || {};
    const { correlationId = "" } = pre;
    this.correlationId = headers["s37-correlation-id"] || correlationId;
    this.request = request;
  }
  logException(error) {
    this.request.server.log("error", error.getLogMessage());
  }
  handleHttpBadRequest(message, details = "400 Bad Request") {
    const error = new apiError_default(400, message, this.correlationId, details);
    return this.buildResponse(error);
  }
  handleMissingRequestHeader(message, details = "400 Bad Request") {
    const error = new apiError_default(400, message, this.correlationId, details);
    return this.buildResponse(error);
  }
  handleHandlerNotFound(message, details = "404 Not Found") {
    const error = new apiError_default(404, message, this.correlationId, details);
    return this.buildResponse(error);
  }
  handleNotFound(message, details = "404 Not Found") {
    return this.handleHandlerNotFound(message, details);
  }
  handleHttpMethodNotAllowed(message, details = "405 Method Not Allowed") {
    const error = new apiError_default(405, message, this.correlationId, details);
    return this.buildResponse(error);
  }
  handleDuplicateKey(message, details = "409 Conflict") {
    const error = new apiError_default(409, message, this.correlationId, details);
    return this.buildResponse(error);
  }
  handleInternalServerError(message, details = "500 Internal Server Error") {
    const error = new apiError_default(500, message, this.correlationId, details);
    return this.buildResponse(error);
  }
  buildResponse(error) {
    this.logException(error);
    return { code: error.getHttpCode(), payload: error.getResponseData() };
  }
};
var exceptionHandler_default = ExceptionHandler;

// src/routes/resource/routes.ts
var transformInput = (request) => {
  return {
    body: request.payload,
    query: request.query,
    params: request.params
  };
};
var storeCorrelationId = (request) => {
  const { params = {}, paramsArray = [], headers = {} } = request || {};
  console.log("STORING CORRELATION ID IN PRE METHOD", params, paramsArray);
  return headers["s37-correlation-id"] || "";
};
var routes_default = [
  {
    method: "GET",
    path: "/api/v1/resources",
    options: {
      tags: ["api", "languages"],
      description: "GET a collection of resources",
      notes: 'Demos using "pre" to transform the inputs and assign to a variable "input"',
      pre: [
        { method: storeCorrelationId, assign: "correlationId" },
        { method: transformInput, assign: "input" }
      ]
    },
    handler: async (request, h) => {
      request.server.log("info", `GET request on /api/v1/resources`);
      const controller = new ResourceController(request);
      const { code, payload } = await controller.getResources();
      return h.response(payload).code(code);
    }
  },
  {
    method: "GET",
    path: "/api/v1/resources/{id}",
    options: {
      tags: ["api", "languages"],
      description: "GET a single resource by id",
      notes: "Demos using Joi for request & response validation",
      pre: [{ method: storeCorrelationId, assign: "correlationId" }],
      validate: {
        params: getResourceByIdRequestSchema,
        options: {
          abortEarly: false,
          presense: "optional",
          allowUnknown: true
        },
        failAction: async (request, h, err) => {
          request.server.log("error", err);
          const { params = {} } = request || {};
          const { id = "unknown" } = params;
          const exception = new exceptionHandler_default(request);
          const { code, payload } = exception.handleHttpBadRequest(`Invalid id parameter: ${id}`);
          return h.response(payload).code(code).takeover();
        }
      },
      response: {
        status: {
          400: errorResponseSchema,
          401: errorResponseSchema
        }
      }
    },
    handler: async (request, h) => {
      const controller = new ResourceController(request);
      const { code, payload } = await controller.getResourceById();
      return h.response(payload).code(code);
    }
  }
];

// src/routes/index.ts
var routes = [...routes_default];
var registerRoutes = (server3) => {
  routes.forEach((route) => {
    server3.route(route);
  });
};

// src/utils/server.ts
var initializeServer = async () => {
  const server3 = Hapi.server();
  registerRoutes(server3);
  await server3.start();
  server3.log("info", "Started hapi server");
  return server3;
};

// src/utils/logger.ts
var import_logger = __toESM(require_lib34());
var createLogger = (config) => {
  return new import_logger.Logger(config);
};

// src/utils/index.ts
var buildFullUrl = (path, query) => {
  if (query) {
    const queryPart = Object.keys(query).map((key) => `${key}=${query[key]}`).join("&");
    return `${path}?${queryPart}`;
  }
  return path;
};

// src/lambdas/index.ts
var CORS_KEY = "access-control-allow-origin";
var CONTENT_TYPE = "content-type";
var CORRELATION_ID = "s37-correlation-id";
var responseHeaders = {
  [CORS_KEY]: "*",
  [CONTENT_TYPE]: "application/json",
  [CORRELATION_ID]: ""
};
var local = process.env["IS_LOCAL"] ? "local" : "cloud";
var logger;
var server2;
var handler = async (event, context) => {
  const { httpMethod, path, queryStringParameters, body, headers } = event;
  const serverOptions = {
    method: httpMethod,
    url: buildFullUrl(path, queryStringParameters),
    payload: body,
    headers,
    validate: false
  };
  const correlationId = headers[CORRELATION_ID];
  const { awsRequestId } = context;
  const loggerOptions = {
    persistentLogAttributes: {
      awsRequestId,
      correlationId
    }
  };
  logger = logger || createLogger(loggerOptions);
  server2 = server2 || await initializeServer();
  server2.events.on("log", (event2, tags) => {
    const { data } = event2;
    if (tags["error"]) {
      logger.error(`Request ${event2.request} error: ${data || "unknown"}`);
    }
    if (tags["info"]) {
      logger.info(`Request ${event2.request} info: ${data || "unknown"}`);
    }
  });
  try {
    logger.info(`*** event received[${local}] ***`, { url: path });
    const { statusCode, result } = await server2.inject(serverOptions);
    const responseBody = JSON.stringify(result);
    responseHeaders[CORRELATION_ID] = correlationId || "";
    return { headers: responseHeaders, body: responseBody, statusCode };
  } catch (err) {
    const { message } = err;
    logger.error(`Error: ${message}`, { err });
    return {
      statusCode: 500,
      body: message || "System Error"
    };
  } finally {
    logger.info("*** event handled ***", { url: path });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
